{"meta":{"title":"进无止境's 博客","subtitle":"","description":"","author":"Jim","url":"jingg.me"},"pages":[{"title":"About","date":"2017-04-07T10:43:03.000Z","updated":"2017-04-26T08:17:33.784Z","comments":true,"path":"about/index.html","permalink":"jingg.me/about/index.html","excerpt":"","text":"Hello, I’m Jim, contact me with email 18986218971@qq.com ."}],"posts":[{"title":"Linux select pselect poll epoll用法","slug":"Linux_select_poll","date":"2017-04-18T16:00:00.000Z","updated":"2017-04-26T13:01:14.369Z","comments":true,"path":"2017/04/19/Linux_select_poll/","link":"","permalink":"jingg.me/2017/04/19/Linux_select_poll/","excerpt":"select &amp; pselect#include &lt;sys/select.h&gt; #include &lt;sys/time.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; void FD_CLR(int fd, fd_set *set); int FD_ISSET(int fd, fd_set *set); void FD_SET(int fd, fd_set *set); void FD_ZERO(fd_set *set); int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); 监控fd状态（timeout 是到期前剩余时间） int pselect(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timespec *timeout, const sigset_t *sigmask); 除了监测fd状态，pselect精度更准，且监测signal(另外pselect的timeout参数是const的) monitor multiple file descriptors, waiting until one or more of the file descriptors become “ready” for some class of I/O operation","text":"select &amp; pselect#include &lt;sys/select.h&gt; #include &lt;sys/time.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; void FD_CLR(int fd, fd_set *set); int FD_ISSET(int fd, fd_set *set); void FD_SET(int fd, fd_set *set); void FD_ZERO(fd_set *set); int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); 监控fd状态（timeout 是到期前剩余时间） int pselect(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timespec *timeout, const sigset_t *sigmask); 除了监测fd状态，pselect精度更准，且监测signal(另外pselect的timeout参数是const的) monitor multiple file descriptors, waiting until one or more of the file descriptors become “ready” for some class of I/O operation poll &amp; ppoll#include &lt;poll.h&gt; int poll(struct pollfd *fds, nfds_t nfds, int timeout); fds: 监听事件的item数组 nfds: 数组成员数 timeout: 超时时间(unit:milliseconds, -1 mean infinite, 0 mean immediately) return: success: &gt; 0 带有revents事件的数组个数; = 0 time out 或者没有fd 事件 error: -1, errno is set int ppoll(struct pollfd *fds, nfds_t nfds, const struct timespec *timeout_ts, const sigset_t *sigmask); fds: 监听事件的item数组 nfds: 数组成员数 timeout_ts: 超时时间(unit:seconds+nanoseconds, -1:indefinitely, 0:immediately) sigmask: 监测的signal (遇到这些signal，ppoll也会返回) (NULL:indefinitely) return: success: &gt; 0 带有revents事件的数组个数; = 0 time out 或者没有fd 事件 error: -1, errno is set performs a similar task to select(2): it waits for one of a set of file descriptors to become ready to perform I/O. 结构体struct pollfd { int fd; /* in, file descriptor */ short events; /* in, requested events */ short revents; /* out, returned events */ }; The bits that may be set/returned in events and revents are defined in &lt;poll.h&gt;: POLLIN 可读 POLLPRI 紧急数据可读 POLLOUT 可读(不会block) POLLRDHUP 对端关闭, 本段hangup, 只针对stream socket fd POLLERR 错误状态 (output only，即只会出现在revents中) POLLHUP Hang up (output only，即只会出现在revents中) POLLNVAL 无效请求 (output only，即只会出现在revents中) epollThe epoll API performs a similar task to poll(2): monitoring multiple file descriptors to see if I/O is possible on any of them.The epoll API can be used either as an edge-trig‐gered or a level-triggered interface and scales well to large numbers of watched file descriptors. 模式 and LT(Level-triggered) 一般 ET(edge-triggered) 事件发生时就触发 epoll_create creates an epoll instance and returns a file descriptor referring to that instance, The more recent epoll_create1 extends the functionality. #include &lt;sys/epoll.h&gt; int epoll_create(int size); int epoll_create1(int flags); epoll_ctl register particular file descriptors interested. #include &lt;sys/epoll.h&gt; int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); epfd: return by epoll_create op: EPOLL_CTL_ADD Register the target file descriptor fd on the epoll instance EPOLL_CTL_MOD Change the event event associated with the target file descriptor fd. EPOLL_CTL_DEL Remove (deregister) the target file descriptor fd from the epoll fd: 需要监听的描述符fd event：需要监听的指定fd上的事件 typedef union epoll_data { void *ptr; int fd; uint32_t u32; uint64_t u64; } epoll_data_t; struct epoll_event { uint32_t events; // EPOLLIN EPOLLOUT EPOLLRDHUP EPOLLPRI EPOLLERR EPOLLHUP EPOLLET EPOLLONESHOT epoll_data_t data; // User data variable }; return: success 0 error -1 errno epoll_wait waits for I/O events, blocking the calling thread if no events are currently available. #include &lt;sys/epoll.h&gt; int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); int epoll_pwait(int epfd, struct epoll_event *events, int maxevents, int timeout, const sigset_t *sigmask); epfd: return by epoll_create events：out, 监听到的事件数组 maxevents: in, 需要监听到事件个数，&gt;0 timeout: time out值， (-1 mean infinite, 0 mean immediately) sigmask: 监测的signal return: the number of file descriptors ready for the requested I/O. 附（epoll 使用示例）功能: 使用epoll 实现tcp server #include &lt;iostream&gt; #include &lt;sys/socket.h&gt; #include &lt;sys/epoll.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;errno.h&gt; using namespace std; #define MAXLINE 5 #define OPEN_MAX 100 #define LISTENQ 20 #define SERV_PORT 5000 #define INFTIM 1000 void setnonblocking(int sock) { int opts; opts=fcntl(sock,F_GETFL); if(opts&lt;0) { perror(&quot;fcntl(sock,GETFL)&quot;); exit(1); } opts = opts|O_NONBLOCK; if(fcntl(sock,F_SETFL,opts)&lt;0) { perror(&quot;fcntl(sock,SETFL,opts)&quot;); exit(1); } } int main(int argc, char* argv[]) { int i, maxi, listenfd, connfd, sockfd, epfd, nfds, portnumber; ssize_t n; char line[MAXLINE]; socklen_t clilen; if (2 == argc ) { if( (portnumber = atoi(argv[1])) &lt; 0 ) { fprintf(stderr,&quot;Usage:%s portnumber/a/n&quot;, argv[0]); return 1; } } else { fprintf(stderr,&quot;Usage:%s portnumber/a/n&quot;,argv[0]); return 1; } //声明epoll_event结构体的变量,ev用于注册事件,数组用于回传要处理的事件 struct epoll_event ev, events[20]; epfd = epoll_create(256); //生成用于处理accept的epoll专用的文件描述符 if (epollfd == -1) { perror(&quot;epoll_create&quot;); exit(EXIT_FAILURE); } // set up server listen socket listenfd = socket(AF_INET, SOCK_STREAM, 0); //setnonblocking(listenfd); //把socket设置为非阻塞方式 ev.events=EPOLLIN | EPOLLET; //设置要处理的事件类型及事件触发模式 ev.data.fd=listenfd; //设置与要处理的事件相关的文件描述符 //注册epoll事件 if (epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &amp;ev) == -1) { perror(&quot;epoll_ctl: listen_sock&quot;); exit(EXIT_FAILURE); } // bind server listen socket struct sockaddr_in serveraddr; bzero(&amp;serveraddr, sizeof(serveraddr)); serveraddr.sin_family = AF_INET; char *local_addr=&quot;127.0.0.1&quot;; inet_aton(local_addr, &amp;(serveraddr.sin_addr)); serveraddr.sin_port = htons(portnumber); bind(listenfd, (sockaddr *)&amp;serveraddr, sizeof(serveraddr)); listen(listenfd, LISTENQ); maxi = 0; struct sockaddr_in clientaddr; for ( ; ; ) { nfds = epoll_wait(epfd,events,20,500); //等待epoll事件的发生 //处理所发生的所有事件 for(i=0; i&lt;nfds; ++i) { if(events[i].data.fd==listenfd)//如果新监测到一个SOCKET用户连接到了绑定的SOCKET端口，建立新的连接。 { connfd = accept(listenfd,(sockaddr *)&amp;clientaddr, &amp;clilen); if(connfd&lt;0){ perror(&quot;connfd&lt;0&quot;); exit(1); } //setnonblocking(connfd); char *str = inet_ntoa(clientaddr.sin_addr); cout &lt;&lt; &quot;accapt a connection from &quot; &lt;&lt; str &lt;&lt; endl; //设置用于读操作的文件描述符 ev.data.fd=connfd; //设置用于注测的读操作事件 ev.events=EPOLLIN|EPOLLET; //ev.events=EPOLLIN; //注册ev epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&amp;ev); } else if(events[i].events&amp;EPOLLIN)//如果是已经连接的用户，并且收到数据，那么进行读入。 { cout &lt;&lt; &quot;EPOLLIN&quot; &lt;&lt; endl; if ( (sockfd = events[i].data.fd) &lt; 0) continue; if ( (n = read(sockfd, line, MAXLINE)) &lt; 0) { if (errno == ECONNRESET) { close(sockfd); events[i].data.fd = -1; } else std::cout&lt;&lt;&quot;readline error&quot;&lt;&lt;std::endl; } else if (n == 0) { close(sockfd); events[i].data.fd = -1; } line[n] = &apos;/0&apos;; cout &lt;&lt; &quot;read &quot; &lt;&lt; line &lt;&lt; endl; //设置用于写操作的文件描述符 ev.data.fd=sockfd; //设置用于注测的写操作事件 ev.events=EPOLLOUT|EPOLLET; //修改sockfd上要处理的事件为EPOLLOUT //epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev); } else if(events[i].events&amp;EPOLLOUT) // 如果有数据发送 { sockfd = events[i].data.fd; write(sockfd, line, n); //设置用于读操作的文件描述符 ev.data.fd=sockfd; //设置用于注测的读操作事件 ev.events=EPOLLIN|EPOLLET; //修改sockfd上要处理的事件为EPOLIN epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev); } } } return 0; }","categories":[{"name":"linux","slug":"linux","permalink":"jingg.me/categories/linux/"}],"tags":[{"name":"select","slug":"select","permalink":"jingg.me/tags/select/"},{"name":"poll","slug":"poll","permalink":"jingg.me/tags/poll/"}]},{"title":"Linux inotify机制","slug":"Linux_inotify","date":"2017-04-18T16:00:00.000Z","updated":"2017-04-26T08:59:00.529Z","comments":true,"path":"2017/04/19/Linux_inotify/","link":"","permalink":"jingg.me/2017/04/19/Linux_inotify/","excerpt":"","text":"Inotify 是一个 Linux 内核特性，它监控文件系统，并且及时向专门的应用程序发出相关的事件警告，比如删除、读、写和卸载操作等。您还可以跟踪活动的源头和目标等细节。使用 inotify 很简单：创建一个文件描述符fd，附加一个或多个监视器（一个监视器 是一个路径和一组事件，对应一个描述符wd），然后使用 read() 方法从描述符fd获取事件信息。 inotify，linux内核版本 &gt;= 2.6.13 inotify C APIInotify 提供几个系统调用，它们可以构建各种各样的文件系统监控器： 1. fd = inotify_init(); / fd = inotify_init1(int flags);在内核中创建 inotify 子系统的一个实例instance，成功的话将返回一个文件描述符fd，失败则返回 -1。 就像其他系统调用一样，如果 inotify_init() 失败，请检查 errno 以获得诊断信息。 2. wd = inotify_add_watch(int fd, const char *pathname, uint32_t mask);用于添加监视器。每个监视器必须提供一个路径名和相关事件的列表（每个事件由一个常量指定，比如 IN_MODIFY）。 要监控多个事件，只需在事件之间使用逻辑操作符或&apos;|&apos;。 如果 inotify_add_watch() 成功，该调用会为已注册的监视器返回一个惟一的标识符wd; 否则，返回 -1。 使用这个标识符更改或删除监视器。 3. inotify_rm_watch(int fd, int wd);删除一个inotify实例中的监视器wd。 success return 0 ； error return -1。 删除操作将触发IN_IGNORED 事件给该wd 4. 读事件、关闭监视器、关闭inotify实例创建完inotify实例及添加监视器后，读inotify实例描述符fd，可以得到监控到的事件。 可以使用select pselect poll epoll 等避免阻塞 文件描述符上的由 inotify_init() 生成的通用 close() 删除所有活动监视器，并释放与 inotify 实例相关联的所有内存（这里也用到典型的引用计数警告。与实例相关联的所有文件描述符必须在监视器和 inotify 消耗的内存被释放之前关闭）。 5. 使用技巧/注意事项如果监视中的文件或目录被删除，它的监视器也会被自动删除（在删除事件发出之后）。 如果在已卸载的文件系统上监控文件或目录，监视器将在删除所有受影响的监视之前收到一个卸载事件。 将 IN_ONESHOT 标志添加到监视器标记中，设置一个一次性警告。警告在发送之后将被删除。 要修改一个事件，必须提供相同的路径名和不同的标记。新监视器将取代老监视器。 考虑到实用性，不可能耗尽任何一个 inotify 实例的监视器。然而，您可能会耗尽事件队列的空间，这取决于处理事件的频率。 队列溢出会引起 IN_Q_OVERFLOW 事件。 close() 方法毁坏 inotify 实例和所有相关联的监视器，并清空队列中的所有等待事件。 inotify 事件结构体及宏（详见inotify.h）1. inotify_event 结构体struct inotify_event { int wd; /* Watch descriptor */ 属于哪个监视器的事件，说白了就是wd对应的pathname的事件 uint32_t mask; /* Mask of events */ // IN_ACCESS IN_MODIFY IN_ATTRIB ... 中一个或多个的位或 uint32_t cookie; /* Unique cookie associating related events (for rename(2)) */ 用于关联两个事件 uint32_t len; /* Size of name field */ name长度 char name[]; /* Optional null-terminated name */ 事件关联的文件名，不包括路径 }; cookie字段使用场景: 当把一个文件从一个目录移动到另一个目录时，您可以使用 cookie 将两个事件绑在一起。仅当您监视源和目标目录时，inotify 才生成两个移动事件 — 分别针对源和目标 —，并通过设置 cookie 将它们绑定在一起。要监视一个移动操作，必须指定 IN_MOVED_FROM 或 IN_MOVED_TO，或使用简短的 IN_MOVE，它可以监视两个操作。使用 IN_MOVED_FROM 和 IN_MOVED_TO 来测试事件类型。 2. 事件类型/宏（详见inotify.h）IN_ACCESS 0x00000001 File was accessed (read) (*). IN_MODIFY 0x00000002 File was modified (*). IN_ATTRIB 0x00000004 Metadata changed, e.g., permissions, timestamps, extended attributes, link count (since Linux 2.6.25), UID, GID, etc. (*). IN_CLOSE_WRITE 0x00000008 File opened for writing was closed (*). IN_CLOSE_NOWRITE 0x00000010 File not opened for writing was closed (*). IN_OPEN 0x00000020 File was opened (*). IN_MOVED_FROM 0x00000040 Generated for the directory containing the old filename when a file is renamed (*). IN_MOVED_TO 0x00000080 Generated for the directory containing the new filename when a file is renamed (*). IN_CREATE 0x00000100 File/directory created in watched directory (*). IN_DELETE 0x00000200 File/directory deleted from watched directory (*). IN_DELETE_SELF 0x00000400 Watched file/directory was itself deleted. IN_MOVE_SELF 0x00000800 Watched file/directory was itself moved. IN_UNMOUNT 0x00002000 IN_Q_OVERFLOW 0x00004000 IN_IGNORED 0x00008000 复合型事件类型 IN_CLOSE (IN_CLOSE_WRITE | IN_CLOSE_NOWRITE) IN_MOVE (IN_MOVED_FROM | IN_MOVED_TO) IN_ALL_EVENTS (IN_ACCESS | IN_MODIFY | IN_ATTRIB | IN_CLOSE_WRITE | IN_CLOSE_NOWRITE | IN_OPEN | IN_MOVED_FROM | IN_MOVED_TO | IN_DELETE | IN_CREATE | IN_DELETE_SELF | IN_MOVE_SELF) IN_ONLYDIR 0x01000000 IN_DONT_FOLLOW 0x02000000 IN_MASK_ADD 0x20000000 IN_ISDIR 0x40000000 IN_ONESHOT 0x80000000 inotify 程序示例#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;errno.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/inotify.h&gt; #define EVENT_SIZE ( sizeof (struct inotify_event) ) #define BUF_LEN ( 1024 * ( EVENT_SIZE + 16 ) ) int main( int argc, char **argv ) { int length, i = 0; int fd; int wd; char buffer[BUF_LEN]; fd = inotify_init(); if ( fd &lt; 0 ) { perror( &quot;inotify_init&quot; ); } wd = inotify_add_watch( fd, &quot;/home/jim/test_inotity&quot;, IN_MODIFY | IN_CREATE | IN_DELETE ); length = read( fd, buffer, BUF_LEN ); if ( length &lt; 0 ) { perror( &quot;read&quot; ); } while ( i &lt; length ) { struct inotify_event *event = ( struct inotify_event * ) &amp;buffer[ i ]; if ( event-&gt;len ) { if ( event-&gt;mask &amp; IN_CREATE ) { if ( event-&gt;mask &amp; IN_ISDIR ) { printf( &quot;The directory %s was created.\\n&quot;, event-&gt;name ); } else { printf( &quot;The file %s was created.\\n&quot;, event-&gt;name ); } } else if ( event-&gt;mask &amp; IN_DELETE ) { if ( event-&gt;mask &amp; IN_ISDIR ) { printf( &quot;The directory %s was deleted.\\n&quot;, event-&gt;name ); } else { printf( &quot;The file %s was deleted.\\n&quot;, event-&gt;name ); } } else if ( event-&gt;mask &amp; IN_MODIFY ) { if ( event-&gt;mask &amp; IN_ISDIR ) { printf( &quot;The directory %s was modified.\\n&quot;, event-&gt;name ); } else { printf( &quot;The file %s was modified.\\n&quot;, event-&gt;name ); } } } i += EVENT_SIZE + event-&gt;len; } ( void ) inotify_rm_watch( fd, wd ); ( void ) close( fd ); exit( 0 ); } 运行测试 $ ./watcher &amp; $ cd $HOME/test_inotify $ touch a b c The file a was created. The file b was created. The file c was created. inotify 程序示例2#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/inotify.h&gt; struct wd_path { int wd; char *path; }; char * event_array[] = { &quot;File was accessed&quot;, &quot;File was modified&quot;, &quot;File attributes were changed&quot;, &quot;writtable file closed&quot;, &quot;Unwrittable file closed&quot;, &quot;File was opened&quot;, &quot;File was moved from X&quot;, &quot;File was moved to Y&quot;, &quot;Subfile was created&quot;, &quot;Subfile was deleted&quot;, &quot;Self was deleted&quot;, &quot;Self was moved&quot;, &quot;&quot;, &quot;Backing fs was unmounted&quot;, &quot;Event queued overflowed&quot;, &quot;File was ignored&quot; }; #define EVENT_NUM 16 int main(int argc,char *argv[]) { int fd,wd,len,tmp_len,i; char buffer[1024],*offset,target[1024]; struct wd_path *wd_array; struct inotify_event *event; wd_array=(struct wd_path*)malloc((argc-1)*sizeof(struct wd_path)); fd=inotify_init(); if(-1==fd) { printf(&quot;failed to init inotifyn&quot;); return 0; } printf(&quot;argc = %d \\n&quot;, argc); if (argc &lt; 2) { return -1; } printf(&quot;argv[0] = %d \\n&quot;, argv[0]); printf(&quot;argv[1] = %d \\n&quot;, argv[1]); for(i=0;i&lt;argc-1;i++) { wd_array[i].path = argv[i+1]; wd=inotify_add_watch(fd,wd_array[i].path,IN_ALL_EVENTS); wd_array[i].wd=wd; } memset(buffer,0,1024); while(len=read(fd,buffer,1024)) { offset=buffer; event=(struct inotify_event*)buffer; while(((char *)event-buffer)&lt;len) { for(i=0;i&lt;argc-1;i++) { if(event-&gt;wd==wd_array[i].wd) { memset(target,0,1024); strcpy(target,wd_array[i].path); strcat(target,&quot;/&quot;); strcat(target,event-&gt;name); printf(&quot;nnntarget:%s:n&quot;,target); } } for(i=0;i&lt;EVENT_NUM;i++) { if(event-&gt;mask&amp;(1&lt;&lt;i)) printf(&quot; event:%sn&quot;,event_array[i]); } tmp_len=sizeof(struct inotify_event)+event-&gt;len; event=(struct inotify_event*)(offset+tmp_len); offset+=tmp_len; } } return 1; }","categories":[{"name":"linux","slug":"linux","permalink":"jingg.me/categories/linux/"}],"tags":[{"name":"inotify","slug":"inotify","permalink":"jingg.me/tags/inotify/"}]},{"title":"Markdown&MarkdownPad编辑器","slug":"Other_Markdown使用","date":"2017-04-13T11:55:33.000Z","updated":"2017-04-27T03:06:59.798Z","comments":true,"path":"2017/04/13/Other_Markdown使用/","link":"","permalink":"jingg.me/2017/04/13/Other_Markdown使用/","excerpt":"","text":"MarkdownPad编辑器添加表格的扩展开启表格特性支持： 工具 ==&gt; 选项 ==&gt; Markdown ==&gt; Markdown处理器 改为 &quot;Markdown(扩展)&quot;or&quot;GitHub风格Markdown&quot;即可。 表格语法: :---- 左对齐,默认左对齐 :---: 居中 ----: 右对齐 每列的宽度是根据对应列里最长的文本来决定 在设置的过程中要注册markdownpad2邮箱： Soar360@live.com 授权秘钥： GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2 M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6 Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5C Cx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr 0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ== Markdown编辑器快捷键· 加粗 Ctrl + B · 斜体 Ctrl + I · 引用 Ctrl + Q · 插入链接 Ctrl + L · 插入代码 Ctrl + K · 插入图片 Ctrl + G · 提升标题 Ctrl + H · 有序列表 Ctrl + O · 无序列表 Ctrl + U · 横线 Ctrl + R · 撤销 Ctrl + Z · 重做 Ctrl + Y Markdown语法参考加粗和倾斜 链接和Email 不解析内容处理方法或者 图片 标题Setext-style: atx-style (closing #’s are optional): 无段落有序列表： 有段落无序列表: 嵌套使用列表: 引用: 代码嵌入: 代码块:(不带行号)Indent every line of a code block by at least 4 spaces or 1 tab. 水平线三个破折号或者星号","categories":[{"name":"杂项","slug":"杂项","permalink":"jingg.me/categories/杂项/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"jingg.me/tags/Markdown/"}]},{"title":"Android支持库(转)","slug":"Android支持库","date":"2017-04-12T23:42:30.000Z","updated":"2017-04-13T00:22:48.005Z","comments":true,"path":"2017/04/13/Android支持库/","link":"","permalink":"jingg.me/2017/04/13/Android支持库/","excerpt":"","text":"随着 Android 5.0 Lollipop 的发布，Android 又为我们提供了更多的支持包，但是我相信大部分开发者都同我之前一样不知道这些包里究竟有些什么东西，我们应该在什么时候使用它。现在，我们就来逐个看看每一个版本的 Support 包中所拥有的东西，让用到他的时候不再迷茫。 首先，你需要了解每一个 Support 包版本后缀 vX 所代表的含义。当然我相信来看博客的诸位都一定知道 Android 对于每一个版本都有一个版本号，例如2.1是7，4.0是14，5.0是21。而这里，v 之后的数字，就代表着他能够被使用的最低版本等级，之所以无法在更低版本进行使用的原因，是因为随着版本的升级，在新版本中有很多之前不支持的特性或者 API，因此如果你在老版本中使用了这些支持包，就可能会导致应用崩溃。 现在，我们从头开始逐个浏览目前所支持的 support 包: 1. support-v4support-v4包算是 Android 最低等级的支持包。所谓的 v4,代表着它最低支持 Android1.6(API Level4)，这个版本算得上是一个真正意义上比较成熟的 Android版本，更何况现在我们写应用的时候一般都只最低支持到 Android 2.x 系统，对于1.x 的系统基本已经已经完全抛弃了，因此你可已经他作为最基本的系统组件使用。 在 support-v4包中，它所拥有的类还是很多的，主要包含了对应用组件的支持，用户交互体验的一些工具类，一些数据网络方面的工具类，相面我们将详细来看看它里面具体的一些类。 1. 系统组件部分 Fragment:其实 Fragment 是直到 Android3.0才正式进入 Android 框架体系的，但是 Android 为了低版本的兼容，因此他帮我们在低版本也适配了 Fragment 框架 NotificationCompat:这是通知栏的一些适配，可以帮助你在低版本的通知栏显示更加丰富的信息 LocalBroadcastManager:这个是用于本地广播通知的，当你希望发送的通知只被本应用接收时，你就应该使用它 2. 用户界面交互部分 ViewPager，这个相信我不用怎么说了，他主要用于帮助我们进行界面间的滑动交互 PagerTitleStrip,PagerTabStrip 这两个算是 ViewPager 的帮助类吧，他们的作用是进行 Tab 栏的切换辅助显示 DrawerLayout，主要用于侧滑栏的实现 SlidingPaneLayout,这个类也是用于侧滑栏的实现，和 DrawerLayout 不同的是，DrawerLayout 侧滑栏出来的时候，默认是覆盖在当前页面上，而 SlidingPaneLayout 则是会将当前页面移走。 3. Accessbility访问的帮助类 ExploreByTouchHelper，帮助自定义 View 实现 Accessibility 的工具类 AccessbilityEventCompat, AccessbilityNodeInfoCompat, AccessbilityNodeProviderCompat, AccessbilityDelegateCompat，这几个都是用作 Accessibility 功能适配的类 4. 数据访问帮助类 Loader，主要用于异步加载数据 FileProvider，提供应用间的文件分享功能 2. support-v71.Appcompat 这个包的主要作用是为了在低版本实现 Android 的 Holo 风格界面而引入的，与之类似的有一个开源项目叫做 SherlockActionbar 2.CardView 卡片布局是最近在 android5.0发布的时候才引入的新包，在我看来，他主要效果是让应用进行卡片花显示 3.GridLayout 网格布局能够帮助你将整个布局按照一格两格的格子形式进行排列 4.MediaRouter 这个布局主要是用来支持 GoogleCast 的，主要用于进行设备间的音频，视频交换显示 5.Palette 这个包也是最新出来的，他的作用是帮助 Android 实现他的 MaterialDesign，让你的 Actionbar 能够根据界面进行对应的颜色改变 7.RecyclerView 这个包同样也是刚出来的，他的作用是替换 ListView 和 GridView，但是可惜是没有实现 OnItemClick 这些接口，你需要自己处理它 3. support-v8support-v8中其实只有一格特性，就是用来渲染脚本 4. support-v13这个包的作用主要是为 Android3.2级以上的系统提供更多地 Framgnet 特性支持，使用它的原因在于，android-support-v4包中虽然也对 Fragment 做了支持，由于要兼容低版本，导致他是自行实现的 Fragment 效果，在高版本的 Fragment 的一些特性丢失了，而对于 v13以上的 sdk 版本，我们可以使用更加有效，特性更多的代码 5. support-v17这个包得主要作用是用于支持电视设备，并为电视设备提供了很多组件 例如下面的: BrowseFragment， DetailFragment， PlaybasckOverlayFragment， SearchFragment 但是原谅我没有做过 Android TV 开发，我也不知道他们的用处是什么，如果真的想要查看，请去官网看看吧 https://developer.android.com/topic/libraries/support-library/index.html 转自http://www.2cto.com/kf/201411/350928.html 附：API与Android版本对应表：Code name Version API level Nougat 7.1 API level 25 Nougat 7.0 API level 24 Marshmallow 6.0 API level 23 Lollipop 5.1 API level 22 Lollipop 5.0 API level 21, NDK 10 KitKat 4.4 - 4.4.4 API level 19 Jelly Bean 4.3.x API level 18 Jelly Bean 4.2.x API level 17 Jelly Bean 4.1.x API level 16 Ice Cream Sandwich 4.0.3 - 4.0.4 API level 15, NDK 8 Ice Cream Sandwich 4.0.1 - 4.0.2 API level 14, NDK 7 Honeycomb 3.2.x API level 13 Honeycomb 3.1 API level 12, NDK 6 Honeycomb 3.0 API level 11 Gingerbread 2.3.3 - 2.3.7 API level 10 Gingerbread 2.3 - 2.3.2 API level 9, NDK 5 Froyo 2.2.x API level 8, NDK 4 Eclair 2.1 API level 7, NDK 3 Eclair 2.0.1 API level 6 Eclair 2.0 API level 5 Donut 1.6 API level 4, NDK 2 Cupcake 1.5 API level 3, NDK 1 (no code name) 1.1 API level 2 (no code name) 1.0 API level 1","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"Android Support","slug":"Android-Support","permalink":"jingg.me/tags/Android-Support/"}]},{"title":"Android init.rc","slug":"Android_init_rc","date":"2017-04-12T04:22:33.000Z","updated":"2017-04-21T03:36:06.599Z","comments":true,"path":"2017/04/12/Android_init_rc/","link":"","permalink":"jingg.me/2017/04/12/Android_init_rc/","excerpt":"","text":"init.rc","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"init.rc","slug":"init-rc","permalink":"jingg.me/tags/init-rc/"}]},{"title":"Android.mk","slug":"Android_mk","date":"2017-04-12T04:22:33.000Z","updated":"2017-04-21T03:35:21.661Z","comments":true,"path":"2017/04/12/Android_mk/","link":"","permalink":"jingg.me/2017/04/12/Android_mk/","excerpt":"","text":"Android.mk","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"Android.mk","slug":"Android-mk","permalink":"jingg.me/tags/Android-mk/"},{"name":"Makefile","slug":"Makefile","permalink":"jingg.me/tags/Makefile/"},{"name":"build","slug":"build","permalink":"jingg.me/tags/build/"}]},{"title":"Android系统升级、烧录、Recovery、OTA","slug":"Android_update_img","date":"2017-04-12T04:22:33.000Z","updated":"2017-04-21T03:33:56.821Z","comments":true,"path":"2017/04/12/Android_update_img/","link":"","permalink":"jingg.me/2017/04/12/Android_update_img/","excerpt":"","text":"Recovery:http://www.tuicool.com/articles/Q7ZBbuhttp://blog.csdn.net/fengying765/article/details/38301895","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"update","slug":"update","permalink":"jingg.me/tags/update/"},{"name":"recovery","slug":"recovery","permalink":"jingg.me/tags/recovery/"},{"name":"OTA","slug":"OTA","permalink":"jingg.me/tags/OTA/"}]},{"title":"Android编译系统——完整编译过程分析","slug":"Android编译系统——完整编译过程分析","date":"2017-04-12T04:22:33.000Z","updated":"2017-04-13T05:09:44.330Z","comments":true,"path":"2017/04/12/Android编译系统——完整编译过程分析/","link":"","permalink":"jingg.me/2017/04/12/Android编译系统——完整编译过程分析/","excerpt":"","text":"###编译命令 make //整体编译Android mm mmm get_build_var TARGET_PRODUCT //获取指定变量的当前值 待续...","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"jingg.me/tags/Android/"},{"name":"编译","slug":"编译","permalink":"jingg.me/tags/编译/"}]},{"title":"APK 反编译及签名工具","slug":"Android_APK_tool","date":"2017-04-12T04:22:33.000Z","updated":"2017-04-21T03:27:18.176Z","comments":true,"path":"2017/04/12/Android_APK_tool/","link":"","permalink":"jingg.me/2017/04/12/Android_APK_tool/","excerpt":"","text":"反编译/解包/再编译1. Apktool——APK反编译及再打包工具通过反编译APK中XML文件，直接可以查看https://ibotpeaches.github.io/Apktool/ 下载安装Apktool （Windows/Linux/Mac）https://ibotpeaches.github.io/Apktool/install/ Apktool 通常用法反编译APK apktool d[ecode] test.apk再打包成APK apktool b[uild] test 2. dex2jar将apk中的classes.dex转化成Jar文件https://github.com/pxb1988/dex2jar 3. JD-GUI反编译工具，可以直接查看Jar包的源代码https://code.google.com/archive/p/innlab/downloadshttps://pan.baidu.com/disk/home#list/vmode=list&amp;path=%2Fapps%2FAPK-Track%E5%B7%A5%E5%85%B7 签名1. keytool是个密钥和证书管理工具,可以用来生成证书.keytool -genkey -keystore test.keystore -alias test -keyalg RSA -validity 10000 参数解释: -genkey 产生证书文件 -keystore 指定密钥库的.keystore文件中 -keyalg 指定密钥的算法,这里指定为RSA(非对称密钥算法) -validity 为证书有效天数，这里我们写的是10000天 -alias 产生别名 2. jarsigner工具利用密钥仓库中的信息来产生或校验 Java 存档 (JAR) 文件的数字签名 可以使用jarsigner 来签名,例子如下:jarsigner -verbose -keystore test.keystore -signedjar -signed.apk unsigned.apk &#39;test.keystore&#39; 参数说明: -verbose：指定生成详细输出 -keystore：指定数字证书存储路径 -signedjar：该选项的三个参数为 签名后的apk包 未签名的apk包 数字证书别名(注意顺序) To Do后续将qq记事本中《加密和签名（及反编译）》 整合到本文 …","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"APK反编译，APK签名","slug":"APK反编译，APK签名","permalink":"jingg.me/tags/APK反编译，APK签名/"}]},{"title":"Android Sensor","slug":"Android_Sensor","date":"2017-04-12T04:22:33.000Z","updated":"2017-04-26T08:22:55.892Z","comments":true,"path":"2017/04/12/Android_Sensor/","link":"","permalink":"jingg.me/2017/04/12/Android_Sensor/","excerpt":"","text":"http://processors.wiki.ti.com/index.php/Android_Sensor_PortingGuide","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"sensor","slug":"sensor","permalink":"jingg.me/tags/sensor/"}]},{"title":"Input系统——TYPE CODE","slug":"InputSystem004_type_code","date":"2017-04-12T04:22:33.000Z","updated":"2017-04-26T13:01:33.546Z","comments":true,"path":"2017/04/12/InputSystem004_type_code/","link":"","permalink":"jingg.me/2017/04/12/InputSystem004_type_code/","excerpt":"Event Type&amp;CodeEV_SYN: - 用于事件间的分割标志。事件可能按时间或空间进行分割，就像在多点触摸协议中的例子。 SYN_REPORT: - 当多个输入数据在同一时间发生变化时，SYN_REPORT用于把这些数据进行打包和包同步。 例如，一次鼠标的移动可以上报 REL_X和REL_Y两个数值，然后发出一个SYN_REPORT。 下一次鼠标移动可以再次发出REL_X和REL_Y两个数值，然后经跟这另一个SYN_REPORT。 SYN_MT_REPORT: - 用于同步和分离触摸事件 SYN_DROPPED: - 用来指出evdev客户的事件队列的的缓冲区溢出。 EV_KEY: - 用来描述键盘，按键或者类似键盘设备的状态变化。 KEY_&lt;name&gt;: - EV_KEY事件采取KEY_&lt;name&gt; 或BTN_&lt;name&gt;的形式， 比如，KEY_A代表键盘上的A键，当一个按键被按下时，一个带有按键编码和value为1的事件被发出。 当一个按键被释放时，一个value为0的事件被发出。有些硬件当按键重复时会发出事件，这些事件的value值为2。 通常，KEY_&lt;name&gt;用作键盘上的按键，而BTN_&lt;name&gt;则用于开关按钮事件。 - 普通键盘按键 0x0~0x100 0x160~0x2ff - 游戏柄的按键 0x100~0x110 0x120~0x140 - 鼠标按键 BTN_MOUSE-BTN_LEFT-0x110-左键； BTN_RIGHT-0x111-右键； BTN_MIDDLE-0x112-中键； BTN_&lt;name&gt;: - see above","text":"Event Type&amp;CodeEV_SYN: - 用于事件间的分割标志。事件可能按时间或空间进行分割，就像在多点触摸协议中的例子。 SYN_REPORT: - 当多个输入数据在同一时间发生变化时，SYN_REPORT用于把这些数据进行打包和包同步。 例如，一次鼠标的移动可以上报 REL_X和REL_Y两个数值，然后发出一个SYN_REPORT。 下一次鼠标移动可以再次发出REL_X和REL_Y两个数值，然后经跟这另一个SYN_REPORT。 SYN_MT_REPORT: - 用于同步和分离触摸事件 SYN_DROPPED: - 用来指出evdev客户的事件队列的的缓冲区溢出。 EV_KEY: - 用来描述键盘，按键或者类似键盘设备的状态变化。 KEY_&lt;name&gt;: - EV_KEY事件采取KEY_&lt;name&gt; 或BTN_&lt;name&gt;的形式， 比如，KEY_A代表键盘上的A键，当一个按键被按下时，一个带有按键编码和value为1的事件被发出。 当一个按键被释放时，一个value为0的事件被发出。有些硬件当按键重复时会发出事件，这些事件的value值为2。 通常，KEY_&lt;name&gt;用作键盘上的按键，而BTN_&lt;name&gt;则用于开关按钮事件。 - 普通键盘按键 0x0~0x100 0x160~0x2ff - 游戏柄的按键 0x100~0x110 0x120~0x140 - 鼠标按键 BTN_MOUSE-BTN_LEFT-0x110-左键； BTN_RIGHT-0x111-右键； BTN_MIDDLE-0x112-中键； BTN_&lt;name&gt;: - see above EV_REL: - 用来描述相对坐标轴上数值的变化，例如：鼠标向左方移动了5个单位。 REL_X 0x00 //X 轴 REL_Y 0x01 //Y 轴 REL_Z 0x02 //Z 轴 REL_RX 0x03 REL_RY 0x04 REL_RZ 0x05 REL_HWHEEL 0x06 //水平方向horizontal的滚轮 REL_DIAL 0x07 REL_WHEEL 0x08 //垂直方向vertical的滚轮 REL_MISC 0x09 REL_MAX 0x0f REL_CNT (REL_MAX+1) EV_ABS: - 用来描述相对坐标轴上数值的变化，例如：描述触摸屏上坐标的值。 ABS_X 0x00 ABS_Y 0x01 ABS_Z 0x02 ABS_RX 0x03 ABS_RY 0x04 ABS_RZ 0x05 ABS_THROTTLE 0x06 ABS_RUDDER 0x07 ABS_WHEEL 0x08 ABS_GAS 0x09 ABS_BRAKE 0x0a ABS_DISTANCE 0x19 - 用来描述触摸工具离触摸表面的距离 ABS_MT_&lt;name&gt; 用于描述多手指触摸输入设备。详情请参考内核文档：multi-touch-protocol.txt。 EV_MSC: - 当不能匹配现有的类型时，使用该类型进行描述。 EV_SW: - 用来描述具备两种状态的输入开关。 SW_LID 0x00 用来指出笔记本电脑的屏幕是否合上 EV_LED: - 用于设置或查询设备上的LED灯的开和关。 EV_SND: - 用来给设备输出提示声音。 EV_REP: - 用于可以自动重复的设备（autorepeating）。 EV_FF: - 用来给输入设备发送强制回馈命令。（震动？） FF_RUMBLE 0x50 FF_CONSTANT 0x52 EV_PWR: - 特别用于电源开关的输入。. EV_FF_STATUS: - 用于接收设备的强制反馈状态。 INPUT_DEVICE_ClASS 来区分INPUT_DEVICE_CLASS_CURSOR 有BTN_MOUSE按钮 且 REL_X及REL_Y INPUT_DEVICE_CLASS_TOUCH | INPUT_DEVICE_CLASS_TOUCH_MT 有BTN_TOUCH ABS_MT_POSITION_X ABS_MT_POSITION_Y 且没有游戏键 INPUT_DEVICE_CLASS_JOYSTICK INPUT_DEVICE_CLASS_SWITCH 任一个即可 INPUT_DEVICE_CLASS_VIBRATOR 有FF_RUMBLE-0x50 TOOL_TYPEAMOTION_EVENT_TOOL_TYPE_UNKNOWN 0 类型未知，或者都无关联项，例如 trackball or other non-pointing device. AMOTION_EVENT_TOOL_TYPE_FINGER 1 The tool is a finger 触摸类工具 AMOTION_EVENT_TOOL_TYPE_STYLUS 2 类似触针类工具，例如手写笔等 AMOTION_EVENT_TOOL_TYPE_MOUSE 3 The tool is a mouse or trackpad. 鼠标或者触摸板 AMOTION_EVENT_TOOL_TYPE_ERASER 4 The tool is an eraser or a stylus being used in an inverted posture. 擦除类工具，或者一类反向针式工具 MotionEvent用于报告运动事件，例如 mouse, pen, finger, trackball Motion events may hold either absolute or relative movements and other data, depending on the type of device. ACTION_BUTTON_PRESS ACTION_BUTTON_RELEASE ACTION_CANCEL // The current gesture has been aborted. ACTION_SCROLL // The motion event contains relative vertical and/or horizontal scroll offsets. ACTION_UP // AXIS_SCROLL // Generic scroll axis of a motion event. AINPUT_SOURCE基本类型 AINPUT_SOURCE_CLASS_MASK 0x000000ff // AINPUT_SOURCE_UNKNOWN 0x00000000 // AINPUT_SOURCE_CLASS_BUTTON 0x00000001 // 输入设备有按钮和键 AINPUT_SOURCE_CLASS_POINTER 0x00000002 // 与显示相关的指针式设备 AINPUT_SOURCE_CLASS_NAVIGATION 0x00000004 // AINPUT_SOURCE_CLASS_TRACKBALL 0x00000004 // 轨迹导航设备 AINPUT_SOURCE_CLASS_POSITION 0x00000008 // 绝对定位设备（与显示无关的定位） AINPUT_SOURCE_CLASS_JOYSTICK 0x00000010 // AINPUT_SOURCE_CLASS_NONE 0x00000000 // joystick 操作杆，绝对运动 衍生类型 AINPUT_SOURCE_KEYBOARD 0x00000101 // AINPUT_SOURCE_DPAD 0x00000201 // AINPUT_SOURCE_GAMEPAD 0x00000401 // AINPUT_SOURCE_TOUCHSCREEN 0x00001002 // AINPUT_SOURCE_MOUSE 0x00002002 // AINPUT_SOURCE_STYLUS 0x00004002 // AINPUT_SOURCE_BLUETOOTH_STYLUS 0x0000c002 // 蓝牙指针，蓝牙鼠标? API 23 AINPUT_SOURCE_TRACKBALL 0x00010004 // AINPUT_SOURCE_MOUSE_RELATIVE 0x00020004 // Android O Developer Preview AINPUT_SOURCE_TOUCHPAD 0x00100008 // AINPUT_SOURCE_TOUCH_NAVIGATION 0x00200000 // AINPUT_SOURCE_ROTARY_ENCODER 0x00400000 // Android O Developer Preview AINPUT_SOURCE_JOYSTICK 0x01000010 // AINPUT_SOURCE_HDMI 0x02000001 // AINPUT_SOURCE_ANY 0xffffff00 // AINPUT_KEYBOARD_TYPEAINPUT_KEYBOARD_TYPE_NONE 0 // There is no keyboard AINPUT_KEYBOARD_TYPE_NON_ALPHABETIC 1 // The keyboard supports a complement of alphabetic keys. AINPUT_KEYBOARD_TYPE_ALPHABETIC 2 // The keyboard is not fully alphabetic Input device configuration (.idc) Input device configuration files (.idc files) contain device-specific configuration properties that affect the behavior of input devices. Location /system/usr/idc/ or /data/system/devices/idc/ idc文件example如下 # This is an example of an input device configuration file. # It might be used to describe the characteristics of a built-in touch screen. # This is an internal device, not an external peripheral attached to the USB # or Bluetooth bus. device.internal = 1 # The device should behave as a touch screen, which uses the same orientation # as the built-in display. touch.deviceType = touchScreen touch.orientationAware = 1 # Additional calibration properties... keyboard.layout = qwerty keyboard.characterMap = qwerty keyboard.orientationAware = 1 keyboard.builtIn = 1 cursor.mode = navigation cursor.orientationAware = 1 Common属性语法 device.internal // Specifies whether the input device is an internal built-in component as opposed to an externally attached (most likely removable) peripheral. If the value is 0, the device is external. If the value is 1, the device is internal. If the value is not specified, the default value is 0 for all devices on the USB (BUS_USB) or Bluetooth (BUS_BLUETOOTH) bus, 1 otherwise. This property determines default policy decisions regarding wake events. Key Layout Files (.kl) 详见 https://source.android.com/devices/input/key-layout-files Key layout files (.kl files) map Linux key codes and axis codes to Android key codes and axis codes and specify associated policy flags. Device-specific key layout files are: Required for internal (built-in) input devices with keys, including special keys such as volume, power, and headset media keys. Optional for other input devices but recommended for special-purpose keyboards and joysticks. If no device-specific key layout file is available, the system chooses a default instead. Location /system/usr/keylayout/ or /data/system/devices/keylayout/ Generic Key Layout File The system provides a special built-in generic key layout file called Generic.kl. This key layout is intended to support a variety of standard external keyboards and joysticks. Do not modify the generic key layout! Syntax A key layout file is a plain text file consisting of key or axis declarations and flags. Key Declarations key Linux key code number Android key code name key usage HID usage(Hex 32-bit integer) Android key code name Axis Declarations axis Linux axis code number Android axis code name Basic Axes Split Axes Inverted Axes Center Flat Position Option Comments Comment lines begin with # and continue to the end of the line: # A comment! Examples -- Keyboard -- key 1 ESCAPE key 2 1 key 3 2 key 4 3 key 5 4 key 6 5 key 7 6 key 8 7 key 9 8 key 10 9 key 11 0 key 12 MINUS key 13 EQUALS key 14 DEL -- System Controls -- # This is an example of a key layout file for basic system controls, # such as volume and power keys which are typically implemented as GPIO pins # the device decodes into key presses. key 114 VOLUME_DOWN key 115 VOLUME_UP key 116 POWER -- Capacitive Buttons -- # This is an example of a key layout file for a touch device with capacitive buttons. key 139 MENU VIRTUAL key 102 HOME VIRTUAL key 158 BACK VIRTUAL key 217 SEARCH VIRTUAL -- Headset Jack Media Controls -- # This is an example of a key layout file for headset mounted media controls. # A typical headset jack interface might have special control wires or detect known # resistive loads as corresponding to media functions or volume controls. # This file assumes that the driver decodes these signals and reports media # controls as key presses. key 163 MEDIA_NEXT key 165 MEDIA_PREVIOUS key 226 HEADSETHOOK -- Joystick -- # This is an example of a key layout file for a joystick. # These are the buttons that the joystick supports, represented as keys. key 304 BUTTON_A key 305 BUTTON_B key 307 BUTTON_X key 308 BUTTON_Y key 310 BUTTON_L1 key 311 BUTTON_R1 key 314 BUTTON_SELECT key 315 BUTTON_START key 316 BUTTON_MODE key 317 BUTTON_THUMBL key 318 BUTTON_THUMBR # Left and right stick. # The reported value for flat is 128 in a range of -32767 to 32768, which is absurd. # This confuses applications that rely on the flat value because the joystick # actually settles in a flat range of +/- 4096 or so. We override it here. axis 0x00 X flat 4096 axis 0x01 Y flat 4096 axis 0x03 Z flat 4096 axis 0x04 RZ flat 4096 # Triggers. axis 0x02 LTRIGGER axis 0x05 RTRIGGER # Hat. axis 0x10 HAT_X axis 0x11 HAT_Y Virtual Soft Keys // to do Validation You should validate your key layout files using the Validate Keymaps tool. Key Character Map Files (.kcm) Key character map files (.kcm files) are responsible for mapping combinations of Android key codes with modifiers to Unicode characters. Location /system/usr/keychars/ /data/system/devices/keychars/ Generic Key Character Map File Generic.kcm Virtual Key Character Map File Virtual.kcm Syntax Keyboard Type Declaration Key Declarations Comments Keyboard DevicesTouch Devices附1：HID号码即Hidden ID code 隐含码；PID号码即Public ID code 公开码。 附2(参考资料)https://source.android.com/devices/input/overviewhttps://www.kernel.org/doc/Documentation/input/event-codes.txthttps://www.kernel.org/doc/Documentation/input/input.txthttps://www.kernel.org/doc/Documentation/input/multi-touch-protocol.txthttps://developer.android.com/reference/android/support/wearable/input/RotaryEncoder.html","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"input","slug":"input","permalink":"jingg.me/tags/input/"},{"name":"input系统","slug":"input系统","permalink":"jingg.me/tags/input系统/"},{"name":"event","slug":"event","permalink":"jingg.me/tags/event/"}]},{"title":"Input系统——Linux驱动","slug":"InputSystem001_LinuxInputDriver","date":"2017-04-12T04:22:33.000Z","updated":"2017-04-25T11:26:27.527Z","comments":true,"path":"2017/04/12/InputSystem001_LinuxInputDriver/","link":"","permalink":"jingg.me/2017/04/12/InputSystem001_LinuxInputDriver/","excerpt":"","text":"","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"input","slug":"input","permalink":"jingg.me/tags/input/"},{"name":"input系统","slug":"input系统","permalink":"jingg.me/tags/input系统/"},{"name":"event","slug":"event","permalink":"jingg.me/tags/event/"}]},{"title":"Input系统——Linux 输入子系统","slug":"InputSystem002_LinuxInputSubSystem","date":"2017-04-12T04:22:33.000Z","updated":"2017-04-26T13:01:57.739Z","comments":true,"path":"2017/04/12/InputSystem002_LinuxInputSubSystem/","link":"","permalink":"jingg.me/2017/04/12/InputSystem002_LinuxInputSubSystem/","excerpt":"待整理完善。。。 1. struct input_devstruct input_dev { const char *name; //名字 const char *phys; const char *uniq; struct input_id id; unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)]; unsigned long evbit[BITS_TO_LONGS(EV_CNT)]; // 设备所支持的事件类型 unsigned long keybit[BITS_TO_LONGS(KEY_CNT)]; // 按键类型 unsigned long relbit[BITS_TO_LONGS(REL_CNT)]; // 相对值类型 unsigned long absbit[BITS_TO_LONGS(ABS_CNT)]; // 绝对值类型 unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)]; // 混合类型 unsigned long ledbit[BITS_TO_LONGS(LED_CNT)]; // LED类型 unsigned long sndbit[BITS_TO_LONGS(SND_CNT)]; // 声音类型 unsigned long ffbit[BITS_TO_LONGS(FF_CNT)]; // 力反馈 unsigned long swbit[BITS_TO_LONGS(SW_CNT)]; // 开关类型???","text":"待整理完善。。。 1. struct input_devstruct input_dev { const char *name; //名字 const char *phys; const char *uniq; struct input_id id; unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)]; unsigned long evbit[BITS_TO_LONGS(EV_CNT)]; // 设备所支持的事件类型 unsigned long keybit[BITS_TO_LONGS(KEY_CNT)]; // 按键类型 unsigned long relbit[BITS_TO_LONGS(REL_CNT)]; // 相对值类型 unsigned long absbit[BITS_TO_LONGS(ABS_CNT)]; // 绝对值类型 unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)]; // 混合类型 unsigned long ledbit[BITS_TO_LONGS(LED_CNT)]; // LED类型 unsigned long sndbit[BITS_TO_LONGS(SND_CNT)]; // 声音类型 unsigned long ffbit[BITS_TO_LONGS(FF_CNT)]; // 力反馈 unsigned long swbit[BITS_TO_LONGS(SW_CNT)]; // 开关类型??? unsigned int hint_events_per_packet; unsigned int keycodemax; unsigned int keycodesize; void *keycode; int (*setkeycode)(struct input_dev *dev, const struct input_keymap_entry *ke, unsigned int *old_keycode); int (*getkeycode)(struct input_dev *dev, struct input_keymap_entry *ke); struct ff_device *ff; unsigned int repeat_key; struct timer_list timer; int rep[REP_CNT]; struct input_mt *mt; struct input_absinfo *absinfo; unsigned long key[BITS_TO_LONGS(KEY_CNT)]; unsigned long led[BITS_TO_LONGS(LED_CNT)]; unsigned long snd[BITS_TO_LONGS(SND_CNT)]; unsigned long sw[BITS_TO_LONGS(SW_CNT)]; int (*open)(struct input_dev *dev); void (*close)(struct input_dev *dev); int (*flush)(struct input_dev *dev, struct file *file); int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value); struct input_handle __rcu *grab; spinlock_t event_lock; struct mutex mutex; unsigned int users; bool going_away; struct device dev; struct list_head h_list; struct list_head node; unsigned int num_vals; unsigned int max_vals; struct input_value *vals; bool devres_managed; }; 2. 注册/注销函数int input_register_device搜索(struct input_dev *dev) void input_unregister_device(struct input_dev *dev) 3. 设备所支持的事件类型有EV_KEY 按键 EV_REL 相对坐标 EV_ABS绝对坐标 EV_MSC 其它 EV_LED LED EV_SND 声音 EV_FF 力反馈 EV_SW 开关??? 4. 操作函数set_bit(EV_KEY, button_dev.evbit) // 设置支持的事件 void input_report_key(struct input_dev *dev,unsigned int code, int value) // 在中断过程中中，内核层使用input_report_key等函数向用户空间报告，然后应用程序读取状态。 void input_report_rel(struct input_dev *dev,unsigned int code, int value) // .. void input_report_abs(struct input_dev *dev,unsigned int code, int value) // .. input_sync() // 用于事件同步，它告知事件的接收者：驱动已经发出了一个完整的报告。 5. 事件代码EV_KEY 事件代码 代码值0~127为键盘上的按键代码，0x110~0x116为鼠标上按键代码，其中0x110(BTN_LEFT)为鼠标左键，0x111(BTN_RIGHT)为鼠标右键,0x112(BTN_ MIDDLE)为鼠标中键。其它代码含义请参看include/linux/input.h文件 EV_KEY 事件值 按键按下时值为1,松开时值为0 evdev","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"input","slug":"input","permalink":"jingg.me/tags/input/"},{"name":"input系统","slug":"input系统","permalink":"jingg.me/tags/input系统/"},{"name":"event","slug":"event","permalink":"jingg.me/tags/event/"}]},{"title":"Input系统——Android Input系统","slug":"InputSystem003_AndroidInputSystem","date":"2017-04-12T04:22:33.000Z","updated":"2017-04-26T13:02:03.136Z","comments":true,"path":"2017/04/12/InputSystem003_AndroidInputSystem/","link":"","permalink":"jingg.me/2017/04/12/InputSystem003_AndroidInputSystem/","excerpt":"Input系统结构解析AndroidInput系统——JNI NativeInputManager InputManger InputReaderhttps://docs.google.com/drawings/d/1DoS3SayZNpAqAMpjQ8h0O1eSb1nb9r9V7c47TjvqO2o/edit","text":"Input系统结构解析AndroidInput系统——JNI NativeInputManager InputManger InputReaderhttps://docs.google.com/drawings/d/1DoS3SayZNpAqAMpjQ8h0O1eSb1nb9r9V7c47TjvqO2o/edit AndroidInput系统——InputReaderhttps://docs.google.com/drawings/d/1A78eIrYTHg2nh-HrWJMpsMu64HitGj7dk_ciSajtex4/edit AndroidInput系统——InputDispatcherhttps://docs.google.com/drawings/d/19KStX_1m2rNCqjCouwW5DFWOY-e1ZbfDTcYAXrPSzOA/edit AndroidInput系统——EventHubhttps://docs.google.com/drawings/d/1QAC0GFiARVOJcv6vugVNEiqIMkGZX0XXhiCuIDssvtk/edit Android Input系统相关结构体1. input_device_idstruct input_device_id { kernel_ulong_t flags; __u16 bustype; // BUS_USB BUS_BLUETOOTH __u16 vendor; __u16 product; __u16 version; kernel_ulong_t evbit[INPUT_DEVICE_ID_EV_MAX / BITS_PER_LONG + 1]; kernel_ulong_t keybit[INPUT_DEVICE_ID_KEY_MAX / BITS_PER_LONG + 1]; kernel_ulong_t relbit[INPUT_DEVICE_ID_REL_MAX / BITS_PER_LONG + 1]; kernel_ulong_t absbit[INPUT_DEVICE_ID_ABS_MAX / BITS_PER_LONG + 1]; kernel_ulong_t mscbit[INPUT_DEVICE_ID_MSC_MAX / BITS_PER_LONG + 1]; kernel_ulong_t ledbit[INPUT_DEVICE_ID_LED_MAX / BITS_PER_LONG + 1]; kernel_ulong_t sndbit[INPUT_DEVICE_ID_SND_MAX / BITS_PER_LONG + 1]; kernel_ulong_t ffbit[INPUT_DEVICE_ID_FF_MAX / BITS_PER_LONG + 1]; kernel_ulong_t swbit[INPUT_DEVICE_ID_SW_MAX / BITS_PER_LONG + 1]; kernel_ulong_t driver_info; }; 2. input_event (input.h)struct input_event { struct timeval time; __u16 type; __u16 code; __s32 value; }; 3. RawEvent (EventHub.h)struct RawEvent { nsecs_t when; time int32_t deviceId; ID = 1 ID = 0 int32_t type; EV_REL= 0x02 EV_SYN = 0x00 int32_t code; REL_X = 0x00 SYN_REPORT = 0 int32_t value; Value = 0x01 Value = 0x00 }; 调试相关查看event注册设备shell@rk3368_32:/dev/input # cat /proc/bus/input/devices I: Bus=0000 Vendor=0000 Product=0003 Version=206a N: Name=&quot;synaptics_dsx&quot; P: Phys=synaptics_dsx/touch_input S: Sysfs=/devices/ff140000.i2c/i2c-2/2-0020/input/input0 U: Uniq= H: Handlers=event0 cpufreq ddr_freq B: PROP=2 B: EV=b B: KEY=420 0 0 0 0 0 8000 0 0 0 0 B: ABS=2638000 3 I: Bus=0019 Vendor=0000 Product=0000 Version=0000 N: Name=&quot;rotary.35&quot; P: Phys= S: Sysfs=/devices/rotary.35/input/input1 U: Uniq= H: Handlers=event1 B: PROP=0 B: EV=5 B: REL=1 I: Bus=0019 Vendor=0001 Product=0001 Version=0100 N: Name=&quot;rk29-keypad&quot; P: Phys=gpio-keys/input0 S: Sysfs=/devices/ff100000.adc/key.38/input/input2 U: Uniq= H: Handlers=event2 ddr_freq keychord B: PROP=0 B: EV=3 B: KEY=8000 100000 0 0 0 I: Bus=0000 Vendor=0000 Product=0000 Version=0000 N: Name=&quot;temperature&quot; P: Phys= S: Sysfs=/devices/ff160000.i2c/i2c-4/4-005b/input/input3 U: Uniq= H: Handlers=event3 B: PROP=0 B: EV=9 B: ABS=40 查看Handler个数shell@rk3368_box:/dev/input # ls -l crw-rw---- root input 13, 64 2017-04-12 11:15 event0 crw-rw---- root input 13, 65 2017-04-12 11:15 event1 crw-rw---- root input 13, 66 2017-04-14 08:12 event2 crw-rw---- root input 13, 67 2017-04-14 08:12 event3 cat event0 cat event1 getevent 获取事件# getevent -h Usage: getevent [-t] [-n] [-s switchmask] [-S] [-v [mask]] [-d] [-p] [-i] [-l] [-q] [-c count] [-r] [device] -t: show time stamps -n: don&apos;t print newlines -s: print switch states for given bits -S: print all switch states -v: verbosity mask (errs=1, dev=2, name=4, info=8, vers=16, pos. events=32, props=64) -d: show HID descriptor, if available -p: show possible events (errs, dev, name, pos. events) -i: show all device info and possible events -l: label event types and names in plain text -q: quiet (clear verbosity mask) -c: print given number of events then exit -r: print rate events are received 常用命令组合： getevent -p // see all of the keys and axes a device reports getevent -ip // get more information, including HID mapping tables and debugging information getevent -lp // option to display textual labels for all event codes getevent -lp getevent -r -q 监控设备的sendevent事件 getevent -p add device 1: /dev/input/event3 name: &quot;temperature&quot; add device 2: /dev/input/event1 name: &quot;rotary.35&quot; add device 3: /dev/input/event0 name: &quot;synaptics_dsx&quot; add device 4: /dev/input/event2 name: &quot;rk29-keypad&quot; /dev/input/event1: 0002 0000 00000001 ID=1 EV_REL=0x02 REL_X = 0x00 Value = 0x01 /dev/input/event1: 0000 0000 00000000 ID=0 EV_SYN 0x00 SYN_REPORT = 0 Value = 0x00 /dev/input/event1: 0002 0000 00000001 /dev/input/event1: 0000 0000 00000000 /dev/input/event1: 0002 0000 00000001 /dev/input/event1: 0000 0000 00000000 /dev/input/event1: 0002 0000 ffffffff EV_REL=0x02 REL_X = 0x00 Value = 0xffffffffff /dev/input/event1: 0000 0000 00000000 /dev/input/event1: 0002 0000 ffffffff dumpsys dumpsys input： To dump the input system’s state (Event Hub State,Input Reader State,Input Dispatcher State)","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"input","slug":"input","permalink":"jingg.me/tags/input/"},{"name":"input系统","slug":"input系统","permalink":"jingg.me/tags/input系统/"},{"name":"event","slug":"event","permalink":"jingg.me/tags/event/"}]},{"title":"RK平台分区信息","slug":"RK平台分区信息","date":"2017-04-11T09:35:57.000Z","updated":"2017-04-20T13:34:08.845Z","comments":true,"path":"2017/04/11/RK平台分区信息/","link":"","permalink":"jingg.me/2017/04/11/RK平台分区信息/","excerpt":"","text":"RK平台分区信息与eMMC partitions对应lrwxrwxrwx root root 2013-01-21 08:50 uboot -&gt; /dev/block/mmcblk0p1 lrwxrwxrwx root root 2013-01-21 08:50 trust -&gt; /dev/block/mmcblk0p2 lrwxrwxrwx root root 2013-01-21 08:50 misc -&gt; /dev/block/mmcblk0p3 lrwxrwxrwx root root 2013-01-21 08:50 resource -&gt; /dev/block/mmcblk0p4 lrwxrwxrwx root root 2013-01-21 08:50 kernel -&gt; /dev/block/mmcblk0p5 lrwxrwxrwx root root 2013-01-21 08:50 boot -&gt; /dev/block/mmcblk0p6 lrwxrwxrwx root root 2013-01-21 08:50 recovery -&gt; /dev/block/mmcblk0p7 lrwxrwxrwx root root 2013-01-21 08:50 backup -&gt; /dev/block/mmcblk0p8 lrwxrwxrwx root root 2013-01-21 08:50 cache -&gt; /dev/block/mmcblk0p9 lrwxrwxrwx root root 2013-01-21 08:50 kpanic -&gt; /dev/block/mmcblk0p10 lrwxrwxrwx root root 2013-01-21 08:50 system -&gt; /dev/block/mmcblk0p11 lrwxrwxrwx root root 2013-01-21 08:50 metadata -&gt; /dev/block/mmcblk0p12 lrwxrwxrwx root root 2013-01-21 08:50 baseparamer -&gt; /dev/block/mmcblk0p13 lrwxrwxrwx root root 2013-01-21 08:50 userdata -&gt; /dev/block/mmcblk0p14 lrwxrwxrwx root root 2013-01-21 08:50 radical_update -&gt; /dev/block/mmcblk0p15 lrwxrwxrwx root root 2013-01-21 08:50 user -&gt; /dev/block/mmcblk0p16 mmcblk0: p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13 p14 p15 p16 p17 /mnt/external_sd vfat /dev/block/mmcblk1p1 RK平台各分区介绍uboot.img trust.img misc.img RK平台，misc分区内容用于启动模式切换，是升级基带还是进入Recovery（misc分区的内容可以被按键出发改变???） resource.img RK平台资源映像，内含开机图片和内核的设备树信息。 kernel boot.img Android 的初始文件映像，负责初始化并加载 system 分区，一般Android系统这个镜像中包含ramdisk.img根文件系统+kernel（RK平台的boot.img是没包含kernel部分的） ramdisk.img 是根文件系统，是root目录打包成的镜像（ramdisk-recovery.img） recovery.img 恢复模式系统启动镜像。内容和boot.img雷同（RK平台recovery.img包含kernel部分），但是其中的ramdisk.img（ramdisk-recovery.img）有些许不同： recovery.fstab文件、sbin下部分工具、build.prop、init.bootmode.emmc.rc、sepolicy等 backup cache kpanic system.img 包括了主要的包、库等文件 metadata baseparameter userdata.img 包括了一些用户数据 radical_update user 另：RK平台生成boot.img recovery.img system.img userdata.img是使用自己的mkimage.sh工具讲root system data 目录生成的 再使用工具mkupdate.sh生成update.img的（不带userdata.img） 烧写userdata.img 需要使用./upgrade_tool DI userdata userdata.img 单独烧写","categories":[{"name":"RK","slug":"RK","permalink":"jingg.me/categories/RK/"}],"tags":[{"name":"分区","slug":"分区","permalink":"jingg.me/tags/分区/"},{"name":"RK","slug":"RK","permalink":"jingg.me/tags/RK/"}]},{"title":"Android编译系统——ramdisk.img system.img userdata.img recovery.img目标编译过程","slug":"Android编译系统——system.img userdata.img recovery.img目标编译过程","date":"2017-04-11T09:35:57.000Z","updated":"2017-04-20T09:47:01.274Z","comments":true,"path":"2017/04/11/Android编译系统——system.img userdata.img recovery.img目标编译过程/","link":"","permalink":"jingg.me/2017/04/11/Android编译系统——system.img userdata.img recovery.img目标编译过程/","excerpt":"","text":"image 介绍boot.img Android 的初始文件映像，负责初始化并加载 system 分区，一般Android系统这个镜像中包含ramdisk.img根文件系统+kernel（RK平台的boot.img是没包含kernel部分的） recovery.img 恢复模式系统启动镜像。内容和boot.img雷同（RK平台recovery.img包含kernel部分），但是其中的ramdisk.img（ramdisk-recovery.img）有些许不同： recovery.fstab文件、sbin下部分工具、build.prop、init.bootmode.emmc.rc、sepolicy等 ramdisk.img 是根文件系统，是root目录打包成的镜像（ramdisk-recovery.img） system.img 包括了主要的包、库等文件 userdata.img 包括了一些用户数据 image 目标编译过程---build/core/main.mk中--- 默认目标，即目标all .PHONY: droid DEFAULT_GOAL := droid $(DEFAULT_GOAL): //root目标droid droid: droidcore dist_files //1级目标，droidcore droidcore: files \\ //2级目标，files systemimage ... systemimage \\ $(INSTALLED_BOOTIMAGE_TARGET) \\ $(INSTALLED_RECOVERYIMAGE_TARGET) \\ $(INSTALLED_USERDATAIMAGE_TARGET) \\ $(INSTALLED_CACHEIMAGE_TARGET) \\ $(INSTALLED_VENDORIMAGE_TARGET) \\ $(INSTALLED_FILES_FILE) ---build/core/Makefile中--- INSTALLED_SYSTEMIMAGE := $(PRODUCT_OUT)/system.img BUILT_SYSTEMIMAGE := $(systemimage_intermediates)/system.img FULL_SYSTEMIMAGE_DEPS := $(INTERNAL_SYSTEMIMAGE_FILES) $(INTERNAL_USERIMAGES_DEPS) INSTALLED_FILES_FILE := $(PRODUCT_OUT)/installed-files.txt systemimage: $(INSTALLED_SYSTEMIMAGE) //3级目标 ./system.img $(INSTALLED_SYSTEMIMAGE): $(BUILT_SYSTEMIMAGE) $(RECOVERY_FROM_BOOT_PATCH) | $(ACP) //4级目标 _./system.img $(BUILT_SYSTEMIMAGE): $(FULL_SYSTEMIMAGE_DEPS) $(INSTALLED_FILES_FILE) //5级目标 $(call build-systemimage-target,$@) BUILT_USERDATAIMAGE_TARGET := $(PRODUCT_OUT)/userdata.img INSTALLED_USERDATAIMAGE_TARGET := $(BUILT_USERDATAIMAGE_TARGET) INTERNAL_USERDATAIMAGE_FILES := \\ //4级目标 $(filter $(TARGET_OUT_DATA)/%,$(ALL_DEFAULT_INSTALLED_MODULES)) $(INSTALLED_USERDATAIMAGE_TARGET): $(INTERNAL_USERIMAGES_DEPS) \\ //3级目标 $(INTERNAL_USERDATAIMAGE_FILES) $(build-userdataimage-target) define build-userdataimage-target //做userdata.img分区build操作 $(call pretty,&quot;Target userdata fs image: $(INSTALLED_USERDATAIMAGE_TARGET)&quot;) @mkdir -p $(TARGET_OUT_DATA) @mkdir -p $(userdataimage_intermediates) &amp;&amp; rm -rf $(userdataimage_intermediates)/userdata_image_info.txt $(call generate-userimage-prop-dictionary, $(userdataimage_intermediates)/userdata_image_info.txt, skip_fsck=true) $(hide) PATH=$(foreach p,$(INTERNAL_USERIMAGES_BINARY_PATHS),$(p):)$$PATH \\ ./build/tools/releasetools/build_image.py \\ $(TARGET_OUT_DATA) $(userdataimage_intermediates)/userdata_image_info.txt $(INSTALLED_USERDATAIMAGE_TARGET) $(hide) $(call assert-max-image-size,$(INSTALLED_USERDATAIMAGE_TARGET),$(BOARD_USERDATAIMAGE_PARTITION_SIZE)) endef 注 system.img userdata.img 会依赖skip_userdata.img := 这个变量 及 嵌套依赖device/.../BoardConfig.mk中的TARGET_USERIMAGES_USE_EXT4、BOARD_SYSTEMIMAGE_PARTITION_SIZE、BOARD_USERDATAIMAGE_PARTITION_SIZE和 image解压方法ramdisk.img 用file命令查看显示ramdisk.img: gzip compressed data, from Unix，采用cpio打包，gzip压缩的 cp -a ramdisk.img 000/ramdisk.img.gz cd 000/ gunzip ramdisk.img.gz //得到ramdisk.img 文件，但是和原始的ramdisk.img是不一样的，大小要大不少 mkdir root cd root cpio –i -F ../ramdisk.img system.img 用file命令查看显示system.img: data cp -a system.img 000/system.img cd 000/ out/host/linux-x86/bin/simg2img system.img system.ext4.img //用simg2img工具把system.img转为为ext4文件格式 mkdir system //建立system目录 sudo mount -t ext4 -o loop system.ext4.img system //将ext4格式的镜像挂在到system目录 userdata.img 用file命令查看显示userdata.img: data 同system.img recovery.img 用file命令查看显示recovery.img: data 需要使用外部工具https://github.com/xiaolu/mkbootimg_tools.git mkboot命令 ./mkbootimg_tools/mkboot recovery.img recovery boot.img 用file命令查看显示boot.img: data 需要使用外部工具https://github.com/xiaolu/mkbootimg_tools.git mkboot命令 ./mkbootimg_tools/mkboot boot.img boot image压缩方法a. ramdisk 使用cpio -o -H | gzip 生成ramdisk.img b. system userdata recovery都可以使用mkuserimg.sh来压缩成镜像 mkuserimg.sh -s 镜像源目录 镜像输出文件 ext4 挂在点 分区size FILE_CONTEXTS文件 单独编译imagemake systemimage - system.img make userdataimage - userdata.img make ramdisk - ramdisk.img make snod - 快速打包system.img (with this command, it will build a new system.img very quickly. well, you cannot use &quot;make snod&quot; for all the situations. it would not check the dependences. if you change some code in the framework which will effect other applications) 附:simg2img解压缩工具: Convert Android sparse images to raw images. 在out/host/linux-x86/bin/simg2img可以找到 用法：simg2img &lt;sparse_image_files&gt; &lt;raw_image_file&gt; mkuserimg.sh镜像制作工具，在out/host/linux-x86/bin/mkuserimg.sh可以找到，工具中会调用make_ext4fs 用法：mkuserimg.sh [-s] SRC_DIR OUTPUT_FILE EXT_VARIANT MOUNT_POINT SIZE [-j &lt;journal_size&gt;] [-T TIMESTAMP] [-C FS_CONFIG] [-B BLOCK_LIST_FILE] [FILE_CONTEXTS] 例如制作system.img和userdata.img时： Running: mkuserimg.sh -s out/target/product/rk3368_box/system out/target/product/rk3368_box/obj/PACKAGING/systemimage_intermediates/system.img ext4 system 1073741824 out/target/product/rk3368_box/root/file_contexts make_ext4fs -s -T -1 -S out/target/product/rk3368_box/root/file_contexts -l 1073741824 -a system out/target/product/rk3368_box/obj/PACKAGING/systemimage_intermediates/system.img out/target/product/rk3368_box/system Running: mkuserimg.sh -s out/target/product/rk3368_box/data out/target/product/rk3368_box/userdata.img ext4 data 2147483648 out/target/product/rk3368_box/root/file_contexts make_ext4fs -s -T -1 -S out/target/product/rk3368_box/root/file_contexts -l 2147483648 -a data out/target/product/rk3368_box/userdata.img out/target/product/rk3368_box/data make_ext4fs工具：用于Android平台上制作ext4文件系统的镜像，在out/host/linux-x86/bin/make_ext4fs 用法：make_ext4fs [ -l &lt;len&gt; ] [ -j &lt;journal size&gt; ] [ -b &lt;block_size&gt; ] [ -g &lt;blocks per group&gt; ] [ -i &lt;inodes&gt; ] [ -I &lt;inode size&gt; ] [ -L &lt;label&gt; ] [ -f ] [ -a &lt;android mountpoint&gt; ] [ -S file_contexts ] [ -C fs_config ] [ -T timestamp ] [ -z | -s ] [ -w ] [ -c ] [ -J ] [ -v ] [ -B &lt;block_list_file&gt; ] &lt;filename&gt; [&lt;directory&gt;] -l 分区大小 支持512M 以及1073741824 单位为bytes -s 生成ext4的S模式制作 -T timestamp // -1 mean what? fix me -a 挂在点 -S file_contexts文件 &lt;filename&gt; 生成的目的文件 &lt;directory&gt; 源文件目录 附2——一般Android系统的boot.img格式(RK平台的boot.img是没包含kernel部分的)因为boot.img的格式比较简单，它主要分为三大块（有的可能有四块） +—————–+ | boot header | 1 page +—————–+ | kernel | n pages +—————–+ | ramdisk | m pages +—————–+ | second stage | o pages +—————–+ n = (kernel_size + page_size – 1) / page_size m = (ramdisk_size + page_size – 1) / page_size o = (second_size + page_size – 1) / page_size a. all entities are page_size aligned in flash b. kernel and ramdisk are required (size != 0) c. second is optional (second_size == 0 -&gt; no second)","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"jingg.me/tags/Android/"},{"name":"编译","slug":"编译","permalink":"jingg.me/tags/编译/"},{"name":"image","slug":"image","permalink":"jingg.me/tags/image/"}]},{"title":"RK平台Android分区大小修改说明","slug":"RK平台Android分区大小修改说明","date":"2017-04-11T01:01:57.000Z","updated":"2017-04-21T06:04:32.705Z","comments":true,"path":"2017/04/11/RK平台Android分区大小修改说明/","link":"","permalink":"jingg.me/2017/04/11/RK平台Android分区大小修改说明/","excerpt":"","text":"不同于一般的Android系统（一般Android系统分区信息在BoardConfig.mk BoardConfigCommon.mk中），RK平台的分区信息文件在自带的烧录工具包中的parameter文件中 如下是板子的parameter文件:FIRMWARE_VER: 5.1.0 MACHINE_MODEL: Geekbox MACHINE_ID: 007 MANUFACTURER: RK3368 MAGIC: 0x5041524B ATAG: 0x00200800 MACHINE: 3368 CHECK_MASK: 0x80 PWR_HLD: 0,0,A,0,1 #KERNEL_IMG: 0x00280000 #FDT_NAME: rk-kernel.dtb #RECOVER_KEY: 1,1,0,20,0 #in section; per section 512(0x200) bytes CMDLINE: console=ttyS2 androidboot.baseband=N/A androidboot.selinux=permissive androidboot.hardware=rk30board androidboot.console=ttyS2 init=/init mtdparts=rk29xxnand:0x00002000@0x00002000(uboot),0x00002000@0x00004000(trust),0x00002000@0x00006000(misc),0x00008000@0x00008000(resource),0x00008000@0x00010000(kernel),0x00010000@0x00018000(boot),0x00010000@0x00028000(recovery),0x00038000@0x00038000(backup),0x00040000@0x00070000(cache),0x00002000@0x000B0000(kpanic),0x00200000@0x000B2000(system),0x00008000@0x002B2000(metadata),0x00002000@0x002BA000(baseparamer),0x00400000@0x002BC000(userdata),0x00020000@0x006BC000(radical_update),-@0x006DC000(user) 分区信息在mtdparts=rk29xxnand:字段后面部分，所以我们修改这部分内容就可以了 这部分信息格式介绍 如：0x00002000@0x00002000(uboot) 分区大小计算为=0x00002000*512Bytes = 4MBytes ↑分区的sector数，每个sector=512Bytes ↑分区起始地址 ↑分区名 0x00200000@0x002BC000(userdata) 分区大小0x00200000*512Bytes = 1073741824 Bytes 注: sector 512Bytes 逻辑单位??? page: FLASH操作的基本单位。 最小读/写单元 page， 1page = 4096Bytes = 4KB； block:最小擦除单元 block，1block = (32 * page) = (32 * 4KB) = 131072Bytes = 128KB； 上述mtdparts=rk29xxnand:字段中所有分区都是连续的，当前分区起始地址+当前分区size和下个分区起始地址都是连续的，所以当修改了其中某个分区后，在它后面的分区的地址都要顺序往前或往后。 以下是我将userdata分区缩小为1GB，将user分区扩大1GB的例子：修改前: size offset 0x00002000@0x00000000(parameter)//4MB 4MB 0x00002000@0x00002000(uboot), //4MB 8MB 0x00002000@0x00004000(trust), //4MB 12MB 0x00002000@0x00006000(misc), //4MB 16MB 0x00008000@0x00008000(resource),//16MB 32MB 0x00008000@0x00010000(kernel), //16MB 48 0x00010000@0x00018000(boot), //32MB 80 0x00010000@0x00028000(recovery),//32MB 112 0x00038000@0x00038000(backup), //112MB 224 0x00040000@0x00070000(cache), //128MB 352 0x00002000@0x000B0000(kpanic), //4MB 356 0x00200000@0x000B2000(system), //1024MB 1380 0x00008000@0x002B2000(metadata),//16MB 1396 0x00002000@0x002BA000(baseparamer), //4MB 1400MB 0x00400000@0x002BC000(userdata), //2048MB 3448 0x00020000@0x006BC000(radical_update), //64MB 3512 -@0x006DC000(user) //212MB/11394MB ... 修改后: 0x00002000@0x00002000(uboot), //4MB 8MB 0x00002000@0x00004000(trust), //4MB 12MB 0x00002000@0x00006000(misc), //4MB 16MB 0x00008000@0x00008000(resource),//16MB 32MB 0x00008000@0x00010000(kernel), //16MB 48 0x00010000@0x00018000(boot), //32MB 80 0x00010000@0x00028000(recovery),//32MB 112 0x00038000@0x00038000(backup), //112MB 224 0x00040000@0x00070000(cache), //128MB 352 0x00002000@0x000B0000(kpanic), //4MB 356 0x00200000@0x000B2000(system), //1024MB 1380 0x00008000@0x002B2000(metadata),//16MB 1396 0x00002000@0x002BA000(baseparamer), //4MB 1400MB 0x00200000@0x002BC000(userdata), //1024MB 2424MB 0x00020000@0x004BC000(radical_update), //64MB 2488MB -@0x004DC000(user) //1024+212MB = 1236MB 注：1.分区的大小要以4MB对齐！ 2.分区总大小不能超过flash的总长度 修改parameter后效果：shell@rk3368_32:/ # df Filesystem Size Used Free Blksize /dev 495.2M 36.0K 495.2M 4096 /sys/fs/cgroup 495.2M 12.0K 495.2M 4096 /mnt/asec 495.2M 0.0K 495.2M 4096 /mnt/obb 495.2M 0.0K 495.2M 4096 /system 1004.2M 403.0M 601.2M 4096 /cache 122.0M 140.0K 121.8M 4096 /metadata 11.7M 40.0K 11.7M 4096 /data 991.9M 87.5M 904.4M 4096 /mnt/shell/emulated 991.9M 87.5M 904.4M 4096 /mnt/internal_sd 1.2G 136.0K 1.2G 8192 /mnt/secure/asec 1.2G 136.0K 1.2G 8192 一般Android平台分区修改eMMC 分区信息 # cat /proc/partitions major minor #blocks name 254 0 520912 zram0 179 0 15267840 mmcblk0 179 1 4096 mmcblk0p1 179 2 4096 mmcblk0p2 179 3 4096 mmcblk0p3 179 4 16384 mmcblk0p4 179 5 16384 mmcblk0p5 179 6 32768 mmcblk0p6 179 7 32768 mmcblk0p7 179 8 114688 mmcblk0p8 179 9 131072 mmcblk0p9 179 10 4096 mmcblk0p10 179 11 1048576 mmcblk0p11 179 12 16384 mmcblk0p12 179 13 4096 mmcblk0p13 179 14 2097152 mmcblk0p14 179 15 65536 mmcblk0p15 179 16 11667456 mmcblk0p16 mmcblk0即emmc的容量（单位kb） #ls /dev/block/platform/ff0f0000.rksdmmc/by-name/* -l lrwxrwxrwx root root 2013-01-21 08:50 uboot -&gt; /dev/block/mmcblk0p1 lrwxrwxrwx root root 2013-01-21 08:50 trust -&gt; /dev/block/mmcblk0p2 lrwxrwxrwx root root 2013-01-21 08:50 misc -&gt; /dev/block/mmcblk0p3 lrwxrwxrwx root root 2013-01-21 08:50 resource -&gt; /dev/block/mmcblk0p4 lrwxrwxrwx root root 2013-01-21 08:50 kernel -&gt; /dev/block/mmcblk0p5 lrwxrwxrwx root root 2013-01-21 08:50 boot -&gt; /dev/block/mmcblk0p6 lrwxrwxrwx root root 2013-01-21 08:50 recovery -&gt; /dev/block/mmcblk0p7 lrwxrwxrwx root root 2013-01-21 08:50 backup -&gt; /dev/block/mmcblk0p8 lrwxrwxrwx root root 2013-01-21 08:50 cache -&gt; /dev/block/mmcblk0p9 lrwxrwxrwx root root 2013-01-21 08:50 kpanic -&gt; /dev/block/mmcblk0p10 lrwxrwxrwx root root 2013-01-21 08:50 system -&gt; /dev/block/mmcblk0p11 lrwxrwxrwx root root 2013-01-21 08:50 metadata -&gt; /dev/block/mmcblk0p12 lrwxrwxrwx root root 2013-01-21 08:50 baseparamer -&gt; /dev/block/mmcblk0p13 lrwxrwxrwx root root 2013-01-21 08:50 userdata -&gt; /dev/block/mmcblk0p14 lrwxrwxrwx root root 2013-01-21 08:50 radical_update -&gt; /dev/block/mmcblk0p15 lrwxrwxrwx root root 2013-01-21 08:50 user -&gt; /dev/block/mmcblk0p16 即userdata 分区 大小为2097152*1024KB = 2147483648B BoardConfig.mk 中修改指定变量即可： BOARD_BOOTIMAGE_PARTITION_SIZE := 16777216 BOARD_RECOVERYIMAGE_PARTITION_SIZE := 16793600 BOARD_SYSTEMIMAGE_PARTITION_SIZE := 2147483648 BOARD_OEMIMAGE_PARTITION_SIZE := 67108864 BOARD_USERDATAIMAGE_PARTITION_SIZE := 25253773312 ---&gt; 2147483648B BOARD_CACHEIMAGE_PARTITION_SIZE := 268435456 BOARD_CACHEIMAGE_FILE_SYSTEM_TYPE := ext4 BOARD_FLASH_BLOCK_SIZE := 131072","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"分区","slug":"分区","permalink":"jingg.me/tags/分区/"},{"name":"RK","slug":"RK","permalink":"jingg.me/tags/RK/"}]},{"title":"Hexo入手","slug":"Other_Hexo入手","date":"2017-04-07T10:01:57.000Z","updated":"2017-04-26T07:58:04.458Z","comments":true,"path":"2017/04/07/Other_Hexo入手/","link":"","permalink":"jingg.me/2017/04/07/Other_Hexo入手/","excerpt":"","text":"1. 安装nodejs从官网下载对应平台binary 包，安装（linux直接将bin lib目录的文件cp到usr/local对应目录下，Window直接点击安装） 2. 安装hexonpm install hexo-cli -g 3. 新建bloghexo init blog cd blog npm install hexo server 3. 解决一个warningnpm install -g npm@3.3.12 npm install hexo-deployer-git --save 4. 配置_config.ymllanguage: zh-CN deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] 5. 部署hexo deploy -generate //hexo d -g 附（参考）https://hexo.io/docs/index.html","categories":[{"name":"杂项","slug":"杂项","permalink":"jingg.me/categories/杂项/"}],"tags":[{"name":"网页博客","slug":"网页博客","permalink":"jingg.me/tags/网页博客/"}]},{"title":"Android fstab介绍","slug":"Android fstab","date":"2017-04-07T08:01:57.000Z","updated":"2017-04-12T01:02:32.476Z","comments":true,"path":"2017/04/07/Android fstab/","link":"","permalink":"jingg.me/2017/04/07/Android fstab/","excerpt":"","text":"ubuntu fstab文件格式下面是/etc/fatab文件的一个示例行： fs_spec fs_file fs_type fs_options fs_dump fs_pass /dev/hda1 / ext2 defaults 1 1 fs_spec - 该字段定义希望加载的文件系统所在的设备或远程文件系统，对于一般的本地块设备情况来说：IDE设备一般描述为 /dev/hdaXN，X是IDE设备通道 (a, b, or c)，N代表分区号；SCSI设备一描述为/dev/sdaXN。对于NFS情况，格式一般为: 例 如：`knuth.aeb.nl:/&apos;。对于procfs，使用`proc&apos;来定义。 fs_file - 该字段描述希望的文件系统加载的目录点，对于swap设备，该字段为none；对于加载目录名包含空格的情况，用40来 表示空格。 fs_type - 定义了该设备上的文件系统，一般常见的文件类型为ext2 (linux设备的常用文件类型)、vfat(Windows系统的fat32格 式)、NTFS、iso9600等。 fs_options - 指定加载该设备的文件系统是需要使用的特定参数选项，多个参数是由逗号分隔开来。对于大多数系统使用&quot;defaults&quot; 就可以满足需要。其他常见的选项包括： 选项含义: ro 以只读模式加载该文件系统 sync 不对该设备的写操作进行缓冲处理，这可以防止在非正常关机时情况下破坏文件系统，但是却降低了计算机速度 user 允许普通用户加载该文件系统 quota 强制在该文件系统上进行磁盘定额限制 noauto 不再使用mount －a命令（例如系统启动时）加载该文件系统 fs_dump 该选项被&quot;dump&quot;命令使用来检查一个文件系统应该以多快频率进行转储，若不需要转储就设置该字段为0 fs_pass 该字段被fsck命令用来决定在启动时需要被扫描的文件系统的顺序，根文件系统&quot;/&quot;对应该字段的值应该为1， 其他文件系统应该为2。若该文件系统无需在启动时扫描则设置该字段为0 ubuntu上实例:&lt;file system&gt; &lt;mount point&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt; / was on /dev/sda1 during installation UUID=757fbb2f-6ee4-4a05-ad2e-0c16b3edc982 / ext4 errors=remount-ro 0 1 /home was on /dev/sda6 during installation UUID=a018cd99-6608-43fc-adea-319a5f04fb29 /home ext4 defaults 0 2 /opt was on /dev/sda7 during installation UUID=0351ac71-4e1d-4194-8d7f-4d9e873e5830 /opt ext4 defaults 0 2 /work was on /dev/sda8 during installation UUID=3f49c9cc-c9cc-48c5-aa8e-058a1d1ec7ad /work ext4 defaults 0 2 /work2 was on /dev/sda9 during installation UUID=e2f54160-fb2d-4517-af54-13393f80ef5f /work2 ext4 defaults 0 2 swap was on /dev/sda5 during installation UUID=d15cbce2-bff1-4241-9c3c-6811f4a1d67d none swap sw 0 0 Android fstab格式及实例https://source.android.com/devices/storage/config.html &lt;src&gt; &lt;mnt_point&gt; &lt;type&gt; &lt;mnt_flags&gt; &lt;fs_mgr_flags&gt; /devices/ff0f0000.rksdmmc/mmc_host/mmc /mnt/internal_sd vfat defaults voldmanaged=internal_sd:15,noemulatedsd /dev/block/platform/ff0f0000.rksdmmc/by-name/system /system ext4 ro,noatime,nodiratime,noauto_da_alloc wait,resize,check src: 设备路径 mnt_point: 挂在点 type: volume中文件系统类型, 对于external cards, type 为vfat mnt_flags: Vold ignores this field and it should be set to defaults fs_mgr_flags: Vold ignores any lines in the unified fstab that do not include the voldmanaged= flag in this field. This flag must be followed by a label describing the card, and a partition number or the word auto. Here is an example: voldmanaged=sdcard:auto. Other possible flags are nonremovable, encryptable=sdcard, noemulatedsd, and encryptable=userdata. 待续...","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"fstab","slug":"fstab","permalink":"jingg.me/tags/fstab/"}]},{"title":"Input系统——APP事件监听及处理","slug":"InputSystem005_ExampleAPP","date":"2016-12-31T16:00:00.000Z","updated":"2017-04-26T13:02:15.949Z","comments":true,"path":"2017/01/01/InputSystem005_ExampleAPP/","link":"","permalink":"jingg.me/2017/01/01/InputSystem005_ExampleAPP/","excerpt":"InputDevicehttps://developer.android.com/reference/android/view/InputDevice.html android.support.wearable 包 http://stackoverflow.com/questions/24520240/import-android-support-wearable-cannot-be-resolved","text":"InputDevicehttps://developer.android.com/reference/android/view/InputDevice.html android.support.wearable 包 http://stackoverflow.com/questions/24520240/import-android-support-wearable-cannot-be-resolved","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"input","slug":"input","permalink":"jingg.me/tags/input/"},{"name":"input系统","slug":"input系统","permalink":"jingg.me/tags/input系统/"},{"name":"APP","slug":"APP","permalink":"jingg.me/tags/APP/"}]},{"title":"Android 智能指针——SP WP","slug":"Android智能指针——SP WP","date":"2016-12-31T16:00:00.000Z","updated":"2017-04-26T12:37:21.883Z","comments":true,"path":"2017/01/01/Android智能指针——SP WP/","link":"","permalink":"jingg.me/2017/01/01/Android智能指针——SP WP/","excerpt":"","text":"http://blog.163.com/ye_kc_lcx88/blog/static/217863346201462411215858/","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"强指针","slug":"强指针","permalink":"jingg.me/tags/强指针/"},{"name":"弱指针","slug":"弱指针","permalink":"jingg.me/tags/弱指针/"},{"name":"智能指针","slug":"智能指针","permalink":"jingg.me/tags/智能指针/"}]},{"title":"Android版本-sdk-ndk-对应关系表","slug":"Android版本-sdk-ndk-对应关系","date":"2016-12-12T04:22:33.000Z","updated":"2017-04-13T11:51:28.273Z","comments":true,"path":"2016/12/12/Android版本-sdk-ndk-对应关系/","link":"","permalink":"jingg.me/2016/12/12/Android版本-sdk-ndk-对应关系/","excerpt":"","text":"Code name Version API level Nougat 7.1 API level 25 Nougat 7.0 API level 24 Marshmallow 6.0 API level 23 Lollipop 5.1 API level 22 Lollipop 5.0 API level 21, NDK 10 KitKat 4.4 - 4.4.4 API level 19 Jelly Bean 4.3.x API level 18 Jelly Bean 4.2.x API level 17 Jelly Bean 4.1.x API level 16 Ice Cream Sandwich 4.0.3 - 4.0.4 API level 15, NDK 8 Ice Cream Sandwich 4.0.1 - 4.0.2 API level 14, NDK 7 Honeycomb 3.2.x API level 13 Honeycomb 3.1 API level 12, NDK 6 Honeycomb 3.0 API level 11 Gingerbread 2.3.3 - 2.3.7 API level 10 Gingerbread 2.3 - 2.3.2 API level 9, NDK 5 Froyo 2.2.x API level 8, NDK 4 Eclair 2.1 API level 7, NDK 3 Eclair 2.0.1 API level 6 Eclair 2.0 API level 5 Donut 1.6 API level 4, NDK 2 Cupcake 1.5 API level 3, NDK 1 (no code name) 1.1 API level 2 (no code name) 1.0 API level 1","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"jingg.me/tags/Android/"},{"name":"版本","slug":"版本","permalink":"jingg.me/tags/版本/"},{"name":"SDK","slug":"SDK","permalink":"jingg.me/tags/SDK/"},{"name":"API level","slug":"API-level","permalink":"jingg.me/tags/API-level/"},{"name":"NDK","slug":"NDK","permalink":"jingg.me/tags/NDK/"}]},{"title":"Android SEpolicy策略规则","slug":"Android SEpolicy策略规则","date":"2016-10-12T10:22:33.000Z","updated":"2017-04-20T07:51:17.912Z","comments":true,"path":"2016/10/12/Android SEpolicy策略规则/","link":"","permalink":"jingg.me/2016/10/12/Android SEpolicy策略规则/","excerpt":"","text":"SEAndroid中各种实体的SContext 定义介绍进程、文件/目录、服务、系统属性等SContext 定义 进程的SContext（以system_server进程为例）（对应每个进程的te文件）u:r:system_server:s0 system 494 186 system_server u表示user SELinux用户 r表示SELinux角色 system_server表示domain，该域的权限定义在策略文件system_server.te中 s0表示MLS中的级别，Android中可忽略 file和dir的SContext（以system目录为例）（在file_contexts定义）drwxr-xr-x root root u:object_r:system_file:s0 system object_r表示文件对象 system_file表示文件类型 fs_use(在fs_use定义)// to do 生成 文件系统的 SContext （在genfs_contexts定义）genfscon rootfs / u:object_r:rootfs:s0 genfscon usbfs / u:object_r:usbfs:s0 property的SContext（在property_contexts定义）* u:object_r:default_prop:s0 //默认property SContext hw. u:object_r:system_prop:s0 service的SContext（在service_contexts定义）* u:object_r:default_android_service:s0 //默认服务SContext package u:object_r:system_server_service:s0 //package 服务 （在shell中执行service list查看所有服务） APP的SContext （在mac_permissions.xml+seapp_contexts+xxx定义，详见 APP安全策略） APP的seinfo: 根据apk的签名决定app的seinfo(platform、default) 1. 特殊APP——system_server (因为它也是有zygote产生的，所以还是也在seapp_contexts中定义) isSystemServer=true domain=system_server // isSystemServer返回true，则domain=system_server 2. 通过user + seinfo + [name]来决定domain 和 type user=cts seinfo=* name=roidJUnitRunner domain=ctsrunner_app type=app_data_file // user 是cts，则domain=ctsrunner_app type=app_data_file CTS测试APP user=system domain=system_app type=system_app_data_file // user是 system seinfo默认是platform签名，则domain=system_app type=system_app_data_file 系统APP // (有android平台签名和system权限) user=bluetooth domain=bluetooth type=bluetooth_data_file // bluetooth user=nfc domain=nfc type=nfc_data_file // nfc user=radio domain=radio type=radio_data_file // radio user=shared_relro domain=shared_relro // shared_relro user=shell domain=shell type=shell_data_file // shell user=_isolated domain=isolated_app // _isolated user=_app seinfo=platform domain=platform_app type=app_data_file // 平台APP(有android平台签名，没有system权限) user=_app domain=untrusted_app type=app_data_file // 其他的都是第三方(untrusted_app)APP (没有Android平台签名，没有system权限) APP安全策略 APP的SContext 确定了APP domain和type ，下面就是不同类型的app domain的安全策略te文件 app.te 应用给所有APP的安全策略（这里的所有APP指的是所有由zygote产生的进程），appdomain域——APP的基域 system_server.te system_server的安全策略 ctsrunner_app.te CTS APP 的安全策略 system_app.te 系统 APP的安全策略 bluetooth.te bluetooth APP的安全策略 nfc.te nfc APP 的安全策略 radio.te radio APP的安全策略 shared_relro.te shared_relro APP的安全策略 shell.te 通过shell 启动的APP的安全策略 isolated_app.te isolated APP的安全策略 AID_ISOLATED_START (99000) ---&gt; AID_ISOLATED_END (99999). platform_app.te 第三方平台 APP的安全策略 untrusted_app.te 其他的都是第三方 APP的安全策略 APP_AID (10000) ---&gt; AID_ISOLATED_START (99000) 安全策略语法 上面都将各个实体的SContext 逐一罗列出来了，下面讲下*.te 文件语法 关键字的关键字 （有点拗口，但确实是这样的） attribute 用于指定xxx_type和domain关键字的关键字 type 用于指定domain域的关键字的关键字 typeattribute 单独将某个type和某个或多个attribute关联起来 基本语法我们再来看看最常见的权限设置语句： allow netd sysfs:file write; 1）allow：表示授权。除了allow之外，还有allowaudit、dontaudit、neverallow等； 这条语句的语法为： 2）netd：sourcetype，也叫Domain，Subject。 3）sysfs：targettype，它代表其后的file所对应的Type。 4）file：objectclass，它代表能够给Domain操作的对象。例如file、dir、socket等，Android中SecurityClass的定义在security_classes中。在Android系统中，有一些特殊的Class，如property_service，binder等。 5）write：在该类objectclass中所定义的操作，例如file类支持ioctl，read，write等操作。access_vectors中定义了所有objectclass支持的操作。 根据SELinux规范，完整的allow语句格式为： rule_name source_type target_type:class perm_set; 1）如果有多个source_type，target_type，class或perm_set，可以用&quot;{}&quot;括起来； 注意：使用allow语句的时候，可以使用下面的一些小技巧来简化命令书写； 2）&quot;~&quot;号，表示除了&quot;~&quot;以外； 3）&quot;-&quot;号，表示去除某项内容； 4）&quot;*&quot;号，表示所有内容 高级语法 对于一般的*.te文件编写，基本的语法就差不多够了，下面是高级语法，说高级语法就是相当于一个批量生成sepolicy规则的的语法，让你少些点规则 域转换(DomainTransition,简称DT) SEAndroid中，init进程的SContext为u:r:init:s0（在init.rc中使用” setcon u:r:init:s0”命令设置），而init创建的子进程显然不会也不可能拥有和init进程一样的SContext （否则根据TE，这些子进程也就在MAC层面上有了和init进程一样的权限）。那么这些子进程是怎么被打上和父进程不一样的SContex呢？ 在SELinux中，上述问题被称为DomainTransition，即某个进程的Domain切换到一个更合适的Domain中去。DomainTransition也是在安全策略文件中配置的，而且有相关的关键字。 语法: type\\_transition source\\_type target\\_type:class default\\_type 表示source_type域的进程在对target_type类型的文件进行class定义的操作时，进程会切换到default_type域中 下面我们看个域转换的例子： type_transition init shell_exec:process init_shell 这个例子表示：当init域的进程执行（process）shell_exec类型的可执行文件时，进程会从init域切换到init_shell域。 那么，哪个文件是shell_exec类型呢？从file_contexts文件能看到，/system/bin/sh的安全属性是u:object_r:shell_exec:s0， 也就是说init域的进程如果运行shell脚本的话，进程所在的域就会切换到init_shell域，这就是DomainTransition（简称DT）。 请注意，DT也是SELinux安全策略的一部分，type_transition不过只是开了一个头而已，要真正实施成功这个DT，还至少需要下面三条权限设置语句： # 首先，你得让init域的进程要能够执行shell_exec类型的文件 allow init shell_exec:file execute; # 然后，你需要告诉SELinux，允许init域的进程切换到init_shell域 allow init init_shell:process transition; # 最后，你还得告诉SELinux，域切换的入口（entrypoint）是执行shell_exec类型的文件 allow init_shell shell_exec:file entrypoint; 看起来挺麻烦，不过SELinux支持宏定义，我们可以定义一个宏，把上面4个步骤全部包含进来。在SEAndroid中，所有的宏都定义在te_macros文件中，其中和DT相关的宏定义如下： # 定义domain_trans宏，$1,$2,$3代表宏的第一个，第二个…参数 define(`domain_trans&apos;, ` allow $1 $2:file { getattr open read execute }; allow $1 $3:process transition; allow $3 $2:file { entrypoint open read execute getattr }; … … &apos;) # 定义domain_auto_trans宏，这个宏才是我们在te中直接使用的 define(`domain_auto_trans&apos;, ` # Allow the necessary permissions. domain_trans($1,$2,$3) # Make the transition occur by default. type_transition $1 $2:process $3; &apos;) 呵呵，是不是简单多了，domain_trnas宏在DT需要的最小权限的基础上还增加了一些权限，在te文件中可以直接用domain_auto_trans宏来显示声明域转换，如下： domain_auto_trans(init, shell_exec, init_shell) 类型转换(TypeTransition,简称TT) 除了DT外，还有针对Type的Transition（简称TT）。举个例子，假设目录A的SContext为u:r:dir_a，那么默认情况下， 在该目录下创建的文件的SContext就是u:r:dir_a，如果想让它的SContext发生变化，那么就需要TypeTransition。 和DT类似，TT的关键字也是type_transition，而且要顺利完成Transition，也需要申请相关权限，废话不多说了， 直接看te_macros是怎么定义TT所需的宏： # 定义file_type_trans宏，为Type Transition申请相关权限 define(`file_type_trans&apos;, ` allow $1 $2:dir ra_dir_perms; allow $1 $3:notdevfile_class_set create_file_perms; allow $1 $3:dir create_dir_perms; &apos;) # 定义file_type_auto_trans(domain, dir_type, file_type)宏 # 该宏的意思就是当domain域的进程在dir_type类型的目录创建文件时，该文件的SContext # 应该是file_type类型 define(`file_type_auto_trans&apos;, ` # Allow the necessary permissions. file_type_trans($1, $2, $3) # Make the transition occur by default. type_transition $1 $2:dir $3; type_transition $1 $2:notdevfile_class_set $3; &apos;) 栗子： file_type_auto_trans(app_domain, system_data_file, xxx_type) class集合 class// to do 权限集合 perm_set// to do 附SELinux模式切换命令 SELinux支持Disabled，Permissive，Enforce三种模式 Disabled就不用说了，此时SELinux的权限检查机制处于关闭状态； Permissive模式就是SELinux有效，但是即使你违反了它的安全策略，它让你继续运行，但是会把你违反的内容记录下来。在策略开发的时候非常有用，相当于Debug模式； Enforce模式就是你违反了安全策略的话，就无法继续操作下去。 在Eng版本使用setenforce命令，可以在Permissive模式和Enforce模式之间切换。 usage: setenforce [ Enforcing | Permissive | 1 | 0 ] -Z——查看SContext 信息的命令ls -Z // 文件目录的SContext ps -Z // 进程的SContext chcon命令——更改文件的安全属性usage: chcon &lt;SContext&gt; &lt;path&gt; restorecon命令——恢复文件原来的安全属性 当文件的安全属性在安全策略配置文件里面有定义时，使用restorecon命令，可以恢复原来的安全属性 usage: restorecon [-DFnrRv] &lt;path&gt; id 命令——确认自己的SecurityContext$ id uid=2000(shell) gid=2000(shell) groups=1007(log) context=u:r:shell:s0 # id uid=0(root) gid=0(root) groups=1007(log) context=u:r:su:s0 ####参考： http://blog.csdn.net/modianwutong/article/details/43114883 http://blog.csdn.net/zhudaozhuan/article/details/50964832","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"SEAndroid","slug":"SEAndroid","permalink":"jingg.me/tags/SEAndroid/"},{"name":"sepolicy","slug":"sepolicy","permalink":"jingg.me/tags/sepolicy/"}]},{"title":"Android JNI介绍及使用","slug":"Android JNI介绍及使用","date":"2016-10-08T04:22:33.000Z","updated":"2017-04-17T11:26:12.622Z","comments":true,"path":"2016/10/08/Android JNI介绍及使用/","link":"","permalink":"jingg.me/2016/10/08/Android JNI介绍及使用/","excerpt":"","text":"JNI 介绍JNI是Java Native Interface的缩写，它提供了若干的API实现了Java和其他语言的通信（主要是C&amp;C++）。 JNI 类型 jni中结构体层次结构 下面是访问String的一些方法： GetStringUTFChars 将jstring转换成为UTF-8格式的char* / ReleaseStringUTFChars 释放指向UTF-8格式的char*的指针 GetStringChars 将jstring转换成为Unicode格式的char* / ReleaseStringChars 释放指向Unicode格式的char*的指针 NewStringUTF 创建一个UTF-8格式的String对象 NewString 创建一个Unicode格式的String对象 GetStringUTFLengt 获取 UTF-8格式的char*的长度 GetStringLength 获取Unicode格式的char*的长度 JNI 实现如果需要在Java中使用到native接口的话，可以使用JNI这个方式来达到目的： 1. Java侧使用方法public class AudioFlingerBinderTest extends TestCase { private static native boolean native_test_setMasterMute(); //声明native函数，都是以native_开头 static { System.loadLibrary(&quot;ctssecurity_jni&quot;); //加载jni库，该函数会找到对应的动态库，然后首先试图找到 // &quot;JNI_OnLoad&quot;函数，如果该函数存在，则调用它。 } //使用native_test_setMasterMute() ..... } 2. Java侧Android.mk编写Android.mk LOCAL_PATH:= $(call my-dir) include $(CLEAR_VARS) ... LOCAL_JNI_SHARED_LIBRARIES := libctssecurity_jni libcts_jni ... 3. JNI侧库ctssecurity_jni的Android.mkAndroid.mk------------------------------ LOCAL_PATH:= $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE := libctssecurity_jni LOCAL_MODULE_TAGS := optional LOCAL_SRC_FILES := \\ CtsSecurityJniOnLoad.cpp \\ android_security_cts_CharDeviceTest.cpp \\ ..... LOCAL_C_INCLUDES := $(JNI_H_INCLUDE) LOCAL_SHARED_LIBRARIES := libnativehelper liblog libbinder libutils libmedia libselinux libdl include $(BUILD_SHARED_LIBRARY) 4. JNI侧库ctssecurity_jni4.1 实现native函数jboolean android_security_cts_AudioFlinger_test_setMasterMute(JNIEnv* env __unused, jobject thiz __unused) { //具体实现 } or jboolean android_security_cts_AudioFlinger_test_setMasterMute(JNIEnv* env, jclass clazz) { //具体实现 } 4.2 注册native函数static JNINativeMethod gMethods[] = { { &quot;native_test_setMasterMute&quot;, &quot;()Z&quot;, (void *) android_security_cts_AudioFlinger_test_setMasterMute }, }; int register_android_security_cts_AudioFlingerBinderTest(JNIEnv* env) { jclass clazz = env-&gt;FindClass(&quot;android/security/cts/AudioFlingerBinderTest&quot;); return env-&gt;RegisterNatives(clazz, gMethods, sizeof(gMethods) / sizeof(JNINativeMethod)); } or int register_android_security_cts_AudioFlingerBinderTest(JNIEnv* env) { int res = jniRegisterNativeMethods(env, &quot;android/security/cts/AudioFlingerBinderTest&quot;, gMethods, NELEM(gMethods)); LOG_FATAL_IF(res &lt; 0, &quot;Unable to register native methods.&quot;); return res; } 4.3 jni库的主函数/加载入口：#include &lt;jni.h&gt; #include &lt;stdio.h&gt; #include “xxx.h” jint JNI_OnLoad(JavaVM *vm, void *reserved) { JNIEnv *env = NULL; if (vm-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_4) != JNI_OK) { return JNI_ERR; } if (register_android_security_cts_AudioFlingerBinderTest(env)) { return JNI_ERR; } return JNI_VERSION_1_4; }","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"JNI","slug":"JNI","permalink":"jingg.me/tags/JNI/"},{"name":"native调用","slug":"native调用","permalink":"jingg.me/tags/native调用/"}]},{"title":"C++的类型转换——隐式、显式转换(xxx_cast)","slug":"LangCPP_C++xxx_cast","date":"2016-05-28T04:22:33.000Z","updated":"2017-04-18T02:50:19.948Z","comments":true,"path":"2016/05/28/LangCPP_C++xxx_cast/","link":"","permalink":"jingg.me/2016/05/28/LangCPP_C++xxx_cast/","excerpt":"","text":"第一部分. 隐式类型转换算数运算float + int =&gt; float 、 赋值int = float、传参、返回值 第二部分.显式类型转换C风格 (type) value C++风格 static_cast、dynamic_cast、reinterpret_cast和const_cast static_cast (expression)该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性，如下几种用法： a. 用于类层次结构中基类和子类之间指针或引用的转换。 进行上行转换（把子类的指针或引用转换成基类表示）是安全的； 进行下行转换（把基类指针或引用转换成子类指针或引用）时，由于没有动态类型检查，所以是不安全的。 b. 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。 c. 把void指针转换成目标类型的指针(不安全!!) e. 把任何类型的表达式转换成void类型。 注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。 来源：为什么需要static_cast强制转换？ 情况1：void指针-&gt;其他类型指针 情况2：改变通常的标准转换 情况3：避免出现可能多种转换的歧义 dynamic_cast (expression)该运算符把expression转换成type-id类型的对象。Type-id必须是类的指针、类的引用或者void *；如果type-id是类指针类型，那么expression也必须是一个指针，如果type-id是一个引用，那么expression也必须是一个引用。 dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。 class Base{ public: int m_iNum; virtual void foo(); }; class Derived:public Base{ public: char *m_szName[100]; }; void func(Base *pb){ //pb可能是Base or Derived Derived *pd1 = static_cast&lt;Derived *&gt; (pb); Derived *pd2 = dynamic_cast&lt;Derived *&gt; (pb); } 在上面的代码段中，如果pb实际指向一个Derived类型的对象，pd1和pd2是一样的，并且对这两个指针执行Derived类型的任何操作都是安全的； 如果pb实际指向的是一个Base类型的对象，那么pd1将是一个指向该对象的指针，对它进行Derived类型的操作将是不安全且非法的（如访问m_szName），而pd2将是一个空指针(即0，因为dynamic_cast失败)。 另外要注意： dynamic_cast 转换时Base要有虚函数，否则会编译出错；static_cast则没有这个限制。这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表（关于虚函数表的概念，详细可见&lt;Inside c++ object model&gt;）中，只有定义了虚函数的类才有虚函数表，没有定义虚函数的类是没有虚函数表的。 dynamic_cast还支持交叉转换（cross cast）。如下代码所示。 class Base { public: int m_iNum; virtual void f(){} }; class Derived1 : public Base{ }; class Derived2 : public Base { }; void foo() { Derived1 *pd1 = new Drived1(); pd1-&gt;m_iNum = 100; Derived2 *pd2 = static_cast&lt;Derived2 *&gt;(pd1); //Compile error Derived2 *pd2 = dynamic_cast&lt;Derived2 *&gt;(pd1); //pd2 is NULL delete pd1; } 在函数foo中，使用static_cast进行转换是不被允许的，将在编译时出错；而使用 dynamic_cast的转换则是允许的，结果是空指针。 来源：为什么需要dynamic_cast强制转换？ 简单的说，当无法使用virtual函数的时候 reinterpret_cast (expression)是C++中强制类型转换符，操作符修改了操作数类型，但仅仅是重新解释了给出的对象的比特模型而没有进行二进制转换。eg: void *p ===&gt; int p type-id必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，再把该整数转换成原类型的指针，还可以得到原先的指针值）。 reinterpret_cast是为了映射到一个完全不同类型的意思，这个关键词在我们需要把类型映射回原有类型时用到它。 const_cast (expression)该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。 常量指针被转化成非常量指针，并且仍然指向原来的对象； 常量引用被转换成非常量引用，并且仍然指向原来的对象； 常量对象被转换成非常量对象。 Voiatile和const类试。举如下一例： class B{ public: int m_iNum; } void foo(){ const B b1; b1.m_iNum = 100; //comile error B b2 = const_cast&lt;B&gt;(b1); // 去掉const 属性 b2. m_iNum = 200; //fine } 上面的代码编译时会报错，因为b1是一个常量对象，不能对它进行改变； 使用const_cast把它转换成一个非常量对象，就可以对它的数据成员任意改变。注意：b1和b2是两个不同的对象。 比较static_cast Vs. reinterpret_castreinterpret_cast是为了映射到一个完全不同类型的意思，这个关键词在我们需要把类型映射回原有类型时用到它。我们映射到的类型仅仅是为了故弄玄虚和其他目的，这是所有映射中最危险的。(这句话是C++编程思想中的原话) static_cast 和 reinterpret_cast 操作符修改了操作数类型。它们不是互逆的； static_cast 在编译时使用类型信息执行转换，在转换执行必要的检测(诸如指针越界计算, 类型检查). 其操作数相对是安全的。另一方面；reinterpret_cast 仅仅是重新解释了给出的对象的比特模型而没有进行二进制转换，例子如下： int n=9; double d=static_cast &lt; double &gt; (n); 上面的例子中, 我们将一个变量从 int 转换到 double。这些类型的二进制表达式是不同的。 要将整数 9 转换到 双精度整数 9，static_cast 需要正确地为双精度整数 d 补足比特位。其结果为 9.0。而reinterpret_cast 的行为却不同: int n=9; double d=reinterpret_cast&lt;double &amp; &gt; (n); 这次, 结果有所不同. 在进行计算以后, d 包含无用值. 这是因为 reinterpret_cast 仅仅是复制 n 的比特位到 d, 没有进行必要的分析. 因此, 你需要谨慎使用 reinterpret_cast. C++primer第五章里写了编译器隐式执行任何类型转换都可由static_cast显示完成;reinterpret_cast通常为操作数的位模式提供较低层的重新解释 1、C++中的static_cast执行非多态的转换，用于代替C中通常的转换操作。因此，被做为隐式类型转换使用。比如： int i; float f = 166.7f; i = static_cast&lt;int&gt;(f); 此时结果，i的值为166。 2、C++中的reinterpret_cast主要是将数据从一种类型的转换为另一种类型。所谓“通常为操作数的位模式提供较低层的重新解释”也就是说将数据以二进制存在形式的重新解释。比如： int i; char *p = &quot;This is a example.&quot;; i = reinterpret_cast&lt;int&gt;(p); 此时结果，i与p的值是完全相同的。reinterpret_cast的作用是说将指针p的值以二进制（位模式）的方式被解释为整型，并赋给i，一个明显的现象是在转换前后没有数位损失。 C++的类型转换明显比C里面的用()的类型转换要严谨很多。首先，C++样式的类型转换编写 的代码更容易维护，想想看，只要搜索“static_cast”，就可以找出代码中所有使用了静态转换的代码，比C里面五花八门的 (long) (long*) (double )好找多了吧。另外，reinterpret_cast，看字面意思就知道，是保持二进制位不变，用另一种格式来重新解释，我们也知道计算机里面只有 bit,到底代表什么类型，整形还是浮点型，全在于应用程序怎么解释每一个bit，reinterpret_cast给了我们这么一个机会。而C里面要想 二进制重解释，你要么拷贝内存，要么还是用()来强制类型转换，某些特定情况下，()强制转换其实是二进制的重解释，毫无疑问，C风格的转换会让代码变得 难懂。","categories":[{"name":"C++","slug":"C","permalink":"jingg.me/categories/C/"}],"tags":[{"name":"类型转换","slug":"类型转换","permalink":"jingg.me/tags/类型转换/"},{"name":"static_cast","slug":"static-cast","permalink":"jingg.me/tags/static-cast/"},{"name":"dynamic_cast","slug":"dynamic-cast","permalink":"jingg.me/tags/dynamic-cast/"},{"name":"reinterpret_cast","slug":"reinterpret-cast","permalink":"jingg.me/tags/reinterpret-cast/"},{"name":"const_cast","slug":"const-cast","permalink":"jingg.me/tags/const-cast/"}]}]}