{"meta":{"title":"进无止境's 博客","subtitle":"","description":"","author":"Jim","url":"jingg.me"},"pages":[{"title":"About","date":"2017-04-07T10:43:03.000Z","updated":"2017-04-26T08:17:33.784Z","comments":true,"path":"about/index.html","permalink":"jingg.me/about/index.html","excerpt":"","text":"Hello, I’m Jim, contact me with email 18986218971@qq.com ."}],"posts":[{"title":"Android Binder","slug":"Android_Binder","date":"2017-04-27T02:37:33.000Z","updated":"2017-05-10T00:29:41.557Z","comments":true,"path":"2017/04/27/Android_Binder/","link":"","permalink":"jingg.me/2017/04/27/Android_Binder/","excerpt":"Binder 通信机制概述Binder通信是一种类似于IPC 的机制，基于C/S通信结构，它是给servicemanager-server、server-client之间通信的工具，下面简单介绍具体实现原理： 从表面上来看，是client通过获得一个server的代理接口，对server进行直接调用；实际上，代理接口中定义的方法与server中定义的方法是一一对应的。 client调用某个代理接口中的方法时，代理接口的方法会将client传递的参数打包成为Parcel对象；代理接口将该Parcel发送给内核中的binder driver。server会读取binder driver中的请求数据，如果是发送给自己的，解包Parcel对象，处理并将结果返回； 整个的调用过程是一个同步过程，在server处理的时候，client会block住。","text":"Binder 通信机制概述Binder通信是一种类似于IPC 的机制，基于C/S通信结构，它是给servicemanager-server、server-client之间通信的工具，下面简单介绍具体实现原理： 从表面上来看，是client通过获得一个server的代理接口，对server进行直接调用；实际上，代理接口中定义的方法与server中定义的方法是一一对应的。 client调用某个代理接口中的方法时，代理接口的方法会将client传递的参数打包成为Parcel对象；代理接口将该Parcel发送给内核中的binder driver。server会读取binder driver中的请求数据，如果是发送给自己的，解包Parcel对象，处理并将结果返回； 整个的调用过程是一个同步过程，在server处理的时候，client会block住。 Binder 通信机制实现原理Binder 通信机制实现IPC的方式和我们所了解的消息队列、信号量、管道等不同，他是通过Binder设备（一个实现数据交换的虚拟设备）来实现数据交换，一次信息传递过程只发生一次拷贝，数据交换非常高效。Binder通信机制中有三个角色，service manager(简称SM)、service、client，它们在Android系统都是有各自的进程在系统中运行，每个进程都与Binder设备建立了信息通信通道(通过open /dev/binder),通过binder设备实现SM、service、client之间的信息交换。 底层实现机制：SM —- handle 0service1 —- handle s1service2 —- handle s2…serviceN —- handle sN client1 —- handle c1client2 —- handle c2…clientN —- handle cN SM 作为service manager，它负责管理service(说白了就是：响应service发送给它的消息)，service添加/service句柄的获取/serviceListservice 负责处理client的RPC请求（也就是响应client发送过来的消息）client 就是主动发送请求一方。 binder机制中交换数据(发送消息)，例如service发送消息给SM，它是将信息通过binder驱动直接挂接到SM 关联的handle下，然后SM直接去读自己handle=0下的消息并进行解析就可以了。从而完成一次数据交换。 Android系统中有如下几种场景： 进程添加service 到SM中。 a. 通过SM handle(默认固定为0)，发送消息给SM； b. SM进程的loop循环获取到发送给自己handle的消息并获取到service注册信息； c. SM将service信息注册到底层binder设备，binder设备给该service分派一个handle sX(关联service name)，功能就算完成。 client 使用service服务。（这其中包含两次binder） A. client 获取指定service句柄 a. client所在进程发送消息给SM(handle固定为0)，即写入parcel信息到binder设备，挂接到SM的handle名下。 b. SM 进程loop循环读取到发给自己信息，解析后，返回对应service name的service handle信息给client。 B. client 使用service句柄使用service提供的接口 a. client所在进程发送接口调用信息给（service handle），即写入parcel信息到binder设备，挂接到service的handle下； b. service 的IPCProcess joinThreadPool中循环获取到发送给自己的消息，处理并以parcel格式返回给binder设备中对应handle的client； c. 然后client调用过程完成。 Binder 通信机制在Android中的实现场景1实现：servicemanager (frameworks\\native\\cmds\\servicemanager\\service_manager.c) 打开/dev/binder设备，将fd映射到128k的内存 将servermanger设置为binder设备的context manager(可以理解为ServiceManager可以将自己注册为Binder的管理员) 循环读取发送给handle 0 的消息 Bn端循环响应server/client过来的请求 C++中的Bp端（跑在使用SM的client或者server 的进程中的） Java中的Bp端（跑在使用SM的client或者server 的进程中的） 场景2实现：（以MediaPlayerService为例）","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"Binder","slug":"Binder","permalink":"jingg.me/tags/Binder/"},{"name":"IPC","slug":"IPC","permalink":"jingg.me/tags/IPC/"},{"name":"RPC","slug":"RPC","permalink":"jingg.me/tags/RPC/"}]},{"title":"Linux select pselect poll epoll用法","slug":"Linux_select_poll","date":"2017-04-18T16:00:00.000Z","updated":"2017-05-10T10:30:53.253Z","comments":true,"path":"2017/04/19/Linux_select_poll/","link":"","permalink":"jingg.me/2017/04/19/Linux_select_poll/","excerpt":"select &amp; pselect#include &lt;sys/select.h&gt; #include &lt;sys/time.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; void FD_CLR(int fd, fd_set *set); int FD_ISSET(int fd, fd_set *set); void FD_SET(int fd, fd_set *set); void FD_ZERO(fd_set *set); int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); 监控fd状态（timeout 是到期前剩余时间） int pselect(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timespec *timeout, const sigset_t *sigmask); 除了监测fd状态，pselect精度更准，且监测signal(另外pselect的timeout参数是const的) monitor multiple file descriptors, waiting until one or more of the file descriptors become “ready” for some class of I/O operation","text":"select &amp; pselect#include &lt;sys/select.h&gt; #include &lt;sys/time.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; void FD_CLR(int fd, fd_set *set); int FD_ISSET(int fd, fd_set *set); void FD_SET(int fd, fd_set *set); void FD_ZERO(fd_set *set); int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); 监控fd状态（timeout 是到期前剩余时间） int pselect(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timespec *timeout, const sigset_t *sigmask); 除了监测fd状态，pselect精度更准，且监测signal(另外pselect的timeout参数是const的) monitor multiple file descriptors, waiting until one or more of the file descriptors become “ready” for some class of I/O operation poll &amp; ppoll#include &lt;poll.h&gt; int poll(struct pollfd *fds, nfds_t nfds, int timeout); fds: 监听事件的item数组 nfds: 数组成员数 timeout: 超时时间(unit:milliseconds, -1 mean infinite, 0 mean immediately) return: success: &gt; 0 带有revents事件的数组个数; = 0 time out 或者没有fd 事件 error: -1, errno is set int ppoll(struct pollfd *fds, nfds_t nfds, const struct timespec *timeout_ts, const sigset_t *sigmask); fds: 监听事件的item数组 nfds: 数组成员数 timeout_ts: 超时时间(unit:seconds+nanoseconds, -1:indefinitely, 0:immediately) sigmask: 监测的signal (遇到这些signal，ppoll也会返回) (NULL:indefinitely) return: success: &gt; 0 带有revents事件的数组个数; = 0 time out 或者没有fd 事件 error: -1, errno is set performs a similar task to select(2): it waits for one of a set of file descriptors to become ready to perform I/O. 结构体struct pollfd { int fd; /* in, file descriptor */ short events; /* in, requested events 请求需要监测的事件类型 */ short revents; /* out, returned events 发生的事件类型 */ }; The bits that may be set/returned in events and revents are defined in &lt;poll.h&gt;: POLLIN 可读 POLLPRI 紧急数据可读 POLLOUT 可读(不会block) POLLRDHUP 对端关闭, 本段hangup, 只针对stream socket fd POLLERR 错误状态 (output only，即只会出现在revents中) POLLHUP Hang up (output only，即只会出现在revents中) POLLNVAL 无效请求 (output only，即只会出现在revents中) epollThe epoll API performs a similar task to poll(2): monitoring multiple file descriptors to see if I/O is possible on any of them.The epoll API can be used either as an edge-trig‐gered or a level-triggered interface and scales well to large numbers of watched file descriptors. 模式 and LT(Level-triggered) 一般 ET(edge-triggered) 事件发生时就触发 epoll_create creates an epoll instance and returns a file descriptor referring to that instance, The more recent epoll_create1 extends the functionality. #include &lt;sys/epoll.h&gt; int epoll_create(int size); int epoll_create1(int flags); epoll_ctl register particular file descriptors interested. #include &lt;sys/epoll.h&gt; int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); epfd: return by epoll_create op: EPOLL_CTL_ADD Register the target file descriptor fd on the epoll instance EPOLL_CTL_MOD Change the event event associated with the target file descriptor fd. EPOLL_CTL_DEL Remove (deregister) the target file descriptor fd from the epoll fd: 需要监听的描述符fd event：需要监听的指定fd上的事件 typedef union epoll_data { void *ptr; int fd; uint32_t u32; uint64_t u64; } epoll_data_t; struct epoll_event { uint32_t events; // EPOLLIN EPOLLOUT EPOLLRDHUP EPOLLPRI EPOLLERR EPOLLHUP EPOLLET EPOLLONESHOT epoll_data_t data; // User data variable }; return: success 0 error -1 errno epoll_wait waits for I/O events, blocking the calling thread if no events are currently available. #include &lt;sys/epoll.h&gt; int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); int epoll_pwait(int epfd, struct epoll_event *events, int maxevents, int timeout, const sigset_t *sigmask); epfd: return by epoll_create events：out, 监听到的事件数组 maxevents: in, 需要监听到事件个数，&gt;0 timeout: time out值， (-1 mean infinite, 0 mean immediately) sigmask: 监测的signal return: the number of file descriptors ready for the requested I/O. 附（epoll 使用示例）功能: 使用epoll 实现tcp server #include &lt;iostream&gt; #include &lt;sys/socket.h&gt; #include &lt;sys/epoll.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;errno.h&gt; using namespace std; #define MAXLINE 5 #define OPEN_MAX 100 #define LISTENQ 20 #define SERV_PORT 5000 #define INFTIM 1000 void setnonblocking(int sock) { int opts; opts=fcntl(sock,F_GETFL); if(opts&lt;0) { perror(&quot;fcntl(sock,GETFL)&quot;); exit(1); } opts = opts|O_NONBLOCK; if(fcntl(sock,F_SETFL,opts)&lt;0) { perror(&quot;fcntl(sock,SETFL,opts)&quot;); exit(1); } } int main(int argc, char* argv[]) { int i, maxi, listenfd, connfd, sockfd, epfd, nfds, portnumber; ssize_t n; char line[MAXLINE]; socklen_t clilen; if (2 == argc ) { if( (portnumber = atoi(argv[1])) &lt; 0 ) { fprintf(stderr,&quot;Usage:%s portnumber/a/n&quot;, argv[0]); return 1; } } else { fprintf(stderr,&quot;Usage:%s portnumber/a/n&quot;,argv[0]); return 1; } //声明epoll_event结构体的变量,ev用于注册事件,数组用于回传要处理的事件 struct epoll_event ev, events[20]; epfd = epoll_create(256); //生成用于处理accept的epoll专用的文件描述符 if (epollfd == -1) { perror(&quot;epoll_create&quot;); exit(EXIT_FAILURE); } // set up server listen socket listenfd = socket(AF_INET, SOCK_STREAM, 0); //setnonblocking(listenfd); //把socket设置为非阻塞方式 ev.events=EPOLLIN | EPOLLET; //设置要处理的事件类型及事件触发模式 ev.data.fd=listenfd; //设置与要处理的事件相关的文件描述符 //注册epoll事件 if (epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &amp;ev) == -1) { perror(&quot;epoll_ctl: listen_sock&quot;); exit(EXIT_FAILURE); } // bind server listen socket struct sockaddr_in serveraddr; bzero(&amp;serveraddr, sizeof(serveraddr)); serveraddr.sin_family = AF_INET; char *local_addr=&quot;127.0.0.1&quot;; inet_aton(local_addr, &amp;(serveraddr.sin_addr)); serveraddr.sin_port = htons(portnumber); bind(listenfd, (sockaddr *)&amp;serveraddr, sizeof(serveraddr)); listen(listenfd, LISTENQ); maxi = 0; struct sockaddr_in clientaddr; for ( ; ; ) { nfds = epoll_wait(epfd,events,20,500); //等待epoll事件的发生 //处理所发生的所有事件 for(i=0; i&lt;nfds; ++i) { if(events[i].data.fd==listenfd)//如果新监测到一个SOCKET用户连接到了绑定的SOCKET端口，建立新的连接。 { connfd = accept(listenfd,(sockaddr *)&amp;clientaddr, &amp;clilen); if(connfd&lt;0){ perror(&quot;connfd&lt;0&quot;); exit(1); } //setnonblocking(connfd); char *str = inet_ntoa(clientaddr.sin_addr); cout &lt;&lt; &quot;accapt a connection from &quot; &lt;&lt; str &lt;&lt; endl; //设置用于读操作的文件描述符 ev.data.fd=connfd; //设置用于注测的读操作事件 ev.events=EPOLLIN|EPOLLET; //ev.events=EPOLLIN; //注册ev epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&amp;ev); } else if(events[i].events&amp;EPOLLIN)//如果是已经连接的用户，并且收到数据，那么进行读入。 { cout &lt;&lt; &quot;EPOLLIN&quot; &lt;&lt; endl; if ( (sockfd = events[i].data.fd) &lt; 0) continue; if ( (n = read(sockfd, line, MAXLINE)) &lt; 0) { if (errno == ECONNRESET) { close(sockfd); events[i].data.fd = -1; } else std::cout&lt;&lt;&quot;readline error&quot;&lt;&lt;std::endl; } else if (n == 0) { close(sockfd); events[i].data.fd = -1; } line[n] = &apos;/0&apos;; cout &lt;&lt; &quot;read &quot; &lt;&lt; line &lt;&lt; endl; //设置用于写操作的文件描述符 ev.data.fd=sockfd; //设置用于注测的写操作事件 ev.events=EPOLLOUT|EPOLLET; //修改sockfd上要处理的事件为EPOLLOUT //epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev); } else if(events[i].events&amp;EPOLLOUT) // 如果有数据发送 { sockfd = events[i].data.fd; write(sockfd, line, n); //设置用于读操作的文件描述符 ev.data.fd=sockfd; //设置用于注测的读操作事件 ev.events=EPOLLIN|EPOLLET; //修改sockfd上要处理的事件为EPOLIN epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev); } } } return 0; }","categories":[{"name":"linux","slug":"linux","permalink":"jingg.me/categories/linux/"}],"tags":[{"name":"select","slug":"select","permalink":"jingg.me/tags/select/"},{"name":"poll","slug":"poll","permalink":"jingg.me/tags/poll/"}]},{"title":"Linux inotify机制","slug":"Linux_inotify","date":"2017-04-18T16:00:00.000Z","updated":"2017-04-27T03:15:46.237Z","comments":true,"path":"2017/04/19/Linux_inotify/","link":"","permalink":"jingg.me/2017/04/19/Linux_inotify/","excerpt":"Inotify 是一个 Linux 内核特性，它监控文件系统，并且及时向专门的应用程序发出相关的事件警告，比如删除、读、写和卸载操作等。您还可以跟踪活动的源头和目标等细节。使用 inotify 很简单：创建一个文件描述符fd，附加一个或多个监视器（一个监视器 是一个路径和一组事件，对应一个描述符wd），然后使用 read() 方法从描述符fd获取事件信息。 inotify，linux内核版本 &gt;= 2.6.13","text":"Inotify 是一个 Linux 内核特性，它监控文件系统，并且及时向专门的应用程序发出相关的事件警告，比如删除、读、写和卸载操作等。您还可以跟踪活动的源头和目标等细节。使用 inotify 很简单：创建一个文件描述符fd，附加一个或多个监视器（一个监视器 是一个路径和一组事件，对应一个描述符wd），然后使用 read() 方法从描述符fd获取事件信息。 inotify，linux内核版本 &gt;= 2.6.13 inotify C APIInotify 提供几个系统调用，它们可以构建各种各样的文件系统监控器： 1. fd = inotify_init(); / fd = inotify_init1(int flags);在内核中创建 inotify 子系统的一个实例instance，成功的话将返回一个文件描述符fd，失败则返回 -1。 就像其他系统调用一样，如果 inotify_init() 失败，请检查 errno 以获得诊断信息。 2. wd = inotify_add_watch(int fd, const char *pathname, uint32_t mask);用于添加监视器。每个监视器必须提供一个路径名和相关事件的列表（每个事件由一个常量指定，比如 IN_MODIFY）。 要监控多个事件，只需在事件之间使用逻辑操作符或&apos;|&apos;。 如果 inotify_add_watch() 成功，该调用会为已注册的监视器返回一个惟一的标识符wd; 否则，返回 -1。 使用这个标识符更改或删除监视器。 3. inotify_rm_watch(int fd, int wd);删除一个inotify实例中的监视器wd。 success return 0 ； error return -1。 删除操作将触发IN_IGNORED 事件给该wd 4. 读事件、关闭监视器、关闭inotify实例创建完inotify实例及添加监视器后，读inotify实例描述符fd，可以得到监控到的事件。 可以使用select pselect poll epoll 等避免阻塞 文件描述符上的由 inotify_init() 生成的通用 close() 删除所有活动监视器，并释放与 inotify 实例相关联的所有内存（这里也用到典型的引用计数警告。与实例相关联的所有文件描述符必须在监视器和 inotify 消耗的内存被释放之前关闭）。 5. 使用技巧/注意事项如果监视中的文件或目录被删除，它的监视器也会被自动删除（在删除事件发出之后）。 如果在已卸载的文件系统上监控文件或目录，监视器将在删除所有受影响的监视之前收到一个卸载事件。 将 IN_ONESHOT 标志添加到监视器标记中，设置一个一次性警告。警告在发送之后将被删除。 要修改一个事件，必须提供相同的路径名和不同的标记。新监视器将取代老监视器。 考虑到实用性，不可能耗尽任何一个 inotify 实例的监视器。然而，您可能会耗尽事件队列的空间，这取决于处理事件的频率。 队列溢出会引起 IN_Q_OVERFLOW 事件。 close() 方法毁坏 inotify 实例和所有相关联的监视器，并清空队列中的所有等待事件。 inotify 事件结构体及宏（详见inotify.h）1. inotify_event 结构体struct inotify_event { int wd; /* Watch descriptor */ 属于哪个监视器的事件，说白了就是wd对应的pathname的事件 uint32_t mask; /* Mask of events */ // IN_ACCESS IN_MODIFY IN_ATTRIB ... 中一个或多个的位或 uint32_t cookie; /* Unique cookie associating related events (for rename(2)) */ 用于关联两个事件 uint32_t len; /* Size of name field */ name长度 char name[]; /* Optional null-terminated name */ 事件关联的文件名，不包括路径 }; cookie字段使用场景: 当把一个文件从一个目录移动到另一个目录时，您可以使用 cookie 将两个事件绑在一起。仅当您监视源和目标目录时，inotify 才生成两个移动事件 — 分别针对源和目标 —，并通过设置 cookie 将它们绑定在一起。要监视一个移动操作，必须指定 IN_MOVED_FROM 或 IN_MOVED_TO，或使用简短的 IN_MOVE，它可以监视两个操作。使用 IN_MOVED_FROM 和 IN_MOVED_TO 来测试事件类型。 2. 事件类型/宏（详见inotify.h）IN_ACCESS 0x00000001 File was accessed (read) (*). IN_MODIFY 0x00000002 File was modified (*). IN_ATTRIB 0x00000004 Metadata changed, e.g., permissions, timestamps, extended attributes, link count (since Linux 2.6.25), UID, GID, etc. (*). IN_CLOSE_WRITE 0x00000008 File opened for writing was closed (*). IN_CLOSE_NOWRITE 0x00000010 File not opened for writing was closed (*). IN_OPEN 0x00000020 File was opened (*). IN_MOVED_FROM 0x00000040 Generated for the directory containing the old filename when a file is renamed (*). IN_MOVED_TO 0x00000080 Generated for the directory containing the new filename when a file is renamed (*). IN_CREATE 0x00000100 File/directory created in watched directory (*). IN_DELETE 0x00000200 File/directory deleted from watched directory (*). IN_DELETE_SELF 0x00000400 Watched file/directory was itself deleted. IN_MOVE_SELF 0x00000800 Watched file/directory was itself moved. IN_UNMOUNT 0x00002000 IN_Q_OVERFLOW 0x00004000 IN_IGNORED 0x00008000 复合型事件类型 IN_CLOSE (IN_CLOSE_WRITE | IN_CLOSE_NOWRITE) IN_MOVE (IN_MOVED_FROM | IN_MOVED_TO) IN_ALL_EVENTS (IN_ACCESS | IN_MODIFY | IN_ATTRIB | IN_CLOSE_WRITE | IN_CLOSE_NOWRITE | IN_OPEN | IN_MOVED_FROM | IN_MOVED_TO | IN_DELETE | IN_CREATE | IN_DELETE_SELF | IN_MOVE_SELF) IN_ONLYDIR 0x01000000 IN_DONT_FOLLOW 0x02000000 IN_MASK_ADD 0x20000000 IN_ISDIR 0x40000000 IN_ONESHOT 0x80000000 inotify 程序示例#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;errno.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/inotify.h&gt; #define EVENT_SIZE ( sizeof (struct inotify_event) ) #define BUF_LEN ( 1024 * ( EVENT_SIZE + 16 ) ) int main( int argc, char **argv ) { int length, i = 0; int fd; int wd; char buffer[BUF_LEN]; fd = inotify_init(); if ( fd &lt; 0 ) { perror( &quot;inotify_init&quot; ); } wd = inotify_add_watch( fd, &quot;/home/jim/test_inotity&quot;, IN_MODIFY | IN_CREATE | IN_DELETE ); length = read( fd, buffer, BUF_LEN ); if ( length &lt; 0 ) { perror( &quot;read&quot; ); } while ( i &lt; length ) { struct inotify_event *event = ( struct inotify_event * ) &amp;buffer[ i ]; if ( event-&gt;len ) { if ( event-&gt;mask &amp; IN_CREATE ) { if ( event-&gt;mask &amp; IN_ISDIR ) { printf( &quot;The directory %s was created.\\n&quot;, event-&gt;name ); } else { printf( &quot;The file %s was created.\\n&quot;, event-&gt;name ); } } else if ( event-&gt;mask &amp; IN_DELETE ) { if ( event-&gt;mask &amp; IN_ISDIR ) { printf( &quot;The directory %s was deleted.\\n&quot;, event-&gt;name ); } else { printf( &quot;The file %s was deleted.\\n&quot;, event-&gt;name ); } } else if ( event-&gt;mask &amp; IN_MODIFY ) { if ( event-&gt;mask &amp; IN_ISDIR ) { printf( &quot;The directory %s was modified.\\n&quot;, event-&gt;name ); } else { printf( &quot;The file %s was modified.\\n&quot;, event-&gt;name ); } } } i += EVENT_SIZE + event-&gt;len; } ( void ) inotify_rm_watch( fd, wd ); ( void ) close( fd ); exit( 0 ); } 运行测试 $ ./watcher &amp; $ cd $HOME/test_inotify $ touch a b c The file a was created. The file b was created. The file c was created. inotify 程序示例2#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/inotify.h&gt; struct wd_path { int wd; char *path; }; char * event_array[] = { &quot;File was accessed&quot;, &quot;File was modified&quot;, &quot;File attributes were changed&quot;, &quot;writtable file closed&quot;, &quot;Unwrittable file closed&quot;, &quot;File was opened&quot;, &quot;File was moved from X&quot;, &quot;File was moved to Y&quot;, &quot;Subfile was created&quot;, &quot;Subfile was deleted&quot;, &quot;Self was deleted&quot;, &quot;Self was moved&quot;, &quot;&quot;, &quot;Backing fs was unmounted&quot;, &quot;Event queued overflowed&quot;, &quot;File was ignored&quot; }; #define EVENT_NUM 16 int main(int argc,char *argv[]) { int fd,wd,len,tmp_len,i; char buffer[1024],*offset,target[1024]; struct wd_path *wd_array; struct inotify_event *event; wd_array=(struct wd_path*)malloc((argc-1)*sizeof(struct wd_path)); fd=inotify_init(); if(-1==fd) { printf(&quot;failed to init inotifyn&quot;); return 0; } printf(&quot;argc = %d \\n&quot;, argc); if (argc &lt; 2) { return -1; } printf(&quot;argv[0] = %d \\n&quot;, argv[0]); printf(&quot;argv[1] = %d \\n&quot;, argv[1]); for(i=0;i&lt;argc-1;i++) { wd_array[i].path = argv[i+1]; wd=inotify_add_watch(fd,wd_array[i].path,IN_ALL_EVENTS); wd_array[i].wd=wd; } memset(buffer,0,1024); while(len=read(fd,buffer,1024)) { offset=buffer; event=(struct inotify_event*)buffer; while(((char *)event-buffer)&lt;len) { for(i=0;i&lt;argc-1;i++) { if(event-&gt;wd==wd_array[i].wd) { memset(target,0,1024); strcpy(target,wd_array[i].path); strcat(target,&quot;/&quot;); strcat(target,event-&gt;name); printf(&quot;nnntarget:%s:n&quot;,target); } } for(i=0;i&lt;EVENT_NUM;i++) { if(event-&gt;mask&amp;(1&lt;&lt;i)) printf(&quot; event:%sn&quot;,event_array[i]); } tmp_len=sizeof(struct inotify_event)+event-&gt;len; event=(struct inotify_event*)(offset+tmp_len); offset+=tmp_len; } } return 1; }","categories":[{"name":"linux","slug":"linux","permalink":"jingg.me/categories/linux/"}],"tags":[{"name":"inotify","slug":"inotify","permalink":"jingg.me/tags/inotify/"}]},{"title":"杂项","slug":"Other_undefined","date":"2017-04-13T11:55:33.000Z","updated":"2017-05-18T06:41:48.458Z","comments":true,"path":"2017/04/13/Other_undefined/","link":"","permalink":"jingg.me/2017/04/13/Other_undefined/","excerpt":"","text":"Google Host文件https://raw.githubusercontent.com/racaljk/hosts/master/hosts Ubuntu x64系统安装32位系统兼容库sudo apt-get install lib32z1 lib32ncurses5 lib32bz2-1.0 sudo apt-get install gawksudo apt-get install libstdc++6sudo apt-get install lib32stdc++6 or sudo apt-get install libc6-i386 利用已有的Doxyfile来生成文档doxygen Doxyfile 护眼色R/B/G:CBE7CE 203 231 206色调84 饱和度88 亮度204","categories":[{"name":"杂项","slug":"杂项","permalink":"jingg.me/categories/杂项/"}],"tags":[]},{"title":"Markdown&MarkdownPad编辑器","slug":"Other_MarkdownGuide","date":"2017-04-13T11:55:33.000Z","updated":"2017-04-27T03:16:17.232Z","comments":true,"path":"2017/04/13/Other_MarkdownGuide/","link":"","permalink":"jingg.me/2017/04/13/Other_MarkdownGuide/","excerpt":"MarkdownPad编辑器添加表格的扩展开启表格特性支持： 工具 ==&gt; 选项 ==&gt; Markdown ==&gt; Markdown处理器 改为 &quot;Markdown(扩展)&quot;or&quot;GitHub风格Markdown&quot;即可。 表格语法: :---- 左对齐,默认左对齐 :---: 居中 ----: 右对齐 每列的宽度是根据对应列里最长的文本来决定 在设置的过程中要注册markdownpad2邮箱： Soar360@live.com 授权秘钥： GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2 M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6 Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5C Cx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr 0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ== Markdown编辑器快捷键· 加粗 Ctrl + B · 斜体 Ctrl + I · 引用 Ctrl + Q · 插入链接 Ctrl + L · 插入代码 Ctrl + K · 插入图片 Ctrl + G · 提升标题 Ctrl + H · 有序列表 Ctrl + O · 无序列表 Ctrl + U · 横线 Ctrl + R · 撤销 Ctrl + Z · 重做 Ctrl + Y","text":"MarkdownPad编辑器添加表格的扩展开启表格特性支持： 工具 ==&gt; 选项 ==&gt; Markdown ==&gt; Markdown处理器 改为 &quot;Markdown(扩展)&quot;or&quot;GitHub风格Markdown&quot;即可。 表格语法: :---- 左对齐,默认左对齐 :---: 居中 ----: 右对齐 每列的宽度是根据对应列里最长的文本来决定 在设置的过程中要注册markdownpad2邮箱： Soar360@live.com 授权秘钥： GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2 M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6 Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5C Cx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr 0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ== Markdown编辑器快捷键· 加粗 Ctrl + B · 斜体 Ctrl + I · 引用 Ctrl + Q · 插入链接 Ctrl + L · 插入代码 Ctrl + K · 插入图片 Ctrl + G · 提升标题 Ctrl + H · 有序列表 Ctrl + O · 无序列表 Ctrl + U · 横线 Ctrl + R · 撤销 Ctrl + Z · 重做 Ctrl + Y Markdown语法参考加粗和倾斜 链接和Email 不解析内容处理方法或者 图片 标题Setext-style: atx-style (closing #’s are optional): 无段落有序列表： 有段落无序列表: 嵌套使用列表: 引用: 代码嵌入: 代码块:(不带行号)Indent every line of a code block by at least 4 spaces or 1 tab. 水平线三个破折号或者星号","categories":[{"name":"杂项","slug":"杂项","permalink":"jingg.me/categories/杂项/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"jingg.me/tags/Markdown/"}]},{"title":"移植开源程序到Android中","slug":"Android_porting_opensourcesoft","date":"2017-04-13T04:22:33.000Z","updated":"2017-05-18T08:02:24.795Z","comments":true,"path":"2017/04/13/Android_porting_opensourcesoft/","link":"","permalink":"jingg.me/2017/04/13/Android_porting_opensourcesoft/","excerpt":"","text":"安装独立的交叉编译链： 下载ndk 包， 解压 cd build/tools ./make-standalone-toolchain.sh –install-dir=/opt/ndk-standalone-10-arm –platform=android-22 –toolchain=arm-linux-androideabi-4.8 注1 老的ndk才需要使用–ndk-dir=../../， ndk10使用 –platform=android-L， ndk13使用 –platform=android-22 注2：需要将/opt/ndk-standalone-10-arm/bin 添加到PATH 路径中 编译libusb-1.0.so库 需要略微添加下timeval 等结构体 等 #define TIMESPEC_TO_TIMEVAL(tv, ts) \\ { \\ (tv)-&gt;tv_sec = (ts)-&gt;tv_sec; \\ (tv)-&gt;tv_usec = (ts)-&gt;tv_nsec / 1000; \\ } while (0) 方法1 使用原始编译框架，交叉编译 ./configure --build=x86_64-linux-gnu --host=arm-linux-androideabi --target=arm-linux-androideabi --prefix=/opt/libusb-1.0.9/ make 注：--prefix 编译生成库的路径，也叫安装路径，使用绝对路径 方法2 使用Android ndk ndk-build进行编译（需要编译Application.mk Android.mk 等文件） 【推荐】 ndk-build clean ndk-build 方法3 copy ti-sdk-am335x-evm-08.00.00.00 中的libusb-1.0.so 库 编译libssl.so libcrypto.so 库 （Android集成的openssl） 方式1： 使用Android 中openssl 编译 【推荐】 需要配置openssl.config和openssl.trusty.config 去掉no-dtls1 宏，否则将不支持DTLS特性 （即通过 arm-linux-androideabi- nm ../../out/target/product/rk3368_box/obj/SHARED_LIBRARIES/libssl_intermediates/LINKED/libssl.so | grep DTLSv1_server_method 查询不到函数符号） ./import_openssl.sh import &lt;path-to-openssl-1.0.1j.tar.gz&gt; //重新按照该openssl.config生成编译配置文件 mm -B 方式2： （下载开源openssl源码编译， 参见openssl-1.1.0c/Configurations/10-main.conf 介绍，此方法用户编译原生openssl库） export ANDROID_NDK=/opt/android-ndk-r13b export CROSS_SYSROOT=/opt/android-ndk-r13b/platforms/android-22/arch-arm export CROSS_COMPILE=arm-linux-androideabi- //等同于选项--cross-compile-prefix ./Configure android-armeabi --openssldir=/opt/openssl-1.1.0c/out/config --prefix=/opt/openssl-1.1.0c/out make install make clean &amp;&amp; make distclean export ANDROID_NDK=/opt/android-ndk-r10b export CROSS_SYSROOT=$ANDROID_NDK/platforms/android-L/arch-arm export CROSS_COMPILE=arm-linux-androideabi- export OPENSSL_HOME=/work2/mygo/src/bitbucket.org/portus/smartgateway/NodePro/Zwave/lib/openssl ./Configure android-armeabi no-threads --openssldir=$OPENSSL_HOME/out/config --prefix=$OPENSSL_HOME/out make make install bridge-utils （主要是需要brctl工具） ./configure –build=x86_64-linux-gnu –host=arm-linux-androideabi –target=arm-linux-androideabi –prefix=/opt/bridge-utils-1.4/out/ make clean make make install 编译zipgateway （基于arm Android目标运行环境） ./configure –build=x86_64-linux-gnu –host=arm-linux-androideabi –target=arm-linux-androideabi make CC=/opt/ndk-standalone-10-arm/bin/arm-linux-androideabi-gcc beaglebone 或者 make CROSS=”arm-linux-androideabi-“ beaglebone 【推荐】 其他android ndk编译开源linux软件方法NDK=/opt/android-ndk-r10bSYSROOT=$NDK/platforms/android-L/arch-armCC=”$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/bin/arm-linux-androideabi-gcc –sysroot=$SYSROOT”$CC –version cmake -DOPENSSL_ROOT_DIR=/work/project/geekbox/Lollipop/external/openssl/include -DOPENSSL_LIBRARIES=/work/project/geekbox/Lollipop/out/target/product/rk3368_box/system/lib./configure","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"porting","slug":"porting","permalink":"jingg.me/tags/porting/"}]},{"title":"Android支持库(转)","slug":"Android_Support.xxx","date":"2017-04-12T23:42:30.000Z","updated":"2017-04-27T03:17:11.811Z","comments":true,"path":"2017/04/13/Android_Support.xxx/","link":"","permalink":"jingg.me/2017/04/13/Android_Support.xxx/","excerpt":"随着 Android 5.0 Lollipop 的发布，Android 又为我们提供了更多的支持包，但是我相信大部分开发者都同我之前一样不知道这些包里究竟有些什么东西，我们应该在什么时候使用它。现在，我们就来逐个看看每一个版本的 Support 包中所拥有的东西，让用到他的时候不再迷茫。 首先，你需要了解每一个 Support 包版本后缀 vX 所代表的含义。当然我相信来看博客的诸位都一定知道 Android 对于每一个版本都有一个版本号，例如2.1是7，4.0是14，5.0是21。而这里，v 之后的数字，就代表着他能够被使用的最低版本等级，之所以无法在更低版本进行使用的原因，是因为随着版本的升级，在新版本中有很多之前不支持的特性或者 API，因此如果你在老版本中使用了这些支持包，就可能会导致应用崩溃。","text":"随着 Android 5.0 Lollipop 的发布，Android 又为我们提供了更多的支持包，但是我相信大部分开发者都同我之前一样不知道这些包里究竟有些什么东西，我们应该在什么时候使用它。现在，我们就来逐个看看每一个版本的 Support 包中所拥有的东西，让用到他的时候不再迷茫。 首先，你需要了解每一个 Support 包版本后缀 vX 所代表的含义。当然我相信来看博客的诸位都一定知道 Android 对于每一个版本都有一个版本号，例如2.1是7，4.0是14，5.0是21。而这里，v 之后的数字，就代表着他能够被使用的最低版本等级，之所以无法在更低版本进行使用的原因，是因为随着版本的升级，在新版本中有很多之前不支持的特性或者 API，因此如果你在老版本中使用了这些支持包，就可能会导致应用崩溃。 现在，我们从头开始逐个浏览目前所支持的 support 包: 1. support-v4support-v4包算是 Android 最低等级的支持包。所谓的 v4,代表着它最低支持 Android1.6(API Level4)，这个版本算得上是一个真正意义上比较成熟的 Android版本，更何况现在我们写应用的时候一般都只最低支持到 Android 2.x 系统，对于1.x 的系统基本已经已经完全抛弃了，因此你可已经他作为最基本的系统组件使用。 在 support-v4包中，它所拥有的类还是很多的，主要包含了对应用组件的支持，用户交互体验的一些工具类，一些数据网络方面的工具类，相面我们将详细来看看它里面具体的一些类。 1. 系统组件部分 Fragment:其实 Fragment 是直到 Android3.0才正式进入 Android 框架体系的，但是 Android 为了低版本的兼容，因此他帮我们在低版本也适配了 Fragment 框架 NotificationCompat:这是通知栏的一些适配，可以帮助你在低版本的通知栏显示更加丰富的信息 LocalBroadcastManager:这个是用于本地广播通知的，当你希望发送的通知只被本应用接收时，你就应该使用它 2. 用户界面交互部分 ViewPager，这个相信我不用怎么说了，他主要用于帮助我们进行界面间的滑动交互 PagerTitleStrip,PagerTabStrip 这两个算是 ViewPager 的帮助类吧，他们的作用是进行 Tab 栏的切换辅助显示 DrawerLayout，主要用于侧滑栏的实现 SlidingPaneLayout,这个类也是用于侧滑栏的实现，和 DrawerLayout 不同的是，DrawerLayout 侧滑栏出来的时候，默认是覆盖在当前页面上，而 SlidingPaneLayout 则是会将当前页面移走。 3. Accessbility访问的帮助类 ExploreByTouchHelper，帮助自定义 View 实现 Accessibility 的工具类 AccessbilityEventCompat, AccessbilityNodeInfoCompat, AccessbilityNodeProviderCompat, AccessbilityDelegateCompat，这几个都是用作 Accessibility 功能适配的类 4. 数据访问帮助类 Loader，主要用于异步加载数据 FileProvider，提供应用间的文件分享功能 2. support-v71.Appcompat 这个包的主要作用是为了在低版本实现 Android 的 Holo 风格界面而引入的，与之类似的有一个开源项目叫做 SherlockActionbar 2.CardView 卡片布局是最近在 android5.0发布的时候才引入的新包，在我看来，他主要效果是让应用进行卡片花显示 3.GridLayout 网格布局能够帮助你将整个布局按照一格两格的格子形式进行排列 4.MediaRouter 这个布局主要是用来支持 GoogleCast 的，主要用于进行设备间的音频，视频交换显示 5.Palette 这个包也是最新出来的，他的作用是帮助 Android 实现他的 MaterialDesign，让你的 Actionbar 能够根据界面进行对应的颜色改变 7.RecyclerView 这个包同样也是刚出来的，他的作用是替换 ListView 和 GridView，但是可惜是没有实现 OnItemClick 这些接口，你需要自己处理它 3. support-v8support-v8中其实只有一格特性，就是用来渲染脚本 4. support-v13这个包的作用主要是为 Android3.2级以上的系统提供更多地 Framgnet 特性支持，使用它的原因在于，android-support-v4包中虽然也对 Fragment 做了支持，由于要兼容低版本，导致他是自行实现的 Fragment 效果，在高版本的 Fragment 的一些特性丢失了，而对于 v13以上的 sdk 版本，我们可以使用更加有效，特性更多的代码 5. support-v17这个包得主要作用是用于支持电视设备，并为电视设备提供了很多组件 例如下面的: BrowseFragment， DetailFragment， PlaybasckOverlayFragment， SearchFragment 但是原谅我没有做过 Android TV 开发，我也不知道他们的用处是什么，如果真的想要查看，请去官网看看吧 https://developer.android.com/topic/libraries/support-library/index.html 转自http://www.2cto.com/kf/201411/350928.html 附：API与Android版本对应表：Code name Version API level Nougat 7.1 API level 25 Nougat 7.0 API level 24 Marshmallow 6.0 API level 23 Lollipop 5.1 API level 22 Lollipop 5.0 API level 21, NDK 10 KitKat 4.4 - 4.4.4 API level 19 Jelly Bean 4.3.x API level 18 Jelly Bean 4.2.x API level 17 Jelly Bean 4.1.x API level 16 Ice Cream Sandwich 4.0.3 - 4.0.4 API level 15, NDK 8 Ice Cream Sandwich 4.0.1 - 4.0.2 API level 14, NDK 7 Honeycomb 3.2.x API level 13 Honeycomb 3.1 API level 12, NDK 6 Honeycomb 3.0 API level 11 Gingerbread 2.3.3 - 2.3.7 API level 10 Gingerbread 2.3 - 2.3.2 API level 9, NDK 5 Froyo 2.2.x API level 8, NDK 4 Eclair 2.1 API level 7, NDK 3 Eclair 2.0.1 API level 6 Eclair 2.0 API level 5 Donut 1.6 API level 4, NDK 2 Cupcake 1.5 API level 3, NDK 1 (no code name) 1.1 API level 2 (no code name) 1.0 API level 1","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"Android Support","slug":"Android-Support","permalink":"jingg.me/tags/Android-Support/"}]},{"title":"Android APP加密和签名","slug":"Android_encryption_signature","date":"2017-04-12T04:22:33.000Z","updated":"2017-05-18T06:35:42.001Z","comments":true,"path":"2017/04/12/Android_encryption_signature/","link":"","permalink":"jingg.me/2017/04/12/Android_encryption_signature/","excerpt":"","text":"基本概念公钥加密、私钥解密是密送，保证消息即使公开也只有私钥持有者能读懂。私钥加密、公钥解密是签名，保证消息来源是私钥持有者。 签名的作用Android系统不会安装没有进行签名的应用程序 给apk签名可以带来以下好处： 1. 应用程序升级 2. 应用程序模块化：Android系统可以允许同一个证书签名的多个应用程序在一个进程里运行 3. 代码或者数据共享：Android提供了基于签名的权限机制，那么一个应用程序就可以为另一个以 相同证书签名的应用程序公开自己的功能。 Android标准签名build/target/product/security目录中有四组默认签名供Android.mk在编译APK使用：1、testkey/releasekey：普通APK，默认情况下使用。2、platform：该APK完成一些系统的核心功能。经过对系统中存在的文件夹的访问测试，这种方式编译出来的APK所在进程的 UID为system。3、shared：该APK需要和home/contacts进程共享数据。4、media：该APK是media/download系统中的一环。 生成platform media 等签名文件/work/aurora/development/tools/make_key：sh make_key releasekey ‘/C=CN/ST=HuBei/L=WuHan/O=Company/OU=Department/CN=YourName/emailAddress=YourE-mailAddress’ 第三方生成签名使用/work/sign下的工具生成系统签名jks文件：（供AS 或者 eclipse 使用）./keytool-importkeypair -k lt_system_me.jks -p liantong -pk8 platform.pk8 -cert platform.x509.pem -alias lt_system 单独给APK签名：out/host/linux-x86/framework/signapk.jarbuild/target/product/security/*也可以从网上下载。使用方法，以platform为例：java -jar ./signapk.jar platform.x509.pem platform.pk8 input.apk output.apk (platform.x509.pem私钥 platform.pk8公钥 在build/target/product/security获取) APP中签名后生成文件APP中META-INF/CERT.RSA 文件数字签名以及一个数字证书机构密钥标识符AuthorityKeyIdentifier基本限制BasicConstraints主体密钥标识符SubjectKeyIdentifier Owner: CN=ZhaoXin, OU=ZhaoXin, O=ZhaoXin, L=Shanghai, ST=Shanghai, C=CNIssuer: CN=ZhaoXin, OU=ZhaoXin, O=ZhaoXin, L=Shanghai, ST=Shanghai, C=CNSerial number: 8e8825ec8c2efe44Valid from: Tue Apr 22 16:58:39 CST 2014 until: Sat Sep 07 16:58:39 CST 2041Certificate fingerprints: MD5: 55:16:F4:38:BD:49:BE:38:47:03:9B:B6:CA:AE:33:AD SHA1: 43:E0:FE:6E:76:BF:53:62:84:15:1B:BD:17:03:67:F1:56:E0:BB:18 SHA256: 0B:6D:62:97:01:A8:5A:63:27:50:D1:EC:AD:47:59:B9:83:3E:0D:92:A5:E8:FE:95:9D:F0:7E:F2:DC:30:75:05 Signature algorithm name: SHA1withRSA Version: 3 Extensions: #1: ObjectId: 2.5.29.35 Criticality=falseAuthorityKeyIdentifier [KeyIdentifier [0000: CF FF A6 88 A3 A8 ED 04 C1 60 2F FD 96 EC BC E9 ………`/…..0010: D3 B4 5F AD .._.]] #2: ObjectId: 2.5.29.19 Criticality=falseBasicConstraints:[ CA:true PathLen:2147483647] #3: ObjectId: 2.5.29.14 Criticality=falseSubjectKeyIdentifier [KeyIdentifier [0000: CF FF A6 88 A3 A8 ED 04 C1 60 2F FD 96 EC BC E9 ………`/…..0010: D3 B4 5F AD .._.]] 查看签名查看签名keytool -printcert -file META-INF/CERT.RSA 查看keystone信息：keytool -list -keystore debug.keystore 其他反编译./apktool d[ecode] xxx.apk -o AndroidStudio中签名配置???app 未知源检测原理（不同系统不一样吗，不同应用市场是不是也不一样？）Y:\\aurora\\development\\samples\\Home sample-Launcher系统Launcher启动流程分析 signingConfigs { release { keyAlias &apos;lt_system&apos; keyPassword &apos;liantong&apos; storeFile file(&apos;D:/25264/Android/Project/SGTest/signedAPK/lt_system.jks&apos;) storePassword &apos;liantong&apos; } release2 { keyAlias &apos;lt_system&apos; keyPassword &apos;liantong&apos; storeFile file(&apos;D:/25264/Android/Project/SGTest/signedAPK/lt_system_me.jks&apos;) storePassword &apos;liantong&apos; } } SeeAlso《APK 反编译及签名工具》","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"加密","slug":"加密","permalink":"jingg.me/tags/加密/"},{"name":"签名","slug":"签名","permalink":"jingg.me/tags/签名/"}]},{"title":"Android系统升级、烧录、Recovery、OTA","slug":"Android_update_img","date":"2017-04-12T04:22:33.000Z","updated":"2017-05-02T04:04:09.138Z","comments":true,"path":"2017/04/12/Android_update_img/","link":"","permalink":"jingg.me/2017/04/12/Android_update_img/","excerpt":"Recovery:http://www.tuicool.com/articles/Q7ZBbuhttp://blog.csdn.net/fengying765/article/details/38301895 待续…","text":"Recovery:http://www.tuicool.com/articles/Q7ZBbuhttp://blog.csdn.net/fengying765/article/details/38301895 待续…","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"update","slug":"update","permalink":"jingg.me/tags/update/"},{"name":"recovery","slug":"recovery","permalink":"jingg.me/tags/recovery/"},{"name":"OTA","slug":"OTA","permalink":"jingg.me/tags/OTA/"}]},{"title":"Android.mk","slug":"Android_mk","date":"2017-04-12T04:22:33.000Z","updated":"2017-04-27T03:22:20.769Z","comments":true,"path":"2017/04/12/Android_mk/","link":"","permalink":"jingg.me/2017/04/12/Android_mk/","excerpt":"Android.mk待续。。。","text":"Android.mk待续。。。","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"Android.mk","slug":"Android-mk","permalink":"jingg.me/tags/Android-mk/"},{"name":"Makefile","slug":"Makefile","permalink":"jingg.me/tags/Makefile/"},{"name":"build","slug":"build","permalink":"jingg.me/tags/build/"}]},{"title":"Input系统——Linux 输入子系统","slug":"InputSystem002_LinuxInputSubSystem","date":"2017-04-12T04:22:33.000Z","updated":"2017-04-26T13:01:57.739Z","comments":true,"path":"2017/04/12/InputSystem002_LinuxInputSubSystem/","link":"","permalink":"jingg.me/2017/04/12/InputSystem002_LinuxInputSubSystem/","excerpt":"待整理完善。。。 1. struct input_devstruct input_dev { const char *name; //名字 const char *phys; const char *uniq; struct input_id id; unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)]; unsigned long evbit[BITS_TO_LONGS(EV_CNT)]; // 设备所支持的事件类型 unsigned long keybit[BITS_TO_LONGS(KEY_CNT)]; // 按键类型 unsigned long relbit[BITS_TO_LONGS(REL_CNT)]; // 相对值类型 unsigned long absbit[BITS_TO_LONGS(ABS_CNT)]; // 绝对值类型 unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)]; // 混合类型 unsigned long ledbit[BITS_TO_LONGS(LED_CNT)]; // LED类型 unsigned long sndbit[BITS_TO_LONGS(SND_CNT)]; // 声音类型 unsigned long ffbit[BITS_TO_LONGS(FF_CNT)]; // 力反馈 unsigned long swbit[BITS_TO_LONGS(SW_CNT)]; // 开关类型???","text":"待整理完善。。。 1. struct input_devstruct input_dev { const char *name; //名字 const char *phys; const char *uniq; struct input_id id; unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)]; unsigned long evbit[BITS_TO_LONGS(EV_CNT)]; // 设备所支持的事件类型 unsigned long keybit[BITS_TO_LONGS(KEY_CNT)]; // 按键类型 unsigned long relbit[BITS_TO_LONGS(REL_CNT)]; // 相对值类型 unsigned long absbit[BITS_TO_LONGS(ABS_CNT)]; // 绝对值类型 unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)]; // 混合类型 unsigned long ledbit[BITS_TO_LONGS(LED_CNT)]; // LED类型 unsigned long sndbit[BITS_TO_LONGS(SND_CNT)]; // 声音类型 unsigned long ffbit[BITS_TO_LONGS(FF_CNT)]; // 力反馈 unsigned long swbit[BITS_TO_LONGS(SW_CNT)]; // 开关类型??? unsigned int hint_events_per_packet; unsigned int keycodemax; unsigned int keycodesize; void *keycode; int (*setkeycode)(struct input_dev *dev, const struct input_keymap_entry *ke, unsigned int *old_keycode); int (*getkeycode)(struct input_dev *dev, struct input_keymap_entry *ke); struct ff_device *ff; unsigned int repeat_key; struct timer_list timer; int rep[REP_CNT]; struct input_mt *mt; struct input_absinfo *absinfo; unsigned long key[BITS_TO_LONGS(KEY_CNT)]; unsigned long led[BITS_TO_LONGS(LED_CNT)]; unsigned long snd[BITS_TO_LONGS(SND_CNT)]; unsigned long sw[BITS_TO_LONGS(SW_CNT)]; int (*open)(struct input_dev *dev); void (*close)(struct input_dev *dev); int (*flush)(struct input_dev *dev, struct file *file); int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value); struct input_handle __rcu *grab; spinlock_t event_lock; struct mutex mutex; unsigned int users; bool going_away; struct device dev; struct list_head h_list; struct list_head node; unsigned int num_vals; unsigned int max_vals; struct input_value *vals; bool devres_managed; }; 2. 注册/注销函数int input_register_device搜索(struct input_dev *dev) void input_unregister_device(struct input_dev *dev) 3. 设备所支持的事件类型有EV_KEY 按键 EV_REL 相对坐标 EV_ABS绝对坐标 EV_MSC 其它 EV_LED LED EV_SND 声音 EV_FF 力反馈 EV_SW 开关??? 4. 操作函数set_bit(EV_KEY, button_dev.evbit) // 设置支持的事件 void input_report_key(struct input_dev *dev,unsigned int code, int value) // 在中断过程中中，内核层使用input_report_key等函数向用户空间报告，然后应用程序读取状态。 void input_report_rel(struct input_dev *dev,unsigned int code, int value) // .. void input_report_abs(struct input_dev *dev,unsigned int code, int value) // .. input_sync() // 用于事件同步，它告知事件的接收者：驱动已经发出了一个完整的报告。 5. 事件代码EV_KEY 事件代码 代码值0~127为键盘上的按键代码，0x110~0x116为鼠标上按键代码，其中0x110(BTN_LEFT)为鼠标左键，0x111(BTN_RIGHT)为鼠标右键,0x112(BTN_ MIDDLE)为鼠标中键。其它代码含义请参看include/linux/input.h文件 EV_KEY 事件值 按键按下时值为1,松开时值为0 evdev","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"input","slug":"input","permalink":"jingg.me/tags/input/"},{"name":"input系统","slug":"input系统","permalink":"jingg.me/tags/input系统/"},{"name":"event","slug":"event","permalink":"jingg.me/tags/event/"}]},{"title":"Input系统——Linux驱动","slug":"InputSystem001_LinuxInputDriver","date":"2017-04-12T04:22:33.000Z","updated":"2017-04-27T03:20:52.925Z","comments":true,"path":"2017/04/12/InputSystem001_LinuxInputDriver/","link":"","permalink":"jingg.me/2017/04/12/InputSystem001_LinuxInputDriver/","excerpt":"待续…","text":"待续…","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"input","slug":"input","permalink":"jingg.me/tags/input/"},{"name":"input系统","slug":"input系统","permalink":"jingg.me/tags/input系统/"},{"name":"event","slug":"event","permalink":"jingg.me/tags/event/"}]},{"title":"Android device.mk","slug":"Android_device.mk","date":"2017-04-12T04:22:33.000Z","updated":"2017-05-18T06:37:46.887Z","comments":true,"path":"2017/04/12/Android_device.mk/","link":"","permalink":"jingg.me/2017/04/12/Android_device.mk/","excerpt":"","text":"PRODUCT_COPY_FILES通过android提供的PRODUCT_COPY_FILES这个变量来自动拷贝，只需要给此变量赋值。 //这里需要注意一点， PRODUCT_COPY_FILES 不能在 Android.mk 中使用 添加新的Copy 项！","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"device.mk","slug":"device-mk","permalink":"jingg.me/tags/device-mk/"}]},{"title":"Input系统——Android Input系统","slug":"InputSystem003_AndroidInputSystem","date":"2017-04-12T04:22:33.000Z","updated":"2017-05-02T06:59:19.059Z","comments":true,"path":"2017/04/12/InputSystem003_AndroidInputSystem/","link":"","permalink":"jingg.me/2017/04/12/InputSystem003_AndroidInputSystem/","excerpt":"Input系统结构解析AndroidInput系统——JNI NativeInputManager InputManger InputReader","text":"Input系统结构解析AndroidInput系统——JNI NativeInputManager InputManger InputReader AndroidInput系统——InputReader AndroidInput系统——InputDispatcher AndroidInput系统——EventHub Android Input系统相关结构体1. input_device_idstruct input_device_id { kernel_ulong_t flags; __u16 bustype; // BUS_USB BUS_BLUETOOTH __u16 vendor; __u16 product; __u16 version; kernel_ulong_t evbit[INPUT_DEVICE_ID_EV_MAX / BITS_PER_LONG + 1]; kernel_ulong_t keybit[INPUT_DEVICE_ID_KEY_MAX / BITS_PER_LONG + 1]; kernel_ulong_t relbit[INPUT_DEVICE_ID_REL_MAX / BITS_PER_LONG + 1]; kernel_ulong_t absbit[INPUT_DEVICE_ID_ABS_MAX / BITS_PER_LONG + 1]; kernel_ulong_t mscbit[INPUT_DEVICE_ID_MSC_MAX / BITS_PER_LONG + 1]; kernel_ulong_t ledbit[INPUT_DEVICE_ID_LED_MAX / BITS_PER_LONG + 1]; kernel_ulong_t sndbit[INPUT_DEVICE_ID_SND_MAX / BITS_PER_LONG + 1]; kernel_ulong_t ffbit[INPUT_DEVICE_ID_FF_MAX / BITS_PER_LONG + 1]; kernel_ulong_t swbit[INPUT_DEVICE_ID_SW_MAX / BITS_PER_LONG + 1]; kernel_ulong_t driver_info; }; 2. input_event (input.h)struct input_event { struct timeval time; __u16 type; __u16 code; __s32 value; }; 3. RawEvent (EventHub.h)struct RawEvent { nsecs_t when; time int32_t deviceId; ID = 1 ID = 0 int32_t type; EV_REL= 0x02 EV_SYN = 0x00 int32_t code; REL_X = 0x00 SYN_REPORT = 0 int32_t value; Value = 0x01 Value = 0x00 }; 调试相关查看event注册设备shell@rk3368_32:/dev/input # cat /proc/bus/input/devices I: Bus=0000 Vendor=0000 Product=0003 Version=206a N: Name=&quot;synaptics_dsx&quot; P: Phys=synaptics_dsx/touch_input S: Sysfs=/devices/ff140000.i2c/i2c-2/2-0020/input/input0 U: Uniq= H: Handlers=event0 cpufreq ddr_freq B: PROP=2 B: EV=b B: KEY=420 0 0 0 0 0 8000 0 0 0 0 B: ABS=2638000 3 I: Bus=0019 Vendor=0000 Product=0000 Version=0000 N: Name=&quot;rotary.35&quot; P: Phys= S: Sysfs=/devices/rotary.35/input/input1 U: Uniq= H: Handlers=event1 B: PROP=0 B: EV=5 B: REL=1 I: Bus=0019 Vendor=0001 Product=0001 Version=0100 N: Name=&quot;rk29-keypad&quot; P: Phys=gpio-keys/input0 S: Sysfs=/devices/ff100000.adc/key.38/input/input2 U: Uniq= H: Handlers=event2 ddr_freq keychord B: PROP=0 B: EV=3 B: KEY=8000 100000 0 0 0 I: Bus=0000 Vendor=0000 Product=0000 Version=0000 N: Name=&quot;temperature&quot; P: Phys= S: Sysfs=/devices/ff160000.i2c/i2c-4/4-005b/input/input3 U: Uniq= H: Handlers=event3 B: PROP=0 B: EV=9 B: ABS=40 查看Handler个数shell@rk3368_box:/dev/input # ls -l crw-rw---- root input 13, 64 2017-04-12 11:15 event0 crw-rw---- root input 13, 65 2017-04-12 11:15 event1 crw-rw---- root input 13, 66 2017-04-14 08:12 event2 crw-rw---- root input 13, 67 2017-04-14 08:12 event3 cat event0 cat event1 getevent 获取事件# getevent -h Usage: getevent [-t] [-n] [-s switchmask] [-S] [-v [mask]] [-d] [-p] [-i] [-l] [-q] [-c count] [-r] [device] -t: show time stamps -n: don&apos;t print newlines -s: print switch states for given bits -S: print all switch states -v: verbosity mask (errs=1, dev=2, name=4, info=8, vers=16, pos. events=32, props=64) -d: show HID descriptor, if available -p: show possible events (errs, dev, name, pos. events) -i: show all device info and possible events -l: label event types and names in plain text -q: quiet (clear verbosity mask) -c: print given number of events then exit -r: print rate events are received 常用命令组合： getevent -p // see all of the keys and axes a device reports getevent -ip // get more information, including HID mapping tables and debugging information getevent -lp // option to display textual labels for all event codes getevent -lp getevent -r -q 监控设备的sendevent事件 getevent -p add device 1: /dev/input/event3 name: &quot;temperature&quot; add device 2: /dev/input/event1 name: &quot;rotary.35&quot; add device 3: /dev/input/event0 name: &quot;synaptics_dsx&quot; add device 4: /dev/input/event2 name: &quot;rk29-keypad&quot; /dev/input/event1: 0002 0000 00000001 ID=1 EV_REL=0x02 REL_X = 0x00 Value = 0x01 /dev/input/event1: 0000 0000 00000000 ID=0 EV_SYN 0x00 SYN_REPORT = 0 Value = 0x00 /dev/input/event1: 0002 0000 00000001 /dev/input/event1: 0000 0000 00000000 /dev/input/event1: 0002 0000 00000001 /dev/input/event1: 0000 0000 00000000 /dev/input/event1: 0002 0000 ffffffff EV_REL=0x02 REL_X = 0x00 Value = 0xffffffffff /dev/input/event1: 0000 0000 00000000 /dev/input/event1: 0002 0000 ffffffff dumpsys dumpsys input： To dump the input system’s state (Event Hub State,Input Reader State,Input Dispatcher State)","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"input","slug":"input","permalink":"jingg.me/tags/input/"},{"name":"input系统","slug":"input系统","permalink":"jingg.me/tags/input系统/"},{"name":"event","slug":"event","permalink":"jingg.me/tags/event/"}]},{"title":"Android Framework层 Sensor 框架","slug":"Android_Sensor","date":"2017-04-12T04:22:33.000Z","updated":"2017-05-10T11:58:59.960Z","comments":true,"path":"2017/04/12/Android_Sensor/","link":"","permalink":"jingg.me/2017/04/12/Android_Sensor/","excerpt":"待续…http://processors.wiki.ti.com/index.php/Android_Sensor_PortingGuide","text":"待续…http://processors.wiki.ti.com/index.php/Android_Sensor_PortingGuide To Dohttp://blog.csdn.net/qq_20678703/article/details/50012597","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"sensor","slug":"sensor","permalink":"jingg.me/tags/sensor/"}]},{"title":"Input系统——TYPE CODE","slug":"InputSystem004_type_code","date":"2017-04-12T04:22:33.000Z","updated":"2017-04-26T13:01:33.546Z","comments":true,"path":"2017/04/12/InputSystem004_type_code/","link":"","permalink":"jingg.me/2017/04/12/InputSystem004_type_code/","excerpt":"Event Type&amp;CodeEV_SYN: - 用于事件间的分割标志。事件可能按时间或空间进行分割，就像在多点触摸协议中的例子。 SYN_REPORT: - 当多个输入数据在同一时间发生变化时，SYN_REPORT用于把这些数据进行打包和包同步。 例如，一次鼠标的移动可以上报 REL_X和REL_Y两个数值，然后发出一个SYN_REPORT。 下一次鼠标移动可以再次发出REL_X和REL_Y两个数值，然后经跟这另一个SYN_REPORT。 SYN_MT_REPORT: - 用于同步和分离触摸事件 SYN_DROPPED: - 用来指出evdev客户的事件队列的的缓冲区溢出。 EV_KEY: - 用来描述键盘，按键或者类似键盘设备的状态变化。 KEY_&lt;name&gt;: - EV_KEY事件采取KEY_&lt;name&gt; 或BTN_&lt;name&gt;的形式， 比如，KEY_A代表键盘上的A键，当一个按键被按下时，一个带有按键编码和value为1的事件被发出。 当一个按键被释放时，一个value为0的事件被发出。有些硬件当按键重复时会发出事件，这些事件的value值为2。 通常，KEY_&lt;name&gt;用作键盘上的按键，而BTN_&lt;name&gt;则用于开关按钮事件。 - 普通键盘按键 0x0~0x100 0x160~0x2ff - 游戏柄的按键 0x100~0x110 0x120~0x140 - 鼠标按键 BTN_MOUSE-BTN_LEFT-0x110-左键； BTN_RIGHT-0x111-右键； BTN_MIDDLE-0x112-中键； BTN_&lt;name&gt;: - see above","text":"Event Type&amp;CodeEV_SYN: - 用于事件间的分割标志。事件可能按时间或空间进行分割，就像在多点触摸协议中的例子。 SYN_REPORT: - 当多个输入数据在同一时间发生变化时，SYN_REPORT用于把这些数据进行打包和包同步。 例如，一次鼠标的移动可以上报 REL_X和REL_Y两个数值，然后发出一个SYN_REPORT。 下一次鼠标移动可以再次发出REL_X和REL_Y两个数值，然后经跟这另一个SYN_REPORT。 SYN_MT_REPORT: - 用于同步和分离触摸事件 SYN_DROPPED: - 用来指出evdev客户的事件队列的的缓冲区溢出。 EV_KEY: - 用来描述键盘，按键或者类似键盘设备的状态变化。 KEY_&lt;name&gt;: - EV_KEY事件采取KEY_&lt;name&gt; 或BTN_&lt;name&gt;的形式， 比如，KEY_A代表键盘上的A键，当一个按键被按下时，一个带有按键编码和value为1的事件被发出。 当一个按键被释放时，一个value为0的事件被发出。有些硬件当按键重复时会发出事件，这些事件的value值为2。 通常，KEY_&lt;name&gt;用作键盘上的按键，而BTN_&lt;name&gt;则用于开关按钮事件。 - 普通键盘按键 0x0~0x100 0x160~0x2ff - 游戏柄的按键 0x100~0x110 0x120~0x140 - 鼠标按键 BTN_MOUSE-BTN_LEFT-0x110-左键； BTN_RIGHT-0x111-右键； BTN_MIDDLE-0x112-中键； BTN_&lt;name&gt;: - see above EV_REL: - 用来描述相对坐标轴上数值的变化，例如：鼠标向左方移动了5个单位。 REL_X 0x00 //X 轴 REL_Y 0x01 //Y 轴 REL_Z 0x02 //Z 轴 REL_RX 0x03 REL_RY 0x04 REL_RZ 0x05 REL_HWHEEL 0x06 //水平方向horizontal的滚轮 REL_DIAL 0x07 REL_WHEEL 0x08 //垂直方向vertical的滚轮 REL_MISC 0x09 REL_MAX 0x0f REL_CNT (REL_MAX+1) EV_ABS: - 用来描述相对坐标轴上数值的变化，例如：描述触摸屏上坐标的值。 ABS_X 0x00 ABS_Y 0x01 ABS_Z 0x02 ABS_RX 0x03 ABS_RY 0x04 ABS_RZ 0x05 ABS_THROTTLE 0x06 ABS_RUDDER 0x07 ABS_WHEEL 0x08 ABS_GAS 0x09 ABS_BRAKE 0x0a ABS_DISTANCE 0x19 - 用来描述触摸工具离触摸表面的距离 ABS_MT_&lt;name&gt; 用于描述多手指触摸输入设备。详情请参考内核文档：multi-touch-protocol.txt。 EV_MSC: - 当不能匹配现有的类型时，使用该类型进行描述。 EV_SW: - 用来描述具备两种状态的输入开关。 SW_LID 0x00 用来指出笔记本电脑的屏幕是否合上 EV_LED: - 用于设置或查询设备上的LED灯的开和关。 EV_SND: - 用来给设备输出提示声音。 EV_REP: - 用于可以自动重复的设备（autorepeating）。 EV_FF: - 用来给输入设备发送强制回馈命令。（震动？） FF_RUMBLE 0x50 FF_CONSTANT 0x52 EV_PWR: - 特别用于电源开关的输入。. EV_FF_STATUS: - 用于接收设备的强制反馈状态。 INPUT_DEVICE_ClASS 来区分INPUT_DEVICE_CLASS_CURSOR 有BTN_MOUSE按钮 且 REL_X及REL_Y INPUT_DEVICE_CLASS_TOUCH | INPUT_DEVICE_CLASS_TOUCH_MT 有BTN_TOUCH ABS_MT_POSITION_X ABS_MT_POSITION_Y 且没有游戏键 INPUT_DEVICE_CLASS_JOYSTICK INPUT_DEVICE_CLASS_SWITCH 任一个即可 INPUT_DEVICE_CLASS_VIBRATOR 有FF_RUMBLE-0x50 TOOL_TYPEAMOTION_EVENT_TOOL_TYPE_UNKNOWN 0 类型未知，或者都无关联项，例如 trackball or other non-pointing device. AMOTION_EVENT_TOOL_TYPE_FINGER 1 The tool is a finger 触摸类工具 AMOTION_EVENT_TOOL_TYPE_STYLUS 2 类似触针类工具，例如手写笔等 AMOTION_EVENT_TOOL_TYPE_MOUSE 3 The tool is a mouse or trackpad. 鼠标或者触摸板 AMOTION_EVENT_TOOL_TYPE_ERASER 4 The tool is an eraser or a stylus being used in an inverted posture. 擦除类工具，或者一类反向针式工具 MotionEvent用于报告运动事件，例如 mouse, pen, finger, trackball Motion events may hold either absolute or relative movements and other data, depending on the type of device. ACTION_BUTTON_PRESS ACTION_BUTTON_RELEASE ACTION_CANCEL // The current gesture has been aborted. ACTION_SCROLL // The motion event contains relative vertical and/or horizontal scroll offsets. ACTION_UP // AXIS_SCROLL // Generic scroll axis of a motion event. AINPUT_SOURCE基本类型 AINPUT_SOURCE_CLASS_MASK 0x000000ff // AINPUT_SOURCE_UNKNOWN 0x00000000 // AINPUT_SOURCE_CLASS_BUTTON 0x00000001 // 输入设备有按钮和键 AINPUT_SOURCE_CLASS_POINTER 0x00000002 // 与显示相关的指针式设备 AINPUT_SOURCE_CLASS_NAVIGATION 0x00000004 // AINPUT_SOURCE_CLASS_TRACKBALL 0x00000004 // 轨迹导航设备 AINPUT_SOURCE_CLASS_POSITION 0x00000008 // 绝对定位设备（与显示无关的定位） AINPUT_SOURCE_CLASS_JOYSTICK 0x00000010 // AINPUT_SOURCE_CLASS_NONE 0x00000000 // joystick 操作杆，绝对运动 衍生类型 AINPUT_SOURCE_KEYBOARD 0x00000101 // AINPUT_SOURCE_DPAD 0x00000201 // AINPUT_SOURCE_GAMEPAD 0x00000401 // AINPUT_SOURCE_TOUCHSCREEN 0x00001002 // AINPUT_SOURCE_MOUSE 0x00002002 // AINPUT_SOURCE_STYLUS 0x00004002 // AINPUT_SOURCE_BLUETOOTH_STYLUS 0x0000c002 // 蓝牙指针，蓝牙鼠标? API 23 AINPUT_SOURCE_TRACKBALL 0x00010004 // AINPUT_SOURCE_MOUSE_RELATIVE 0x00020004 // Android O Developer Preview AINPUT_SOURCE_TOUCHPAD 0x00100008 // AINPUT_SOURCE_TOUCH_NAVIGATION 0x00200000 // AINPUT_SOURCE_ROTARY_ENCODER 0x00400000 // Android O Developer Preview AINPUT_SOURCE_JOYSTICK 0x01000010 // AINPUT_SOURCE_HDMI 0x02000001 // AINPUT_SOURCE_ANY 0xffffff00 // AINPUT_KEYBOARD_TYPEAINPUT_KEYBOARD_TYPE_NONE 0 // There is no keyboard AINPUT_KEYBOARD_TYPE_NON_ALPHABETIC 1 // The keyboard supports a complement of alphabetic keys. AINPUT_KEYBOARD_TYPE_ALPHABETIC 2 // The keyboard is not fully alphabetic Input device configuration (.idc) Input device configuration files (.idc files) contain device-specific configuration properties that affect the behavior of input devices. Location /system/usr/idc/ or /data/system/devices/idc/ idc文件example如下 # This is an example of an input device configuration file. # It might be used to describe the characteristics of a built-in touch screen. # This is an internal device, not an external peripheral attached to the USB # or Bluetooth bus. device.internal = 1 # The device should behave as a touch screen, which uses the same orientation # as the built-in display. touch.deviceType = touchScreen touch.orientationAware = 1 # Additional calibration properties... keyboard.layout = qwerty keyboard.characterMap = qwerty keyboard.orientationAware = 1 keyboard.builtIn = 1 cursor.mode = navigation cursor.orientationAware = 1 Common属性语法 device.internal // Specifies whether the input device is an internal built-in component as opposed to an externally attached (most likely removable) peripheral. If the value is 0, the device is external. If the value is 1, the device is internal. If the value is not specified, the default value is 0 for all devices on the USB (BUS_USB) or Bluetooth (BUS_BLUETOOTH) bus, 1 otherwise. This property determines default policy decisions regarding wake events. Key Layout Files (.kl) 详见 https://source.android.com/devices/input/key-layout-files Key layout files (.kl files) map Linux key codes and axis codes to Android key codes and axis codes and specify associated policy flags. Device-specific key layout files are: Required for internal (built-in) input devices with keys, including special keys such as volume, power, and headset media keys. Optional for other input devices but recommended for special-purpose keyboards and joysticks. If no device-specific key layout file is available, the system chooses a default instead. Location /system/usr/keylayout/ or /data/system/devices/keylayout/ Generic Key Layout File The system provides a special built-in generic key layout file called Generic.kl. This key layout is intended to support a variety of standard external keyboards and joysticks. Do not modify the generic key layout! Syntax A key layout file is a plain text file consisting of key or axis declarations and flags. Key Declarations key Linux key code number Android key code name key usage HID usage(Hex 32-bit integer) Android key code name Axis Declarations axis Linux axis code number Android axis code name Basic Axes Split Axes Inverted Axes Center Flat Position Option Comments Comment lines begin with # and continue to the end of the line: # A comment! Examples -- Keyboard -- key 1 ESCAPE key 2 1 key 3 2 key 4 3 key 5 4 key 6 5 key 7 6 key 8 7 key 9 8 key 10 9 key 11 0 key 12 MINUS key 13 EQUALS key 14 DEL -- System Controls -- # This is an example of a key layout file for basic system controls, # such as volume and power keys which are typically implemented as GPIO pins # the device decodes into key presses. key 114 VOLUME_DOWN key 115 VOLUME_UP key 116 POWER -- Capacitive Buttons -- # This is an example of a key layout file for a touch device with capacitive buttons. key 139 MENU VIRTUAL key 102 HOME VIRTUAL key 158 BACK VIRTUAL key 217 SEARCH VIRTUAL -- Headset Jack Media Controls -- # This is an example of a key layout file for headset mounted media controls. # A typical headset jack interface might have special control wires or detect known # resistive loads as corresponding to media functions or volume controls. # This file assumes that the driver decodes these signals and reports media # controls as key presses. key 163 MEDIA_NEXT key 165 MEDIA_PREVIOUS key 226 HEADSETHOOK -- Joystick -- # This is an example of a key layout file for a joystick. # These are the buttons that the joystick supports, represented as keys. key 304 BUTTON_A key 305 BUTTON_B key 307 BUTTON_X key 308 BUTTON_Y key 310 BUTTON_L1 key 311 BUTTON_R1 key 314 BUTTON_SELECT key 315 BUTTON_START key 316 BUTTON_MODE key 317 BUTTON_THUMBL key 318 BUTTON_THUMBR # Left and right stick. # The reported value for flat is 128 in a range of -32767 to 32768, which is absurd. # This confuses applications that rely on the flat value because the joystick # actually settles in a flat range of +/- 4096 or so. We override it here. axis 0x00 X flat 4096 axis 0x01 Y flat 4096 axis 0x03 Z flat 4096 axis 0x04 RZ flat 4096 # Triggers. axis 0x02 LTRIGGER axis 0x05 RTRIGGER # Hat. axis 0x10 HAT_X axis 0x11 HAT_Y Virtual Soft Keys // to do Validation You should validate your key layout files using the Validate Keymaps tool. Key Character Map Files (.kcm) Key character map files (.kcm files) are responsible for mapping combinations of Android key codes with modifiers to Unicode characters. Location /system/usr/keychars/ /data/system/devices/keychars/ Generic Key Character Map File Generic.kcm Virtual Key Character Map File Virtual.kcm Syntax Keyboard Type Declaration Key Declarations Comments Keyboard DevicesTouch Devices附1：HID号码即Hidden ID code 隐含码；PID号码即Public ID code 公开码。 附2(参考资料)https://source.android.com/devices/input/overviewhttps://www.kernel.org/doc/Documentation/input/event-codes.txthttps://www.kernel.org/doc/Documentation/input/input.txthttps://www.kernel.org/doc/Documentation/input/multi-touch-protocol.txthttps://developer.android.com/reference/android/support/wearable/input/RotaryEncoder.html","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"input","slug":"input","permalink":"jingg.me/tags/input/"},{"name":"input系统","slug":"input系统","permalink":"jingg.me/tags/input系统/"},{"name":"event","slug":"event","permalink":"jingg.me/tags/event/"}]},{"title":"Android编译系统——完整编译过程分析","slug":"Android_Build_CompleteCompileProcess","date":"2017-04-12T04:22:33.000Z","updated":"2017-04-27T03:21:08.838Z","comments":true,"path":"2017/04/12/Android_Build_CompleteCompileProcess/","link":"","permalink":"jingg.me/2017/04/12/Android_Build_CompleteCompileProcess/","excerpt":"###编译命令 make //整体编译Android mm mmm get_build_var TARGET_PRODUCT //获取指定变量的当前值 待续...","text":"###编译命令 make //整体编译Android mm mmm get_build_var TARGET_PRODUCT //获取指定变量的当前值 待续...","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"jingg.me/tags/Android/"},{"name":"编译","slug":"编译","permalink":"jingg.me/tags/编译/"}]},{"title":"APK 反编译及签名工具","slug":"Android_APK_tool","date":"2017-04-12T04:22:33.000Z","updated":"2017-05-18T06:35:16.382Z","comments":true,"path":"2017/04/12/Android_APK_tool/","link":"","permalink":"jingg.me/2017/04/12/Android_APK_tool/","excerpt":"反编译/解包/再编译1. Apktool——APK反编译及再打包工具通过反编译APK中XML文件，直接可以查看https://ibotpeaches.github.io/Apktool/ 下载安装Apktool （Windows/Linux/Mac）https://ibotpeaches.github.io/Apktool/install/ Apktool 通常用法反编译APK apktool d[ecode] test.apk再打包成APK apktool b[uild] test 2. dex2jar将apk中的classes.dex转化成Jar文件https://github.com/pxb1988/dex2jar 3. JD-GUI反编译工具，可以直接查看Jar包的源代码https://code.google.com/archive/p/innlab/downloadshttps://pan.baidu.com/disk/home#list/vmode=list&amp;path=%2Fapps%2FAPK-Track%E5%B7%A5%E5%85%B7","text":"反编译/解包/再编译1. Apktool——APK反编译及再打包工具通过反编译APK中XML文件，直接可以查看https://ibotpeaches.github.io/Apktool/ 下载安装Apktool （Windows/Linux/Mac）https://ibotpeaches.github.io/Apktool/install/ Apktool 通常用法反编译APK apktool d[ecode] test.apk再打包成APK apktool b[uild] test 2. dex2jar将apk中的classes.dex转化成Jar文件https://github.com/pxb1988/dex2jar 3. JD-GUI反编译工具，可以直接查看Jar包的源代码https://code.google.com/archive/p/innlab/downloadshttps://pan.baidu.com/disk/home#list/vmode=list&amp;path=%2Fapps%2FAPK-Track%E5%B7%A5%E5%85%B7 签名1. keytool是个密钥和证书管理工具,可以用来生成证书.keytool -genkey -keystore test.keystore -alias test -keyalg RSA -validity 10000 参数解释: -genkey 产生证书文件 -keystore 指定密钥库的.keystore文件中 -keyalg 指定密钥的算法,这里指定为RSA(非对称密钥算法) -validity 为证书有效天数，这里我们写的是10000天 -alias 产生别名 2. jarsigner工具利用密钥仓库中的信息来产生或校验 Java 存档 (JAR) 文件的数字签名 可以使用jarsigner 来签名,例子如下:jarsigner -verbose -keystore test.keystore -signedjar -signed.apk unsigned.apk &#39;test.keystore&#39; 参数说明: -verbose：指定生成详细输出 -keystore：指定数字证书存储路径 -signedjar：该选项的三个参数为 签名后的apk包 未签名的apk包 数字证书别名(注意顺序) To Do后续将qq记事本中《加密和签名（及反编译）》 整合到本文 … SeeAlso《Android APP加密和签名》","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"APK反编译，APK签名","slug":"APK反编译，APK签名","permalink":"jingg.me/tags/APK反编译，APK签名/"}]},{"title":"RK平台分区信息","slug":"RK_AndroidPartitionInfo","date":"2017-04-11T09:35:57.000Z","updated":"2017-04-27T03:19:07.044Z","comments":true,"path":"2017/04/11/RK_AndroidPartitionInfo/","link":"","permalink":"jingg.me/2017/04/11/RK_AndroidPartitionInfo/","excerpt":"RK 分区信息和一般Android 系统分区有些许区别，下面我们来看看","text":"RK 分区信息和一般Android 系统分区有些许区别，下面我们来看看 RK平台分区信息与eMMC partitions对应lrwxrwxrwx root root 2013-01-21 08:50 uboot -&gt; /dev/block/mmcblk0p1 lrwxrwxrwx root root 2013-01-21 08:50 trust -&gt; /dev/block/mmcblk0p2 lrwxrwxrwx root root 2013-01-21 08:50 misc -&gt; /dev/block/mmcblk0p3 lrwxrwxrwx root root 2013-01-21 08:50 resource -&gt; /dev/block/mmcblk0p4 lrwxrwxrwx root root 2013-01-21 08:50 kernel -&gt; /dev/block/mmcblk0p5 lrwxrwxrwx root root 2013-01-21 08:50 boot -&gt; /dev/block/mmcblk0p6 lrwxrwxrwx root root 2013-01-21 08:50 recovery -&gt; /dev/block/mmcblk0p7 lrwxrwxrwx root root 2013-01-21 08:50 backup -&gt; /dev/block/mmcblk0p8 lrwxrwxrwx root root 2013-01-21 08:50 cache -&gt; /dev/block/mmcblk0p9 lrwxrwxrwx root root 2013-01-21 08:50 kpanic -&gt; /dev/block/mmcblk0p10 lrwxrwxrwx root root 2013-01-21 08:50 system -&gt; /dev/block/mmcblk0p11 lrwxrwxrwx root root 2013-01-21 08:50 metadata -&gt; /dev/block/mmcblk0p12 lrwxrwxrwx root root 2013-01-21 08:50 baseparamer -&gt; /dev/block/mmcblk0p13 lrwxrwxrwx root root 2013-01-21 08:50 userdata -&gt; /dev/block/mmcblk0p14 lrwxrwxrwx root root 2013-01-21 08:50 radical_update -&gt; /dev/block/mmcblk0p15 lrwxrwxrwx root root 2013-01-21 08:50 user -&gt; /dev/block/mmcblk0p16 mmcblk0: p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13 p14 p15 p16 p17 /mnt/external_sd vfat /dev/block/mmcblk1p1 RK平台各分区介绍uboot.img trust.img misc.img RK平台，misc分区内容用于启动模式切换，是升级基带还是进入Recovery（misc分区的内容可以被按键出发改变???） resource.img RK平台资源映像，内含开机图片和内核的设备树信息。 kernel boot.img Android 的初始文件映像，负责初始化并加载 system 分区，一般Android系统这个镜像中包含ramdisk.img根文件系统+kernel（RK平台的boot.img是没包含kernel部分的） ramdisk.img 是根文件系统，是root目录打包成的镜像（ramdisk-recovery.img） recovery.img 恢复模式系统启动镜像。内容和boot.img雷同（RK平台recovery.img包含kernel部分），但是其中的ramdisk.img（ramdisk-recovery.img）有些许不同： recovery.fstab文件、sbin下部分工具、build.prop、init.bootmode.emmc.rc、sepolicy等 backup cache kpanic system.img 包括了主要的包、库等文件 metadata baseparameter userdata.img 包括了一些用户数据 radical_update user 另：RK平台生成boot.img recovery.img system.img userdata.img是使用自己的mkimage.sh工具讲root system data 目录生成的 再使用工具mkupdate.sh生成update.img的（不带userdata.img） 烧写userdata.img 需要使用./upgrade_tool DI userdata userdata.img 单独烧写","categories":[{"name":"RK","slug":"RK","permalink":"jingg.me/categories/RK/"}],"tags":[{"name":"分区","slug":"分区","permalink":"jingg.me/tags/分区/"},{"name":"RK","slug":"RK","permalink":"jingg.me/tags/RK/"}]},{"title":"Android编译系统——ramdisk.img system.img userdata.img recovery.img目标编译过程","slug":"Android_Build_Img","date":"2017-04-11T09:35:57.000Z","updated":"2017-04-27T03:21:18.256Z","comments":true,"path":"2017/04/11/Android_Build_Img/","link":"","permalink":"jingg.me/2017/04/11/Android_Build_Img/","excerpt":"image 介绍boot.img Android 的初始文件映像，负责初始化并加载 system 分区，一般Android系统这个镜像中包含ramdisk.img根文件系统+kernel（RK平台的boot.img是没包含kernel部分的） recovery.img 恢复模式系统启动镜像。内容和boot.img雷同（RK平台recovery.img包含kernel部分），但是其中的ramdisk.img（ramdisk-recovery.img）有些许不同： recovery.fstab文件、sbin下部分工具、build.prop、init.bootmode.emmc.rc、sepolicy等 ramdisk.img 是根文件系统，是root目录打包成的镜像（ramdisk-recovery.img） system.img 包括了主要的包、库等文件 userdata.img 包括了一些用户数据","text":"image 介绍boot.img Android 的初始文件映像，负责初始化并加载 system 分区，一般Android系统这个镜像中包含ramdisk.img根文件系统+kernel（RK平台的boot.img是没包含kernel部分的） recovery.img 恢复模式系统启动镜像。内容和boot.img雷同（RK平台recovery.img包含kernel部分），但是其中的ramdisk.img（ramdisk-recovery.img）有些许不同： recovery.fstab文件、sbin下部分工具、build.prop、init.bootmode.emmc.rc、sepolicy等 ramdisk.img 是根文件系统，是root目录打包成的镜像（ramdisk-recovery.img） system.img 包括了主要的包、库等文件 userdata.img 包括了一些用户数据 image 目标编译过程---build/core/main.mk中--- 默认目标，即目标all .PHONY: droid DEFAULT_GOAL := droid $(DEFAULT_GOAL): //root目标droid droid: droidcore dist_files //1级目标，droidcore droidcore: files \\ //2级目标，files systemimage ... systemimage \\ $(INSTALLED_BOOTIMAGE_TARGET) \\ $(INSTALLED_RECOVERYIMAGE_TARGET) \\ $(INSTALLED_USERDATAIMAGE_TARGET) \\ $(INSTALLED_CACHEIMAGE_TARGET) \\ $(INSTALLED_VENDORIMAGE_TARGET) \\ $(INSTALLED_FILES_FILE) ---build/core/Makefile中--- INSTALLED_SYSTEMIMAGE := $(PRODUCT_OUT)/system.img BUILT_SYSTEMIMAGE := $(systemimage_intermediates)/system.img FULL_SYSTEMIMAGE_DEPS := $(INTERNAL_SYSTEMIMAGE_FILES) $(INTERNAL_USERIMAGES_DEPS) INSTALLED_FILES_FILE := $(PRODUCT_OUT)/installed-files.txt systemimage: $(INSTALLED_SYSTEMIMAGE) //3级目标 ./system.img $(INSTALLED_SYSTEMIMAGE): $(BUILT_SYSTEMIMAGE) $(RECOVERY_FROM_BOOT_PATCH) | $(ACP) //4级目标 _./system.img $(BUILT_SYSTEMIMAGE): $(FULL_SYSTEMIMAGE_DEPS) $(INSTALLED_FILES_FILE) //5级目标 $(call build-systemimage-target,$@) BUILT_USERDATAIMAGE_TARGET := $(PRODUCT_OUT)/userdata.img INSTALLED_USERDATAIMAGE_TARGET := $(BUILT_USERDATAIMAGE_TARGET) INTERNAL_USERDATAIMAGE_FILES := \\ //4级目标 $(filter $(TARGET_OUT_DATA)/%,$(ALL_DEFAULT_INSTALLED_MODULES)) $(INSTALLED_USERDATAIMAGE_TARGET): $(INTERNAL_USERIMAGES_DEPS) \\ //3级目标 $(INTERNAL_USERDATAIMAGE_FILES) $(build-userdataimage-target) define build-userdataimage-target //做userdata.img分区build操作 $(call pretty,&quot;Target userdata fs image: $(INSTALLED_USERDATAIMAGE_TARGET)&quot;) @mkdir -p $(TARGET_OUT_DATA) @mkdir -p $(userdataimage_intermediates) &amp;&amp; rm -rf $(userdataimage_intermediates)/userdata_image_info.txt $(call generate-userimage-prop-dictionary, $(userdataimage_intermediates)/userdata_image_info.txt, skip_fsck=true) $(hide) PATH=$(foreach p,$(INTERNAL_USERIMAGES_BINARY_PATHS),$(p):)$$PATH \\ ./build/tools/releasetools/build_image.py \\ $(TARGET_OUT_DATA) $(userdataimage_intermediates)/userdata_image_info.txt $(INSTALLED_USERDATAIMAGE_TARGET) $(hide) $(call assert-max-image-size,$(INSTALLED_USERDATAIMAGE_TARGET),$(BOARD_USERDATAIMAGE_PARTITION_SIZE)) endef 注 system.img userdata.img 会依赖skip_userdata.img := 这个变量 及 嵌套依赖device/.../BoardConfig.mk中的TARGET_USERIMAGES_USE_EXT4、BOARD_SYSTEMIMAGE_PARTITION_SIZE、BOARD_USERDATAIMAGE_PARTITION_SIZE和 image解压方法ramdisk.img 用file命令查看显示ramdisk.img: gzip compressed data, from Unix，采用cpio打包，gzip压缩的 cp -a ramdisk.img 000/ramdisk.img.gz cd 000/ gunzip ramdisk.img.gz //得到ramdisk.img 文件，但是和原始的ramdisk.img是不一样的，大小要大不少 mkdir root cd root cpio –i -F ../ramdisk.img system.img 用file命令查看显示system.img: data cp -a system.img 000/system.img cd 000/ out/host/linux-x86/bin/simg2img system.img system.ext4.img //用simg2img工具把system.img转为为ext4文件格式 mkdir system //建立system目录 sudo mount -t ext4 -o loop system.ext4.img system //将ext4格式的镜像挂在到system目录 userdata.img 用file命令查看显示userdata.img: data 同system.img recovery.img 用file命令查看显示recovery.img: data 需要使用外部工具https://github.com/xiaolu/mkbootimg_tools.git mkboot命令 ./mkbootimg_tools/mkboot recovery.img recovery boot.img 用file命令查看显示boot.img: data 需要使用外部工具https://github.com/xiaolu/mkbootimg_tools.git mkboot命令 ./mkbootimg_tools/mkboot boot.img boot image压缩方法a. ramdisk 使用cpio -o -H | gzip 生成ramdisk.img b. system userdata recovery都可以使用mkuserimg.sh来压缩成镜像 mkuserimg.sh -s 镜像源目录 镜像输出文件 ext4 挂在点 分区size FILE_CONTEXTS文件 单独编译imagemake systemimage - system.img make userdataimage - userdata.img make ramdisk - ramdisk.img make snod - 快速打包system.img (with this command, it will build a new system.img very quickly. well, you cannot use &quot;make snod&quot; for all the situations. it would not check the dependences. if you change some code in the framework which will effect other applications) 附:simg2img解压缩工具: Convert Android sparse images to raw images. 在out/host/linux-x86/bin/simg2img可以找到 用法：simg2img &lt;sparse_image_files&gt; &lt;raw_image_file&gt; mkuserimg.sh镜像制作工具，在out/host/linux-x86/bin/mkuserimg.sh可以找到，工具中会调用make_ext4fs 用法：mkuserimg.sh [-s] SRC_DIR OUTPUT_FILE EXT_VARIANT MOUNT_POINT SIZE [-j &lt;journal_size&gt;] [-T TIMESTAMP] [-C FS_CONFIG] [-B BLOCK_LIST_FILE] [FILE_CONTEXTS] 例如制作system.img和userdata.img时： Running: mkuserimg.sh -s out/target/product/rk3368_box/system out/target/product/rk3368_box/obj/PACKAGING/systemimage_intermediates/system.img ext4 system 1073741824 out/target/product/rk3368_box/root/file_contexts make_ext4fs -s -T -1 -S out/target/product/rk3368_box/root/file_contexts -l 1073741824 -a system out/target/product/rk3368_box/obj/PACKAGING/systemimage_intermediates/system.img out/target/product/rk3368_box/system Running: mkuserimg.sh -s out/target/product/rk3368_box/data out/target/product/rk3368_box/userdata.img ext4 data 2147483648 out/target/product/rk3368_box/root/file_contexts make_ext4fs -s -T -1 -S out/target/product/rk3368_box/root/file_contexts -l 2147483648 -a data out/target/product/rk3368_box/userdata.img out/target/product/rk3368_box/data make_ext4fs工具：用于Android平台上制作ext4文件系统的镜像，在out/host/linux-x86/bin/make_ext4fs 用法：make_ext4fs [ -l &lt;len&gt; ] [ -j &lt;journal size&gt; ] [ -b &lt;block_size&gt; ] [ -g &lt;blocks per group&gt; ] [ -i &lt;inodes&gt; ] [ -I &lt;inode size&gt; ] [ -L &lt;label&gt; ] [ -f ] [ -a &lt;android mountpoint&gt; ] [ -S file_contexts ] [ -C fs_config ] [ -T timestamp ] [ -z | -s ] [ -w ] [ -c ] [ -J ] [ -v ] [ -B &lt;block_list_file&gt; ] &lt;filename&gt; [&lt;directory&gt;] -l 分区大小 支持512M 以及1073741824 单位为bytes -s 生成ext4的S模式制作 -T timestamp // -1 mean what? fix me -a 挂在点 -S file_contexts文件 &lt;filename&gt; 生成的目的文件 &lt;directory&gt; 源文件目录 附2——一般Android系统的boot.img格式(RK平台的boot.img是没包含kernel部分的)因为boot.img的格式比较简单，它主要分为三大块（有的可能有四块） +—————–+ | boot header | 1 page +—————–+ | kernel | n pages +—————–+ | ramdisk | m pages +—————–+ | second stage | o pages +—————–+ n = (kernel_size + page_size – 1) / page_size m = (ramdisk_size + page_size – 1) / page_size o = (second_size + page_size – 1) / page_size a. all entities are page_size aligned in flash b. kernel and ramdisk are required (size != 0) c. second is optional (second_size == 0 -&gt; no second)","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"jingg.me/tags/Android/"},{"name":"编译","slug":"编译","permalink":"jingg.me/tags/编译/"},{"name":"image","slug":"image","permalink":"jingg.me/tags/image/"}]},{"title":"RK平台Android分区大小修改说明","slug":"RK_AndroidPartitionSizeModifyGuide","date":"2017-04-11T01:01:57.000Z","updated":"2017-04-27T03:19:19.910Z","comments":true,"path":"2017/04/11/RK_AndroidPartitionSizeModifyGuide/","link":"","permalink":"jingg.me/2017/04/11/RK_AndroidPartitionSizeModifyGuide/","excerpt":"不同于一般的Android系统（一般Android系统分区信息在BoardConfig.mk BoardConfigCommon.mk中），RK平台的分区信息文件在自带的烧录工具包中的parameter文件中","text":"不同于一般的Android系统（一般Android系统分区信息在BoardConfig.mk BoardConfigCommon.mk中），RK平台的分区信息文件在自带的烧录工具包中的parameter文件中 如下是板子的parameter文件:FIRMWARE_VER: 5.1.0 MACHINE_MODEL: Geekbox MACHINE_ID: 007 MANUFACTURER: RK3368 MAGIC: 0x5041524B ATAG: 0x00200800 MACHINE: 3368 CHECK_MASK: 0x80 PWR_HLD: 0,0,A,0,1 #KERNEL_IMG: 0x00280000 #FDT_NAME: rk-kernel.dtb #RECOVER_KEY: 1,1,0,20,0 #in section; per section 512(0x200) bytes CMDLINE: console=ttyS2 androidboot.baseband=N/A androidboot.selinux=permissive androidboot.hardware=rk30board androidboot.console=ttyS2 init=/init mtdparts=rk29xxnand:0x00002000@0x00002000(uboot),0x00002000@0x00004000(trust),0x00002000@0x00006000(misc),0x00008000@0x00008000(resource),0x00008000@0x00010000(kernel),0x00010000@0x00018000(boot),0x00010000@0x00028000(recovery),0x00038000@0x00038000(backup),0x00040000@0x00070000(cache),0x00002000@0x000B0000(kpanic),0x00200000@0x000B2000(system),0x00008000@0x002B2000(metadata),0x00002000@0x002BA000(baseparamer),0x00400000@0x002BC000(userdata),0x00020000@0x006BC000(radical_update),-@0x006DC000(user) 分区信息在mtdparts=rk29xxnand:字段后面部分，所以我们修改这部分内容就可以了 这部分信息格式介绍 如：0x00002000@0x00002000(uboot) 分区大小计算为=0x00002000*512Bytes = 4MBytes ↑分区的sector数，每个sector=512Bytes ↑分区起始地址 ↑分区名 0x00200000@0x002BC000(userdata) 分区大小0x00200000*512Bytes = 1073741824 Bytes 注: sector 512Bytes 逻辑单位??? page: FLASH操作的基本单位。 最小读/写单元 page， 1page = 4096Bytes = 4KB； block:最小擦除单元 block，1block = (32 * page) = (32 * 4KB) = 131072Bytes = 128KB； 上述mtdparts=rk29xxnand:字段中所有分区都是连续的，当前分区起始地址+当前分区size和下个分区起始地址都是连续的，所以当修改了其中某个分区后，在它后面的分区的地址都要顺序往前或往后。 以下是我将userdata分区缩小为1GB，将user分区扩大1GB的例子：修改前: size offset 0x00002000@0x00000000(parameter)//4MB 4MB 0x00002000@0x00002000(uboot), //4MB 8MB 0x00002000@0x00004000(trust), //4MB 12MB 0x00002000@0x00006000(misc), //4MB 16MB 0x00008000@0x00008000(resource),//16MB 32MB 0x00008000@0x00010000(kernel), //16MB 48 0x00010000@0x00018000(boot), //32MB 80 0x00010000@0x00028000(recovery),//32MB 112 0x00038000@0x00038000(backup), //112MB 224 0x00040000@0x00070000(cache), //128MB 352 0x00002000@0x000B0000(kpanic), //4MB 356 0x00200000@0x000B2000(system), //1024MB 1380 0x00008000@0x002B2000(metadata),//16MB 1396 0x00002000@0x002BA000(baseparamer), //4MB 1400MB 0x00400000@0x002BC000(userdata), //2048MB 3448 0x00020000@0x006BC000(radical_update), //64MB 3512 -@0x006DC000(user) //212MB/11394MB ... 修改后: 0x00002000@0x00002000(uboot), //4MB 8MB 0x00002000@0x00004000(trust), //4MB 12MB 0x00002000@0x00006000(misc), //4MB 16MB 0x00008000@0x00008000(resource),//16MB 32MB 0x00008000@0x00010000(kernel), //16MB 48 0x00010000@0x00018000(boot), //32MB 80 0x00010000@0x00028000(recovery),//32MB 112 0x00038000@0x00038000(backup), //112MB 224 0x00040000@0x00070000(cache), //128MB 352 0x00002000@0x000B0000(kpanic), //4MB 356 0x00200000@0x000B2000(system), //1024MB 1380 0x00008000@0x002B2000(metadata),//16MB 1396 0x00002000@0x002BA000(baseparamer), //4MB 1400MB 0x00200000@0x002BC000(userdata), //1024MB 2424MB 0x00020000@0x004BC000(radical_update), //64MB 2488MB -@0x004DC000(user) //1024+212MB = 1236MB 注：1.分区的大小要以4MB对齐！ 2.分区总大小不能超过flash的总长度 修改parameter后效果：shell@rk3368_32:/ # df Filesystem Size Used Free Blksize /dev 495.2M 36.0K 495.2M 4096 /sys/fs/cgroup 495.2M 12.0K 495.2M 4096 /mnt/asec 495.2M 0.0K 495.2M 4096 /mnt/obb 495.2M 0.0K 495.2M 4096 /system 1004.2M 403.0M 601.2M 4096 /cache 122.0M 140.0K 121.8M 4096 /metadata 11.7M 40.0K 11.7M 4096 /data 991.9M 87.5M 904.4M 4096 /mnt/shell/emulated 991.9M 87.5M 904.4M 4096 /mnt/internal_sd 1.2G 136.0K 1.2G 8192 /mnt/secure/asec 1.2G 136.0K 1.2G 8192 一般Android平台分区修改eMMC 分区信息 # cat /proc/partitions major minor #blocks name 254 0 520912 zram0 179 0 15267840 mmcblk0 179 1 4096 mmcblk0p1 179 2 4096 mmcblk0p2 179 3 4096 mmcblk0p3 179 4 16384 mmcblk0p4 179 5 16384 mmcblk0p5 179 6 32768 mmcblk0p6 179 7 32768 mmcblk0p7 179 8 114688 mmcblk0p8 179 9 131072 mmcblk0p9 179 10 4096 mmcblk0p10 179 11 1048576 mmcblk0p11 179 12 16384 mmcblk0p12 179 13 4096 mmcblk0p13 179 14 2097152 mmcblk0p14 179 15 65536 mmcblk0p15 179 16 11667456 mmcblk0p16 mmcblk0即emmc的容量（单位kb） #ls /dev/block/platform/ff0f0000.rksdmmc/by-name/* -l lrwxrwxrwx root root 2013-01-21 08:50 uboot -&gt; /dev/block/mmcblk0p1 lrwxrwxrwx root root 2013-01-21 08:50 trust -&gt; /dev/block/mmcblk0p2 lrwxrwxrwx root root 2013-01-21 08:50 misc -&gt; /dev/block/mmcblk0p3 lrwxrwxrwx root root 2013-01-21 08:50 resource -&gt; /dev/block/mmcblk0p4 lrwxrwxrwx root root 2013-01-21 08:50 kernel -&gt; /dev/block/mmcblk0p5 lrwxrwxrwx root root 2013-01-21 08:50 boot -&gt; /dev/block/mmcblk0p6 lrwxrwxrwx root root 2013-01-21 08:50 recovery -&gt; /dev/block/mmcblk0p7 lrwxrwxrwx root root 2013-01-21 08:50 backup -&gt; /dev/block/mmcblk0p8 lrwxrwxrwx root root 2013-01-21 08:50 cache -&gt; /dev/block/mmcblk0p9 lrwxrwxrwx root root 2013-01-21 08:50 kpanic -&gt; /dev/block/mmcblk0p10 lrwxrwxrwx root root 2013-01-21 08:50 system -&gt; /dev/block/mmcblk0p11 lrwxrwxrwx root root 2013-01-21 08:50 metadata -&gt; /dev/block/mmcblk0p12 lrwxrwxrwx root root 2013-01-21 08:50 baseparamer -&gt; /dev/block/mmcblk0p13 lrwxrwxrwx root root 2013-01-21 08:50 userdata -&gt; /dev/block/mmcblk0p14 lrwxrwxrwx root root 2013-01-21 08:50 radical_update -&gt; /dev/block/mmcblk0p15 lrwxrwxrwx root root 2013-01-21 08:50 user -&gt; /dev/block/mmcblk0p16 即userdata 分区 大小为2097152*1024KB = 2147483648B BoardConfig.mk 中修改指定变量即可： BOARD_BOOTIMAGE_PARTITION_SIZE := 16777216 BOARD_RECOVERYIMAGE_PARTITION_SIZE := 16793600 BOARD_SYSTEMIMAGE_PARTITION_SIZE := 2147483648 BOARD_OEMIMAGE_PARTITION_SIZE := 67108864 BOARD_USERDATAIMAGE_PARTITION_SIZE := 25253773312 ---&gt; 2147483648B BOARD_CACHEIMAGE_PARTITION_SIZE := 268435456 BOARD_CACHEIMAGE_FILE_SYSTEM_TYPE := ext4 BOARD_FLASH_BLOCK_SIZE := 131072","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"分区","slug":"分区","permalink":"jingg.me/tags/分区/"},{"name":"RK","slug":"RK","permalink":"jingg.me/tags/RK/"}]},{"title":"Hexo入手","slug":"Other_HexoSetUp","date":"2017-04-07T10:01:57.000Z","updated":"2017-04-27T03:19:37.756Z","comments":true,"path":"2017/04/07/Other_HexoSetUp/","link":"","permalink":"jingg.me/2017/04/07/Other_HexoSetUp/","excerpt":"1. 安装nodejs从官网下载对应平台binary 包，安装（linux直接将bin lib目录的文件cp到usr/local对应目录下，Window直接点击安装） 2. 安装hexonpm install hexo-cli -g","text":"1. 安装nodejs从官网下载对应平台binary 包，安装（linux直接将bin lib目录的文件cp到usr/local对应目录下，Window直接点击安装） 2. 安装hexonpm install hexo-cli -g 3. 新建bloghexo init blog cd blog npm install hexo server 3. 解决一个warningnpm install -g npm@3.3.12 npm install hexo-deployer-git --save 4. 配置_config.ymllanguage: zh-CN deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] 5. 部署hexo deploy -generate //hexo d -g 附（参考）https://hexo.io/docs/index.html","categories":[{"name":"杂项","slug":"杂项","permalink":"jingg.me/categories/杂项/"}],"tags":[{"name":"网页博客","slug":"网页博客","permalink":"jingg.me/tags/网页博客/"}]},{"title":"Android fstab介绍","slug":"Android_fstab","date":"2017-04-07T08:01:57.000Z","updated":"2017-04-27T03:23:52.649Z","comments":true,"path":"2017/04/07/Android_fstab/","link":"","permalink":"jingg.me/2017/04/07/Android_fstab/","excerpt":"ubuntu fstab文件格式下面是/etc/fatab文件的一个示例行： fs_spec fs_file fs_type fs_options fs_dump fs_pass /dev/hda1 / ext2 defaults 1 1 fs_spec - 该字段定义希望加载的文件系统所在的设备或远程文件系统，对于一般的本地块设备情况来说：IDE设备一般描述为 /dev/hdaXN，X是IDE设备通道 (a, b, or c)，N代表分区号；SCSI设备一描述为/dev/sdaXN。对于NFS情况，格式一般为: 例 如：`knuth.aeb.nl:/&apos;。对于procfs，使用`proc&apos;来定义。 fs_file - 该字段描述希望的文件系统加载的目录点，对于swap设备，该字段为none；对于加载目录名包含空格的情况，用40来 表示空格。 fs_type - 定义了该设备上的文件系统，一般常见的文件类型为ext2 (linux设备的常用文件类型)、vfat(Windows系统的fat32格 式)、NTFS、iso9600等。 fs_options - 指定加载该设备的文件系统是需要使用的特定参数选项，多个参数是由逗号分隔开来。对于大多数系统使用&quot;defaults&quot; 就可以满足需要。其他常见的选项包括： 选项含义: ro 以只读模式加载该文件系统 sync 不对该设备的写操作进行缓冲处理，这可以防止在非正常关机时情况下破坏文件系统，但是却降低了计算机速度 user 允许普通用户加载该文件系统 quota 强制在该文件系统上进行磁盘定额限制 noauto 不再使用mount －a命令（例如系统启动时）加载该文件系统 fs_dump 该选项被&quot;dump&quot;命令使用来检查一个文件系统应该以多快频率进行转储，若不需要转储就设置该字段为0 fs_pass 该字段被fsck命令用来决定在启动时需要被扫描的文件系统的顺序，根文件系统&quot;/&quot;对应该字段的值应该为1， 其他文件系统应该为2。若该文件系统无需在启动时扫描则设置该字段为0","text":"ubuntu fstab文件格式下面是/etc/fatab文件的一个示例行： fs_spec fs_file fs_type fs_options fs_dump fs_pass /dev/hda1 / ext2 defaults 1 1 fs_spec - 该字段定义希望加载的文件系统所在的设备或远程文件系统，对于一般的本地块设备情况来说：IDE设备一般描述为 /dev/hdaXN，X是IDE设备通道 (a, b, or c)，N代表分区号；SCSI设备一描述为/dev/sdaXN。对于NFS情况，格式一般为: 例 如：`knuth.aeb.nl:/&apos;。对于procfs，使用`proc&apos;来定义。 fs_file - 该字段描述希望的文件系统加载的目录点，对于swap设备，该字段为none；对于加载目录名包含空格的情况，用40来 表示空格。 fs_type - 定义了该设备上的文件系统，一般常见的文件类型为ext2 (linux设备的常用文件类型)、vfat(Windows系统的fat32格 式)、NTFS、iso9600等。 fs_options - 指定加载该设备的文件系统是需要使用的特定参数选项，多个参数是由逗号分隔开来。对于大多数系统使用&quot;defaults&quot; 就可以满足需要。其他常见的选项包括： 选项含义: ro 以只读模式加载该文件系统 sync 不对该设备的写操作进行缓冲处理，这可以防止在非正常关机时情况下破坏文件系统，但是却降低了计算机速度 user 允许普通用户加载该文件系统 quota 强制在该文件系统上进行磁盘定额限制 noauto 不再使用mount －a命令（例如系统启动时）加载该文件系统 fs_dump 该选项被&quot;dump&quot;命令使用来检查一个文件系统应该以多快频率进行转储，若不需要转储就设置该字段为0 fs_pass 该字段被fsck命令用来决定在启动时需要被扫描的文件系统的顺序，根文件系统&quot;/&quot;对应该字段的值应该为1， 其他文件系统应该为2。若该文件系统无需在启动时扫描则设置该字段为0 ubuntu上实例:&lt;file system&gt; &lt;mount point&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt; / was on /dev/sda1 during installation UUID=757fbb2f-6ee4-4a05-ad2e-0c16b3edc982 / ext4 errors=remount-ro 0 1 /home was on /dev/sda6 during installation UUID=a018cd99-6608-43fc-adea-319a5f04fb29 /home ext4 defaults 0 2 /opt was on /dev/sda7 during installation UUID=0351ac71-4e1d-4194-8d7f-4d9e873e5830 /opt ext4 defaults 0 2 /work was on /dev/sda8 during installation UUID=3f49c9cc-c9cc-48c5-aa8e-058a1d1ec7ad /work ext4 defaults 0 2 /work2 was on /dev/sda9 during installation UUID=e2f54160-fb2d-4517-af54-13393f80ef5f /work2 ext4 defaults 0 2 swap was on /dev/sda5 during installation UUID=d15cbce2-bff1-4241-9c3c-6811f4a1d67d none swap sw 0 0 Android fstab格式及实例https://source.android.com/devices/storage/config.html &lt;src&gt; &lt;mnt_point&gt; &lt;type&gt; &lt;mnt_flags&gt; &lt;fs_mgr_flags&gt; /devices/ff0f0000.rksdmmc/mmc_host/mmc /mnt/internal_sd vfat defaults voldmanaged=internal_sd:15,noemulatedsd /dev/block/platform/ff0f0000.rksdmmc/by-name/system /system ext4 ro,noatime,nodiratime,noauto_da_alloc wait,resize,check src: 设备路径 mnt_point: 挂在点 type: volume中文件系统类型, 对于external cards, type 为vfat mnt_flags: Vold ignores this field and it should be set to defaults fs_mgr_flags: Vold ignores any lines in the unified fstab that do not include the voldmanaged= flag in this field. This flag must be followed by a label describing the card, and a partition number or the word auto. Here is an example: voldmanaged=sdcard:auto. Other possible flags are nonremovable, encryptable=sdcard, noemulatedsd, and encryptable=userdata. 待续...","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"fstab","slug":"fstab","permalink":"jingg.me/tags/fstab/"}]},{"title":"Android 智能指针——SP WP","slug":"Android_SmartPointer_SP_WP","date":"2016-12-31T16:00:00.000Z","updated":"2017-04-27T03:21:02.504Z","comments":true,"path":"2017/01/01/Android_SmartPointer_SP_WP/","link":"","permalink":"jingg.me/2017/01/01/Android_SmartPointer_SP_WP/","excerpt":"待续…","text":"待续…http://blog.163.com/ye_kc_lcx88/blog/static/217863346201462411215858/","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"强指针","slug":"强指针","permalink":"jingg.me/tags/强指针/"},{"name":"弱指针","slug":"弱指针","permalink":"jingg.me/tags/弱指针/"},{"name":"智能指针","slug":"智能指针","permalink":"jingg.me/tags/智能指针/"}]},{"title":"Input系统——APP事件监听及处理","slug":"InputSystem005_ExampleAPP","date":"2016-12-31T16:00:00.000Z","updated":"2017-04-27T03:20:27.088Z","comments":true,"path":"2017/01/01/InputSystem005_ExampleAPP/","link":"","permalink":"jingg.me/2017/01/01/InputSystem005_ExampleAPP/","excerpt":"InputDevicehttps://developer.android.com/reference/android/view/InputDevice.html android.support.wearable 包 http://stackoverflow.com/questions/24520240/import-android-support-wearable-cannot-be-resolved","text":"InputDevicehttps://developer.android.com/reference/android/view/InputDevice.html android.support.wearable 包 http://stackoverflow.com/questions/24520240/import-android-support-wearable-cannot-be-resolved","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"input","slug":"input","permalink":"jingg.me/tags/input/"},{"name":"input系统","slug":"input系统","permalink":"jingg.me/tags/input系统/"},{"name":"APP","slug":"APP","permalink":"jingg.me/tags/APP/"}]},{"title":"Android版本-sdk-ndk-对应关系表","slug":"Android_Version-sdk-ndk","date":"2016-12-12T04:22:33.000Z","updated":"2017-04-13T11:51:28.273Z","comments":true,"path":"2016/12/12/Android_Version-sdk-ndk/","link":"","permalink":"jingg.me/2016/12/12/Android_Version-sdk-ndk/","excerpt":"","text":"Code name Version API level Nougat 7.1 API level 25 Nougat 7.0 API level 24 Marshmallow 6.0 API level 23 Lollipop 5.1 API level 22 Lollipop 5.0 API level 21, NDK 10 KitKat 4.4 - 4.4.4 API level 19 Jelly Bean 4.3.x API level 18 Jelly Bean 4.2.x API level 17 Jelly Bean 4.1.x API level 16 Ice Cream Sandwich 4.0.3 - 4.0.4 API level 15, NDK 8 Ice Cream Sandwich 4.0.1 - 4.0.2 API level 14, NDK 7 Honeycomb 3.2.x API level 13 Honeycomb 3.1 API level 12, NDK 6 Honeycomb 3.0 API level 11 Gingerbread 2.3.3 - 2.3.7 API level 10 Gingerbread 2.3 - 2.3.2 API level 9, NDK 5 Froyo 2.2.x API level 8, NDK 4 Eclair 2.1 API level 7, NDK 3 Eclair 2.0.1 API level 6 Eclair 2.0 API level 5 Donut 1.6 API level 4, NDK 2 Cupcake 1.5 API level 3, NDK 1 (no code name) 1.1 API level 2 (no code name) 1.0 API level 1","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"jingg.me/tags/Android/"},{"name":"版本","slug":"版本","permalink":"jingg.me/tags/版本/"},{"name":"SDK","slug":"SDK","permalink":"jingg.me/tags/SDK/"},{"name":"API level","slug":"API-level","permalink":"jingg.me/tags/API-level/"},{"name":"NDK","slug":"NDK","permalink":"jingg.me/tags/NDK/"}]},{"title":"Android init.rc","slug":"Android_init_rc","date":"2016-11-25T04:22:33.000Z","updated":"2017-05-18T08:01:21.346Z","comments":true,"path":"2016/11/25/Android_init_rc/","link":"","permalink":"jingg.me/2016/11/25/Android_init_rc/","excerpt":"init.rc主要有两大元素: Actions和Service 一种是定时任务——Actions，由以下构成： on … 一种是固定顺序的任务(初始化启动，可以重启)，即Services service [ ]* …","text":"init.rc主要有两大元素: Actions和Service 一种是定时任务——Actions，由以下构成： on … 一种是固定顺序的任务(初始化启动，可以重启)，即Services service [ ]* … 以下是分别详解critical //标识设备核心服务，如果在四分钟内，退出超过四次，设备进入recovery模式disabled // 和class 一起使用时，也不会随着class一起启动，必须自己显式的用服务名启动 。在init.rc的条件中触发或者在代码中通过ctl.start来触发 // 如果该服务选项中没有disabled定义，则在init.rc中解析到这个服务的时候，会马上执行这个服务。而如果在服务的选项中增加了disabled定义， // 则该服务不会在init.rc中启动，需要我们在代码中使用以下方法来启动：property_set(“ctl.start”, “wifi_dhcpcd”);上句话的意思是， // 我要启动wifi_dhcpd这个服务了。 setenv //启动该服务时，设置环境变量 name 为valuesocket … //建立socketuser //启动该服务前，切换到username 用户group [ ]* //启动该服务前，切换到组seclabel //启动前切换到安全上下文oneshot //服务存在是不重启class //指定一个class名，所有指定相同class名的服务将可能被一起启动或停止onrestart //启动时执行一条命令(和Actions中的可选项一样)，可指定的命令如下： 以下是Triggers分别详解 //是一个字符串，被用于匹配不同种类的事件，用于触发一个动作发生 有如下trigger： boot //这是第一个在init启动时发生的trigger = //这种trigger表示，在name=value时触发。 device-added-&lt;path&gt; device-removed-&lt;path&gt; //这种trigger表示当设备节点被添加或者被移除时触发 service-exited-&lt;name&gt; //这种trigger表示当指定服务&lt;name&gt;退出时触发 以下是Command分别详解 exec [ ] //fork一个进程，执行program，避免执行内置命令，这可能会导致init卡主export // 设置一个全局变量， 这个全局变量将会被所有后面启动的进程继承ifup //bringup 网口interfaceimport //解析一个类似init.rc的配置文件，作为拓展hostname //设置hostnamechdir //切换工作目录chmod //改变模式，八进制chown chroot //改变进程运行的root目录class_start 如果没运行的话，运行class_stop 如果在运行的话，停止domainname 设置域名enable 如果该服务没有被指定禁用的话，启动这个未启动的服务。insmod //加载ko模块mkdir [mode] [owner] [group]mount [ ]restorecon [ ]restorecon_recursive [ ]setcon setenforce 0|1setprop setrlimit //Set the rlimit for a resource.setsebool //Set SELinux boolean to . may be 1|true|on or 0|false|offstart //启动一个未启动的服务stop //停止一个启动的服务symlink //创建一个符号链接sysclktz //trigger //触发另外一个时间，用于动作同步。wait [ ] //轮训是否该文件存在，如果存在，return，或者timeout时间达到时，也退出，未指定timeout，默认等5swrite //写字符串到文件中。不是追加 系统属性init.action //=当前执行的动作的action名，没有action名，即为空init.command //=当前执行的命令的action名，没有command名，即为空init.svc. //=服务名为的服务状态，可选值为(“stopped”, “running”, “restarting”) 调试notes：默认，被init进程执行的子进程 stdout和stderr都会进入/dev/null中，如果你需要调试你的程序的话，你可以使用Android logwrapper，它将会重定向stdout/stderr 到Android log 系统（你可以通过logcat导出）用法：service zip /system/bin/logwrapper /system/bin/zipgateway","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"init.rc","slug":"init-rc","permalink":"jingg.me/tags/init-rc/"}]},{"title":"Android 中同步和并发实现的几个方式","slug":"Android_sync_asyncmd","date":"2016-10-21T07:13:00.000Z","updated":"2017-05-18T07:16:38.926Z","comments":true,"path":"2016/10/21/Android_sync_asyncmd/","link":"","permalink":"jingg.me/2016/10/21/Android_sync_asyncmd/","excerpt":"","text":"1. 关键字synchronized实例方法同步/静态方法同步class Demo{ public synchronized void print(){ //实例方法 System.out.println(“print”); } public static synchronized void print2(){ //静态方法 System.out.println(“print2”); }}Demo demo1; //同一时间段只能有一个线程可以访问demo1.printDemo demo2; //可以同时访问demo1.print 和 demo2.print //同一时间段只能有一个线程可以访问demo1.print2 或者 demo2.print2 实例方法中同步块 //分为对象锁和全局的Class锁，静态方法中同步块 //只有全局锁 static synchronized方法也相当于全局锁synchronized(xxx.class) 如果{}范围相同的话synchronized方法也相当于synchronized(this) 如果{}范围相同的话 2. 类java.util.concurrent.locks.ReentrantLock （比synchronized 功能更全更灵活， 还多了锁投票，定时锁等候和中断锁）lock() 如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于休眠状态，直到获取锁tryLock() 如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false；tryLock(long timeout,TimeUnit unit) 如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false；lockInterruptibly 如果获取了锁定立即返回，如果没有获取锁定，当前线程处于休眠状态，直到或者锁定，或者当前线程被别的线程中断 异同：synchronized是在JVM层面上实现的，不但可以通过一些监控工具监控synchronized的锁定，而且在代码执行时出现异常，JVM会自动释放锁定，但是使用Lock则不行，lock是通过代码实现的，要保证锁定一定会被释放，就必须将unLock()放到finally{}中 在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态； 3. AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference:在32位操作系统中，64位的long 和 double 变量由于会被JVM当作两个分离的32位来进行操作，所以不具有原子性。而使用AtomicLong能让long的操作保持原子型。区别：和上面的类似，不激烈情况下，性能比synchronized略逊，而激烈的时候，也能维持常态。激烈的时候，Atomic的性能会优于ReentrantLock一倍左右。但是其有一个缺点，就是只能同步一个值，一段代码中只能出现一个Atomic的变量，多于一个同步无效。因为他不能在多个Atomic之间同步。 4. 特殊域变量(volatile)实现线程同步a.volatile关键字为域变量的访问提供了一种免锁机制， b.使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新， c.因此每次使用该域就要重新计算，而不是使用寄存器中的值 d.volatile不会提供任何原子操作，它也不能用来修饰final类型的变量 5. 使用局部变量实现线程同步如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本， 副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。 明天看下ThreadLocal","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"synchronized","slug":"synchronized","permalink":"jingg.me/tags/synchronized/"},{"name":"ReentrantLock","slug":"ReentrantLock","permalink":"jingg.me/tags/ReentrantLock/"}]},{"title":"Android SEpolicy策略规则","slug":"Android_SEpolicy","date":"2016-10-12T10:22:33.000Z","updated":"2017-04-27T03:23:22.522Z","comments":true,"path":"2016/10/12/Android_SEpolicy/","link":"","permalink":"jingg.me/2016/10/12/Android_SEpolicy/","excerpt":"SEAndroid中各种实体的SContext 定义介绍进程、文件/目录、服务、系统属性等SContext 定义 进程的SContext（以system_server进程为例）（对应每个进程的te文件）u:r:system_server:s0 system 494 186 system_server u表示user SELinux用户 r表示SELinux角色 system_server表示domain，该域的权限定义在策略文件system_server.te中 s0表示MLS中的级别，Android中可忽略 file和dir的SContext（以system目录为例）（在file_contexts定义）drwxr-xr-x root root u:object_r:system_file:s0 system object_r表示文件对象 system_file表示文件类型 fs_use(在fs_use定义)// to do 生成 文件系统的 SContext （在genfs_contexts定义）genfscon rootfs / u:object_r:rootfs:s0 genfscon usbfs / u:object_r:usbfs:s0 property的SContext（在property_contexts定义）* u:object_r:default_prop:s0 //默认property SContext hw. u:object_r:system_prop:s0 service的SContext（在service_contexts定义）* u:object_r:default_android_service:s0 //默认服务SContext package u:object_r:system_server_service:s0 //package 服务 （在shell中执行service list查看所有服务）","text":"SEAndroid中各种实体的SContext 定义介绍进程、文件/目录、服务、系统属性等SContext 定义 进程的SContext（以system_server进程为例）（对应每个进程的te文件）u:r:system_server:s0 system 494 186 system_server u表示user SELinux用户 r表示SELinux角色 system_server表示domain，该域的权限定义在策略文件system_server.te中 s0表示MLS中的级别，Android中可忽略 file和dir的SContext（以system目录为例）（在file_contexts定义）drwxr-xr-x root root u:object_r:system_file:s0 system object_r表示文件对象 system_file表示文件类型 fs_use(在fs_use定义)// to do 生成 文件系统的 SContext （在genfs_contexts定义）genfscon rootfs / u:object_r:rootfs:s0 genfscon usbfs / u:object_r:usbfs:s0 property的SContext（在property_contexts定义）* u:object_r:default_prop:s0 //默认property SContext hw. u:object_r:system_prop:s0 service的SContext（在service_contexts定义）* u:object_r:default_android_service:s0 //默认服务SContext package u:object_r:system_server_service:s0 //package 服务 （在shell中执行service list查看所有服务） APP的SContext （在mac_permissions.xml+seapp_contexts+xxx定义，详见 APP安全策略） APP的seinfo: 根据apk的签名决定app的seinfo(platform、default) 1. 特殊APP——system_server (因为它也是有zygote产生的，所以还是也在seapp_contexts中定义) isSystemServer=true domain=system_server // isSystemServer返回true，则domain=system_server 2. 通过user + seinfo + [name]来决定domain 和 type user=cts seinfo=* name=roidJUnitRunner domain=ctsrunner_app type=app_data_file // user 是cts，则domain=ctsrunner_app type=app_data_file CTS测试APP user=system domain=system_app type=system_app_data_file // user是 system seinfo默认是platform签名，则domain=system_app type=system_app_data_file 系统APP // (有android平台签名和system权限) user=bluetooth domain=bluetooth type=bluetooth_data_file // bluetooth user=nfc domain=nfc type=nfc_data_file // nfc user=radio domain=radio type=radio_data_file // radio user=shared_relro domain=shared_relro // shared_relro user=shell domain=shell type=shell_data_file // shell user=_isolated domain=isolated_app // _isolated user=_app seinfo=platform domain=platform_app type=app_data_file // 平台APP(有android平台签名，没有system权限) user=_app domain=untrusted_app type=app_data_file // 其他的都是第三方(untrusted_app)APP (没有Android平台签名，没有system权限) APP安全策略 APP的SContext 确定了APP domain和type ，下面就是不同类型的app domain的安全策略te文件 app.te 应用给所有APP的安全策略（这里的所有APP指的是所有由zygote产生的进程），appdomain域——APP的基域 system_server.te system_server的安全策略 ctsrunner_app.te CTS APP 的安全策略 system_app.te 系统 APP的安全策略 bluetooth.te bluetooth APP的安全策略 nfc.te nfc APP 的安全策略 radio.te radio APP的安全策略 shared_relro.te shared_relro APP的安全策略 shell.te 通过shell 启动的APP的安全策略 isolated_app.te isolated APP的安全策略 AID_ISOLATED_START (99000) ---&gt; AID_ISOLATED_END (99999). platform_app.te 第三方平台 APP的安全策略 untrusted_app.te 其他的都是第三方 APP的安全策略 APP_AID (10000) ---&gt; AID_ISOLATED_START (99000) 安全策略语法 上面都将各个实体的SContext 逐一罗列出来了，下面讲下*.te 文件语法 关键字的关键字 （有点拗口，但确实是这样的） attribute 用于指定xxx_type和domain关键字的关键字 type 用于指定domain域的关键字的关键字 typeattribute 单独将某个type和某个或多个attribute关联起来 基本语法我们再来看看最常见的权限设置语句： allow netd sysfs:file write; 1）allow：表示授权。除了allow之外，还有allowaudit、dontaudit、neverallow等； 这条语句的语法为： 2）netd：sourcetype，也叫Domain，Subject。 3）sysfs：targettype，它代表其后的file所对应的Type。 4）file：objectclass，它代表能够给Domain操作的对象。例如file、dir、socket等，Android中SecurityClass的定义在security_classes中。在Android系统中，有一些特殊的Class，如property_service，binder等。 5）write：在该类objectclass中所定义的操作，例如file类支持ioctl，read，write等操作。access_vectors中定义了所有objectclass支持的操作。 根据SELinux规范，完整的allow语句格式为： rule_name source_type target_type:class perm_set; 1）如果有多个source_type，target_type，class或perm_set，可以用&quot;{}&quot;括起来； 注意：使用allow语句的时候，可以使用下面的一些小技巧来简化命令书写； 2）&quot;~&quot;号，表示除了&quot;~&quot;以外； 3）&quot;-&quot;号，表示去除某项内容； 4）&quot;*&quot;号，表示所有内容 高级语法 对于一般的*.te文件编写，基本的语法就差不多够了，下面是高级语法，说高级语法就是相当于一个批量生成sepolicy规则的的语法，让你少些点规则 域转换(DomainTransition,简称DT) SEAndroid中，init进程的SContext为u:r:init:s0（在init.rc中使用” setcon u:r:init:s0”命令设置），而init创建的子进程显然不会也不可能拥有和init进程一样的SContext （否则根据TE，这些子进程也就在MAC层面上有了和init进程一样的权限）。那么这些子进程是怎么被打上和父进程不一样的SContex呢？ 在SELinux中，上述问题被称为DomainTransition，即某个进程的Domain切换到一个更合适的Domain中去。DomainTransition也是在安全策略文件中配置的，而且有相关的关键字。 语法: type\\_transition source\\_type target\\_type:class default\\_type 表示source_type域的进程在对target_type类型的文件进行class定义的操作时，进程会切换到default_type域中 下面我们看个域转换的例子： type_transition init shell_exec:process init_shell 这个例子表示：当init域的进程执行（process）shell_exec类型的可执行文件时，进程会从init域切换到init_shell域。 那么，哪个文件是shell_exec类型呢？从file_contexts文件能看到，/system/bin/sh的安全属性是u:object_r:shell_exec:s0， 也就是说init域的进程如果运行shell脚本的话，进程所在的域就会切换到init_shell域，这就是DomainTransition（简称DT）。 请注意，DT也是SELinux安全策略的一部分，type_transition不过只是开了一个头而已，要真正实施成功这个DT，还至少需要下面三条权限设置语句： # 首先，你得让init域的进程要能够执行shell_exec类型的文件 allow init shell_exec:file execute; # 然后，你需要告诉SELinux，允许init域的进程切换到init_shell域 allow init init_shell:process transition; # 最后，你还得告诉SELinux，域切换的入口（entrypoint）是执行shell_exec类型的文件 allow init_shell shell_exec:file entrypoint; 看起来挺麻烦，不过SELinux支持宏定义，我们可以定义一个宏，把上面4个步骤全部包含进来。在SEAndroid中，所有的宏都定义在te_macros文件中，其中和DT相关的宏定义如下： # 定义domain_trans宏，$1,$2,$3代表宏的第一个，第二个…参数 define(`domain_trans&apos;, ` allow $1 $2:file { getattr open read execute }; allow $1 $3:process transition; allow $3 $2:file { entrypoint open read execute getattr }; … … &apos;) # 定义domain_auto_trans宏，这个宏才是我们在te中直接使用的 define(`domain_auto_trans&apos;, ` # Allow the necessary permissions. domain_trans($1,$2,$3) # Make the transition occur by default. type_transition $1 $2:process $3; &apos;) 呵呵，是不是简单多了，domain_trnas宏在DT需要的最小权限的基础上还增加了一些权限，在te文件中可以直接用domain_auto_trans宏来显示声明域转换，如下： domain_auto_trans(init, shell_exec, init_shell) 类型转换(TypeTransition,简称TT) 除了DT外，还有针对Type的Transition（简称TT）。举个例子，假设目录A的SContext为u:r:dir_a，那么默认情况下， 在该目录下创建的文件的SContext就是u:r:dir_a，如果想让它的SContext发生变化，那么就需要TypeTransition。 和DT类似，TT的关键字也是type_transition，而且要顺利完成Transition，也需要申请相关权限，废话不多说了， 直接看te_macros是怎么定义TT所需的宏： # 定义file_type_trans宏，为Type Transition申请相关权限 define(`file_type_trans&apos;, ` allow $1 $2:dir ra_dir_perms; allow $1 $3:notdevfile_class_set create_file_perms; allow $1 $3:dir create_dir_perms; &apos;) # 定义file_type_auto_trans(domain, dir_type, file_type)宏 # 该宏的意思就是当domain域的进程在dir_type类型的目录创建文件时，该文件的SContext # 应该是file_type类型 define(`file_type_auto_trans&apos;, ` # Allow the necessary permissions. file_type_trans($1, $2, $3) # Make the transition occur by default. type_transition $1 $2:dir $3; type_transition $1 $2:notdevfile_class_set $3; &apos;) 栗子： file_type_auto_trans(app_domain, system_data_file, xxx_type) class集合 class// to do 权限集合 perm_set// to do 附SELinux模式切换命令 SELinux支持Disabled，Permissive，Enforce三种模式 Disabled就不用说了，此时SELinux的权限检查机制处于关闭状态； Permissive模式就是SELinux有效，但是即使你违反了它的安全策略，它让你继续运行，但是会把你违反的内容记录下来。在策略开发的时候非常有用，相当于Debug模式； Enforce模式就是你违反了安全策略的话，就无法继续操作下去。 在Eng版本使用setenforce命令，可以在Permissive模式和Enforce模式之间切换。 usage: setenforce [ Enforcing | Permissive | 1 | 0 ] -Z——查看SContext 信息的命令ls -Z // 文件目录的SContext ps -Z // 进程的SContext chcon命令——更改文件的安全属性usage: chcon &lt;SContext&gt; &lt;path&gt; restorecon命令——恢复文件原来的安全属性 当文件的安全属性在安全策略配置文件里面有定义时，使用restorecon命令，可以恢复原来的安全属性 usage: restorecon [-DFnrRv] &lt;path&gt; id 命令——确认自己的SecurityContext$ id uid=2000(shell) gid=2000(shell) groups=1007(log) context=u:r:shell:s0 # id uid=0(root) gid=0(root) groups=1007(log) context=u:r:su:s0 ####参考： http://blog.csdn.net/modianwutong/article/details/43114883 http://blog.csdn.net/zhudaozhuan/article/details/50964832","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"SEAndroid","slug":"SEAndroid","permalink":"jingg.me/tags/SEAndroid/"},{"name":"sepolicy","slug":"sepolicy","permalink":"jingg.me/tags/sepolicy/"}]},{"title":"Android JNI介绍及使用","slug":"Android_JNI_Guide","date":"2016-10-08T04:22:33.000Z","updated":"2017-04-27T03:23:38.701Z","comments":true,"path":"2016/10/08/Android_JNI_Guide/","link":"","permalink":"jingg.me/2016/10/08/Android_JNI_Guide/","excerpt":"JNI 介绍JNI是Java Native Interface的缩写，它提供了若干的API实现了Java和其他语言的通信（主要是C&amp;C++）。 JNI 类型 jni中结构体层次结构 下面是访问String的一些方法： GetStringUTFChars 将jstring转换成为UTF-8格式的char* / ReleaseStringUTFChars 释放指向UTF-8格式的char*的指针 GetStringChars 将jstring转换成为Unicode格式的char* / ReleaseStringChars 释放指向Unicode格式的char*的指针 NewStringUTF 创建一个UTF-8格式的String对象 NewString 创建一个Unicode格式的String对象 GetStringUTFLengt 获取 UTF-8格式的char*的长度 GetStringLength 获取Unicode格式的char*的长度","text":"JNI 介绍JNI是Java Native Interface的缩写，它提供了若干的API实现了Java和其他语言的通信（主要是C&amp;C++）。 JNI 类型 jni中结构体层次结构 下面是访问String的一些方法： GetStringUTFChars 将jstring转换成为UTF-8格式的char* / ReleaseStringUTFChars 释放指向UTF-8格式的char*的指针 GetStringChars 将jstring转换成为Unicode格式的char* / ReleaseStringChars 释放指向Unicode格式的char*的指针 NewStringUTF 创建一个UTF-8格式的String对象 NewString 创建一个Unicode格式的String对象 GetStringUTFLengt 获取 UTF-8格式的char*的长度 GetStringLength 获取Unicode格式的char*的长度 JNI 实现如果需要在Java中使用到native接口的话，可以使用JNI这个方式来达到目的： 1. Java侧使用方法public class AudioFlingerBinderTest extends TestCase { private static native boolean native_test_setMasterMute(); //声明native函数，都是以native_开头 static { System.loadLibrary(&quot;ctssecurity_jni&quot;); //加载jni库，该函数会找到对应的动态库，然后首先试图找到 // &quot;JNI_OnLoad&quot;函数，如果该函数存在，则调用它。 } //使用native_test_setMasterMute() ..... } 2. Java侧Android.mk编写Android.mk LOCAL_PATH:= $(call my-dir) include $(CLEAR_VARS) ... LOCAL_JNI_SHARED_LIBRARIES := libctssecurity_jni libcts_jni ... 3. JNI侧库ctssecurity_jni的Android.mkAndroid.mk------------------------------ LOCAL_PATH:= $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE := libctssecurity_jni LOCAL_MODULE_TAGS := optional LOCAL_SRC_FILES := \\ CtsSecurityJniOnLoad.cpp \\ android_security_cts_CharDeviceTest.cpp \\ ..... LOCAL_C_INCLUDES := $(JNI_H_INCLUDE) LOCAL_SHARED_LIBRARIES := libnativehelper liblog libbinder libutils libmedia libselinux libdl include $(BUILD_SHARED_LIBRARY) 4. JNI侧库ctssecurity_jni4.1 实现native函数jboolean android_security_cts_AudioFlinger_test_setMasterMute(JNIEnv* env __unused, jobject thiz __unused) { //具体实现 } or jboolean android_security_cts_AudioFlinger_test_setMasterMute(JNIEnv* env, jclass clazz) { //具体实现 } 4.2 注册native函数static JNINativeMethod gMethods[] = { { &quot;native_test_setMasterMute&quot;, &quot;()Z&quot;, (void *) android_security_cts_AudioFlinger_test_setMasterMute }, }; int register_android_security_cts_AudioFlingerBinderTest(JNIEnv* env) { jclass clazz = env-&gt;FindClass(&quot;android/security/cts/AudioFlingerBinderTest&quot;); return env-&gt;RegisterNatives(clazz, gMethods, sizeof(gMethods) / sizeof(JNINativeMethod)); } or int register_android_security_cts_AudioFlingerBinderTest(JNIEnv* env) { int res = jniRegisterNativeMethods(env, &quot;android/security/cts/AudioFlingerBinderTest&quot;, gMethods, NELEM(gMethods)); LOG_FATAL_IF(res &lt; 0, &quot;Unable to register native methods.&quot;); return res; } 4.3 jni库的主函数/加载入口：#include &lt;jni.h&gt; #include &lt;stdio.h&gt; #include “xxx.h” jint JNI_OnLoad(JavaVM *vm, void *reserved) { JNIEnv *env = NULL; if (vm-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_4) != JNI_OK) { return JNI_ERR; } if (register_android_security_cts_AudioFlingerBinderTest(env)) { return JNI_ERR; } return JNI_VERSION_1_4; }","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"JNI","slug":"JNI","permalink":"jingg.me/tags/JNI/"},{"name":"native调用","slug":"native调用","permalink":"jingg.me/tags/native调用/"}]},{"title":"Java中创建（实例化）对象的五种方式 及 基本数据类型","slug":"Lang_Java_create_class","date":"2016-09-30T04:22:33.000Z","updated":"2017-05-19T07:22:56.525Z","comments":true,"path":"2016/09/30/Lang_Java_create_class/","link":"","permalink":"jingg.me/2016/09/30/Lang_Java_create_class/","excerpt":"","text":"首先，Java中创建（实例化）对象的五种方式，如下1、用new语句创建对象，这是最常见的创建对象的方法。2、通过工厂方法返回对象，如：String str = String.valueOf(23);3、运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。如：Object obj = Class.forName(“java.lang.Object”).newInstance();4、调用对象的clone()方法。5、通过I/O流（包括反序列化），如运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。 示例package org.whb.test.demo724; /* * 测试Cloneable接口的使用 * 包含第一种和第三种方法clone() * 不过要注意在clone()中深复制和潜复制的理解 * 实例化对象 */ class Person implements Cloneable{ private String name; private int age; public Person( String name,int age) { this.name = name; this.age = age; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name){ this.name =name; } @Override public Object clone() throws CloneNotSupportedException { // TODO Auto-generated method stub return super.clone(); } @Override public String toString() { // TODO Auto-generated method stub return &quot;姓名是：&quot;+name+&quot;; 年龄是：&quot;+age; } } public class TestClone{ public static void main(String[] args){ Person p1 = new Person(&quot;王豪博&quot;,25); System.out.println(p1); Person p2 =null; try { p2 = (Person)p1.clone(); } catch (CloneNotSupportedException e) { // TODO Auto-generated catch block e.printStackTrace(); } p2.setName(&quot;春香&quot;); p2.setAge(24); System.out.println(p2); } } /* * 通过反射对对象进行初始化 * 注意必须有无参数的Constructor * 实例化Class类然后调用newInstance()方法 */ package org.whb.test.demo715; class Person{ private int age; private String name; public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String toString(){ return &quot;年龄是：&quot;+this.age+&quot; 姓名是：&quot;+this.name; } } public class TestClass { public static void main(String[] args){ Class&lt; ?&gt; c1 = null; try{ c1 = Class.forName(&quot;org.whb.test.demo715.Person&quot;); }catch(ClassNotFoundException e){ e.printStackTrace(); } Person p1 = null; try { p1 =(Person)c1.newInstance(); } catch (InstantiationException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (IllegalAccessException e) { // TODO Auto-generated catch block e.printStackTrace(); } p1.setAge(12); p1.setName(&quot;haobo&quot;); System.out.println(p1); } } /* * 对象的序列化和反序列化测试类. *1、序列化是干什么的？ 简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自 己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。 *2、什么情况下需要序列化 a）当你想把的内存中的对象状态保存到一个文件中或者数据库中时候； b）当你想用套接字在网络上传送对象的时候； c）当你想通过RMI传输对象的时候； * *3、相关注意事项 a）序列化时，只对对象的状态进行保存，而不管对象的方法； b）当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口； c）当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化； d）并非所有的对象都可以序列化，,至于为什么不可以，有很多原因了,比如： 1.安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行rmi传输 等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的。 2.资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分 配，而且，也是没有必要这样实现。 */ package org.whb.test.demo724; import java.io.*; import java.util.Date; public class ObjectSaver { public static void main(String[] args) throws Exception { ObjectOutputStream out = new ObjectOutputStream (new FileOutputStream(&quot;D:/objectFile.swf&quot;)); //序列化对象 Customer customer = new Customer(&quot;haobo&quot;, 24); out.writeObject(&quot;你好!&quot;); out.writeObject(new Date()); out.writeObject(customer); out.writeInt(123); //写入基本类型数据 out.close(); //反序列化对象 ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;D:/objectFile.swf&quot;)); System.out.println(&quot;obj1=&quot; + (String) in.readObject()); System.out.println(&quot;obj2=&quot; + (Date) in.readObject()); Customer obj3 = (Customer) in.readObject(); System.out.println(&quot;obj3=&quot; + obj3); int obj4 = in.readInt(); System.out.println(&quot;obj4=&quot; + obj4); in.close(); } } class Customer implements Serializable { private static final long serialVersionUID = -88175599799432325L; private String name; private int age; public Customer(String name, int age) { this.name = name; this.age = age; } public String toString() { return &quot;name=&quot; + name + &quot;, age=&quot; + age; } } /* 打印输出 * obj1=你好! * obj2=Sat Jul 24 21:18:19 CST 2010 * obj3=name=haobo, age=24 * obj4=123 */ 附（C++中实例化对象）A a = new A; 和 A a=new A(); （推荐使用这个）都是调用A类的默认构造函数，指针a在函数栈中，指向内容在堆中。但是如果单独声明一个A 类变量，如：A a；则调用的是默认构造函数，对象a整个在函数栈中。但是不能写成 A a(); 来调用默认构造函数！！因为这种形式会被识别成一个：名称为a的不接受任何参数，返回值为A类型的函数！","categories":[{"name":"Java","slug":"Java","permalink":"jingg.me/categories/Java/"}],"tags":[{"name":"reflect","slug":"reflect","permalink":"jingg.me/tags/reflect/"},{"name":"class","slug":"class","permalink":"jingg.me/tags/class/"},{"name":"instance","slug":"instance","permalink":"jingg.me/tags/instance/"}]},{"title":"Android中Vector、ArrayList、LinkedList和HashMap","slug":"Android_vector_list","date":"2016-09-19T04:22:33.000Z","updated":"2017-05-19T07:23:10.603Z","comments":true,"path":"2016/09/19/Android_vector_list/","link":"","permalink":"jingg.me/2016/09/19/Android_vector_list/","excerpt":"","text":"先说：Iterator、Iterable、Collection 接口public interface Iterator接口： 包含hasNext next remove三个方法public interface Iterable 迭代接口： 包含一个iterator() 方法public interface Collection extends Iterable：继承Iterable接口(Iterable是接口，使用的关键字是extends，因为Collection也是接口),并包含add remove clear等操作方法；contains equals isEmpty 等检测方法；size iterator toArray工具方法。 AbstractCollection 集合的类化，抽象类： 有添加删除特性的抽象类 public abstract class AbstractCollection implements Collection {} 需要实现： public boolean add(E object) {throw} 迭代接口iterator(); （实例化一个实现接口Iterator的类，并作为返回值即可） public abstract int size(); 再来看接口 List 和 ListIteratorpublic interface List extends Collection {} List在Collection的基础上添加了index的特性。 接口重写：add、clear public void add(int location, E object); public E get(int location); public int indexOf(Object object); public int lastIndexOf(Object object); //最后一次出现的index public ListIterator listIterator(); //见ListIterator public ListIterator listIterator(int location); //从指定位置开始迭代 public E set(int location, E object); public List subList(int start, int end); public interface ListIterator extends Iterator {} 在Iterator基础上添加了连贯性的特点 除了add hasNext remove 添加了hasPrevious nextIndex(); previous previousIndex(); set(E object); 等操作 看看List的类化——AbstractListpublic abstract class AbstractList extends AbstractCollection implements List {} 集Collection和List于一身的抽象List类 ArrayList类public class ArrayList extends AbstractList implements Cloneable, Serializable, RandomAccess {} Object[] array; 数组进行存储元素 Vector类 （带同步功能的List）public class Vector extends AbstractList implements List, RandomAccess, Cloneable, Serializable { ……………………………….. LinkedList类 （双链表，队列特性）public class LinkedList extends AbstractSequentialList implements List, Deque, Queue, Cloneable, Serializable { ………………………………… HashMap类Map接口 public interface Map 包含k-v 对的集合","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"Vector","slug":"Vector","permalink":"jingg.me/tags/Vector/"},{"name":"ArrayList","slug":"ArrayList","permalink":"jingg.me/tags/ArrayList/"},{"name":"LinkedList","slug":"LinkedList","permalink":"jingg.me/tags/LinkedList/"},{"name":"HashMap","slug":"HashMap","permalink":"jingg.me/tags/HashMap/"}]},{"title":"Java中父类和子类可以同时实现一个接口，有什么作用？","slug":"Lang_Java_sameInterface","date":"2016-09-19T04:22:33.000Z","updated":"2017-05-19T07:22:38.987Z","comments":true,"path":"2016/09/19/Lang_Java_sameInterface/","link":"","permalink":"jingg.me/2016/09/19/Lang_Java_sameInterface/","excerpt":"","text":"看下面的代码片段，父类和子类都实现了接口A Class Base `implements A` Class Sub extends Base `implements A` 就是说子类Sub实现A有什么用？ 我原来认为是多余的。实际上， 子类再次实现父类实现的接口是为了强制子类(SUB)重写父类(BASE)中实现的所有接口中的方法。 现实中的例子：父类：public abstract class AbstractList extends AbstractCollection implements List {} 子类：public class Vector extends AbstractList implements List, RandomAccess, Cloneable, Serializable {}","categories":[{"name":"Java","slug":"Java","permalink":"jingg.me/categories/Java/"}],"tags":[]},{"title":"Android Pid/Tid/UserId/PackageName/ProcessName/shareUserId/签名","slug":"Android_uid_pid_appid","date":"2016-08-31T06:43:33.000Z","updated":"2017-05-18T06:27:05.598Z","comments":true,"path":"2016/08/31/Android_uid_pid_appid/","link":"","permalink":"jingg.me/2016/08/31/Android_uid_pid_appid/","excerpt":"这篇博文只能算是笔记了，比较杂。 Pid : Linux 进程IDTid : Linux 线程ID，或者任务IDUID : Android中的UID不同于Linux中的UID，Linux中UID是针对多用户操作系统中用于区分用户的；而Android中的UID是分配给各个进程使用，用来做权限管理的。userID : Android自从Android 4.2.2 之后就有支持多用户的拓展，只不过现在只有user 只有一个 = 0，故userID = 0。AppID : 单用户时和UID值是一样的。shareUserId : 拥有同一个UID的多个APK可以配置成运行在同一个进程中. 所以默认就是可以互相访问任意数据. 也可以配置成运行成不同的进程, 同时可以访问其他APK的数据目录下的数据库和文件. 就像访问本程序的数据一样. e.g. android:sharedUserId=”android.uid.system” “android.uid.phone” “android.uid.bluetooth” “android.uid.shell” “android.uid.calendar” “android.uid.shared” “android.media” “android.uid.systemui” e.g. android:sharedUserId=&quot;com.rainwii.share&quot; 签名 : 1. Android 标准签名为platform media shared testkey/releasekey； 2. 第三方签名 可以在源码的/build/target/product/security里面看到对应的密钥，其中shared.pk8代表私钥，shared.x509.pem公钥，一定是成对出现的。 LOCAL_CERTIFICATE : 配置应用使用什么签名 platform media shared 或者第三方签名 presigned， 默认配置的话使用testkey/releasekey . 注：shareUserID一样的，签名也必须相同","text":"这篇博文只能算是笔记了，比较杂。 Pid : Linux 进程IDTid : Linux 线程ID，或者任务IDUID : Android中的UID不同于Linux中的UID，Linux中UID是针对多用户操作系统中用于区分用户的；而Android中的UID是分配给各个进程使用，用来做权限管理的。userID : Android自从Android 4.2.2 之后就有支持多用户的拓展，只不过现在只有user 只有一个 = 0，故userID = 0。AppID : 单用户时和UID值是一样的。shareUserId : 拥有同一个UID的多个APK可以配置成运行在同一个进程中. 所以默认就是可以互相访问任意数据. 也可以配置成运行成不同的进程, 同时可以访问其他APK的数据目录下的数据库和文件. 就像访问本程序的数据一样. e.g. android:sharedUserId=”android.uid.system” “android.uid.phone” “android.uid.bluetooth” “android.uid.shell” “android.uid.calendar” “android.uid.shared” “android.media” “android.uid.systemui” e.g. android:sharedUserId=&quot;com.rainwii.share&quot; 签名 : 1. Android 标准签名为platform media shared testkey/releasekey； 2. 第三方签名 可以在源码的/build/target/product/security里面看到对应的密钥，其中shared.pk8代表私钥，shared.x509.pem公钥，一定是成对出现的。 LOCAL_CERTIFICATE : 配置应用使用什么签名 platform media shared 或者第三方签名 presigned， 默认配置的话使用testkey/releasekey . 注：shareUserID一样的，签名也必须相同 所有运行的App进程信息list： mActivityManager.getRunningAppProcesses()可以使用for 循环来解析 ps信息———UID PID PPID VSIZE RSS WCHAN PC package nameu0_a324 15713 231 1549320 79328 ffffffff 00000000 S com.china_liantong.sgtest Uid Pid Tid 及PackageName：Uid = Binder.getCallingUid()； //返回当前进程Uid或者远程调用进程的Uid //eg:10324Uid = context.getApplicationContext().getApplicationInfo().uid; //eg:10324Uid = android.os.Process.myUid(); //eg:10324Pid = android.os.Process.myPid(); //eg:15713Tid = android.os.Process.myTid(); 线程ID，一般情况都是单线程应该 == Pid ？？？ //15713 PackageName = context.getPackageName(); //com.china_liantong.sgtestPackageName = AppGlobals.getPackageManager().getNameForUid(Uid); //com.china_liantong.sgtest (使用限制：不在sdk中，不能在外部apk开始中使用)PackageName = context.getPackageManager().getNameForUid(Uid); //com.china_liantong.sgtest UserId = 如果支持多用户：Uid/100000 否则：0（一般都是0） 高六位AppId = Uid % 100000 即AppId 是Uid 的低五位 //因为user=0, UID&lt;100000, 所以APPID=Uid （范围Process.FIRST_APPLICATION_UID=10000—-Process.LAST_APPLICATION_UID=19999） Uid： //10324 如果支持多用户的话（一般userId 都是0，所以Uid = AppId） UserId * 100000 + (AppId % 100000); 否则 appId Gid： //固定值9997 如果系统支持多用户的话： userId*100000 + 9997 否则 9997 uid &lt; 10000 系统进程 root system install keystore logd shell dhcp radio //个人见解uid &gt;= 10000 有多用户的概念设计保留，但是目前userid都是=0 uid = userid100000 + appid //个人见解 10000~99999 给user 0 分配的UID = 100000 0 + AppID = AppID，所以单用户时uid=AppID 100000~999999 给user 1 分配的UID … UID值设定（系统核心进程的UID是固定的，其他应用的UID是在安装时随机生成的userID * 100000 + AppID ） appID=10000-99999 细分： application appid: [10000, 19999] shared application appid: [50000, 59999] isolated appid: [99000, 99999] ROOT_UID = 0;//Java层系统 ——“zygote”SYSTEM_UID = 1000; //shareId//Java层系统应用，指定UIDPHONE_UID = 1001;BLUETOOTH_UID = 1002; //Bluetooth service process.SHELL_UID = 2000;LOG_UID = 1007;WIFI_UID = 1010; //WIFI supplicant processMEDIA_UID = 1013; //mediaserver process.DRM_UID = 1019; //DRM process.SDCARD_RW_GID = 1015;VPN_UID = 1016; //the group that controls VPN services.NFC_UID = 1027; //NFC service process.MEDIA_RW_GID = 1023; //internal media storage.PACKAGE_INFO_GID = 1032; //installed package detailsSHELL_UID = 2000; //user shell. //应用程序UID范围FIRST_APPLICATION_UID = 10000;LAST_APPLICATION_UID = 19999;//fully isolated sandboxed processes UID范围FIRST_ISOLATED_UID = 99000;LAST_ISOLATED_UID = 99999; packages.list pkgName userId debugFlag dataPath固定UID的应用android 1000 0 /data/system platform 3002,3001,1028,1015,3003 //UID= system = 1000com.android.settings 1000 0 /data/data/com.android.settings platform 3002,3001,1028,1015,3003 //android:sharedUserId=”android.uid.system” platform签名com.android.providers.settings 1000 0 /data/data/com.android.providers.settings platform 3002,3001,1028,1015,3003 //android:sharedUserId=”android.uid.system” platform签名com.android.inputdevices 1000 0 /data/data/com.android.inputdevices platform 3002,3001,1028,1015,3003 //android:sharedUserId=”android.uid.system” platform签名com.android.server.telecom 1000 0 /data/data/com.android.server.telecom platform 3002,3001,1028,1015,3003 //android:sharedUserId=”android.uid.system” platform签名com.android.keychain 1000 0 /data/data/com.android.keychain platform 3002,3001,1028,1015,3003 //android:sharedUserId=”android.uid.system” platform签名com.android.location.fused 1000 0 /data/data/com.android.location.fused platform 3002,3001,1028,1015,3003 //android:sharedUserId=”android.uid.system” platform签名com.fiship.cibn 1000 0 /data/data/com.fiship.cibn platform 3002,3001,1028,1015,3003 //android:sharedUserId=”android.uid.system” platform签名 com.android.phone 1001 0 /data/data/com.android.phone platform 1028,1015,3002,3001,3003 //android:sharedUserId=”android.uid.phone” platform签名com.android.providers.telephony 1001 0 /data/data/com.android.providers.telephony platform 1028,1015,3002,3001,3003 //android:sharedUserId=”android.uid.phone” platform签名 com.android.bluetooth 1002 0 /data/data/com.android.bluetooth platform 3003,3002,3001,1028,1015,3005,1016,3008 //android:sharedUserId=”android.uid.bluetooth” platform签名 com.android.shell 2000 0 /data/data/com.android.shell platform 3002,1028,1015,1023,3008 //android:sharedUserId=”android.uid.shell” platform签名 //未指定UID应用 com.android.providers.calendar 10000 0 /data/data/com.android.providers.calendar default 3003,1028,1015 //android:sharedUserId=”android.uid.calendar” 无指定签名 com.android.contacts 10001 0 /data/data/com.android.contacts default 3003,1028,1015 //android:sharedUserId=”android.uid.shared” share签名com.android.providers.contacts 10001 0 /data/data/com.android.providers.contacts default 3003,1028,1015 //android:sharedUserId=”android.uid.shared” share签名com.android.providers.userdictionary 10001 0 /data/data/com.android.providers.userdictionary default 3003,1028,1015 //android:sharedUserId=”android.uid.shared” share签名 com.android.defcontainer 10002 0 /data/data/com.android.defcontainer platform 1028,1015,1023,2001,1035 com.android.providers.media 10003 0 /data/data/com.android.providers.media default 1028,1015,1023,1024,2001,3003,3007 //android:sharedUserId=”android.media” media签名com.android.providers.downloads 10003 0 /data/data/com.android.providers.downloads default 1028,1015,1023,1024,2001,3003,3007 //android:sharedUserId=”android.media” media签名com.android.providers.downloads.ui 10003 0 /data/data/com.android.providers.downloads.ui default 1028,1015,1023,1024,2001,3003,3007 //android:sharedUserId=”android.media” media签名 com.android.externalstorage 10004 0 /data/data/com.android.externalstorage platform 1028,1015,1023com.android.proxyhandler 10005 0 /data/data/com.android.proxyhandler platform 3003com.android.sharedstoragebackup 10006 0 /data/data/com.android.sharedstoragebackup platform 1028,1015,1023com.android.systemui 10007 0 /data/data/com.android.systemui platform 1028,1015,1035,3002,3001,3006 //android:sharedUserId=”android.uid.systemui” 未绑定UID platform签名com.android.vpndialogs 10008 0 /data/data/com.android.vpndialogs platform nonecom.android.browser 10009 0 /data/data/com.android.browser default 3003,1028,1015com.android.calendar 10010 0 /data/data/com.android.calendar default 3003com.android.captiveportallogin 10011 0 /data/data/com.android.captiveportallogin platform 3003com.android.certinstaller 10012 0 /data/data/com.android.certinstaller platform none //platform签名com.android.deskclock 10013 0 /data/data/com.android.deskclock default 1028com.android.documentsui 10014 0 /data/data/com.android.documentsui platform none //platform签名com.android.inputmethod.latin 10015 0 /data/data/com.android.inputmethod.latin default 1028,1015com.android.launcher 10016 0 /data/data/com.android.launcher default none //share签名，与contact 有交互com.coocaa.multiscreenservice 10017 0 /data/data/com.coocaa.multiscreenservice platform 3003,1028,1015com.android.music 10018 0 /data/data/com.android.music default 3003,1028,1015com.android.pacprocessor 10019 0 /data/data/com.android.pacprocessor platform 3003com.android.packageinstaller 10020 0 /data/data/com.android.packageinstaller platform 1028com.svox.pico 10021 0 /data/data/com.svox.pico default 1028,1015com.android.printspooler 10022 0 /data/data/com.android.printspooler default nonecom.android.provision 10023 0 /data/data/com.android.provision platform nonecom.android.quicksearchbox 10024 0 /data/data/com.android.quicksearchbox default 3003com.android.webview 10025 0 /data/data/com.android.webview default none 附（缩写）： PKCS：Public-Key Cryptography Standards (PKCS) ，公钥加密标准PKCS#8：定义了保存private key信息的标准语法，用来保存private keys。PKCS#8 有两个版本，加密的和非加密的。","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"APK反编译，APK签名","slug":"APK反编译，APK签名","permalink":"jingg.me/tags/APK反编译，APK签名/"}]},{"title":"Android 杂项","slug":"Android_Others","date":"2016-08-08T07:13:00.000Z","updated":"2017-05-18T08:04:11.885Z","comments":true,"path":"2016/08/08/Android_Others/","link":"","permalink":"jingg.me/2016/08/08/Android_Others/","excerpt":"","text":"命令行启动jar包export CLASSPATH=/system/framework/sg.jartrap “” HUPexec app_process /system/bin com.china_liantong.commands.SGCmdToolManager systemtask exec “ping -c 1 192.168.0.1” exec app_process /system/bin com.china_liantong.commands.SGCmdToolManager systemtask exec “ping -c 1 192.168.0.1” 获取包名String callingApp = context.getPackageManager().getNameForUid(Binder.getCallingUid());context.getPackageName 区别 sendBroadcast &amp; BroadcastReceiverMainActivity.javapublic class MainActivity extends Activity { private static final String MY_ACTION = “com.android.notification.MY_ACTION”; public void onCreate(Bundle savedInstanceState) { btn.setOnClickListener(listener); } private OnClickListener listener = new OnClickListener() { @Override public void onClick(View v) { // 实例化Intent Intent intent = new Intent(); // 设置Intent action属性 intent.setAction(MY_ACTION); // 发起广播 sendBroadcast(intent); } }} MyReceiver.javapublic class MyReceiver extends BroadcastReceiver{ @Override public void onReceive(Context context, Intent intent) { // 实例化Intent Intent i = new Intent(); // 在新的任务中启动Activity i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); // 设置Intent启动的组件名称 i.setClass(context, SecondActivity.class); // 启动Activity显示通知 context.startActivity(i); }} SecondActivity.javapublic class SecondActivity extends Activity { public void onCreate(Bundle savedInstanceState) { } } AndroidManifest.xml&lt;?xml version=”1.0” encoding=”utf-8”?&gt; 屏幕超时休眠配置：packages/apps/Settings/res/values/arrays.xml //菜单项配置 frameworks/base/packages/SettingsProvider/res/values/defaults.xml // 默认值配置Lollipop/device/rockchip/common/overlay_screenoff/frameworks/base/packages/SettingsProvider/res/values/defaults.xml //默认值配置 adb connect 提示 unable to connect to解决方法使用ADB 连接Android设备时，提示连接失败，在Android设备中执行以下命令，重试 setprop service.adb.tcp.port 5555stop adbdstart adbd","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[]},{"title":"Android 布局","slug":"Android_Layout","date":"2016-08-08T07:00:13.000Z","updated":"2017-05-18T07:00:50.060Z","comments":true,"path":"2016/08/08/Android_Layout/","link":"","permalink":"jingg.me/2016/08/08/Android_Layout/","excerpt":"","text":"layout_gravity 和 gravitylayout_gravity 表示本组件自身在父组件中的位置gravity 表示本组件的子组件在组件中的位置","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"layout","slug":"layout","permalink":"jingg.me/tags/layout/"},{"name":"UI","slug":"UI","permalink":"jingg.me/tags/UI/"}]},{"title":"Sqlite","slug":"Sqlite_operate","date":"2016-07-28T11:11:33.000Z","updated":"2017-05-18T06:59:10.731Z","comments":true,"path":"2016/07/28/Sqlite_operate/","link":"","permalink":"jingg.me/2016/07/28/Sqlite_operate/","excerpt":"","text":"Sqlite3 在Android shell中操作adb shellcd /data/data/com.android.providers.securityguard/databasessqlite3 securityguard.db.tableselect * from SystemTaskPerm; INSERT INTO SystemTaskPerm (id, ‘packagename’, ‘cmd’, ‘args’, ‘reserved’, auth) VALUES (4, ‘com.a.b’, ‘ip’ , ‘’, ‘’, 1);","categories":[{"name":"sqlite","slug":"sqlite","permalink":"jingg.me/categories/sqlite/"}],"tags":[{"name":"db","slug":"db","permalink":"jingg.me/tags/db/"},{"name":"sqlite","slug":"sqlite","permalink":"jingg.me/tags/sqlite/"}]},{"title":"Java语言","slug":"Lang_Java","date":"2016-05-28T04:22:33.000Z","updated":"2017-05-18T07:48:30.301Z","comments":true,"path":"2016/05/28/Lang_Java/","link":"","permalink":"jingg.me/2016/05/28/Lang_Java/","excerpt":"","text":"","categories":[{"name":"Java","slug":"Java","permalink":"jingg.me/categories/Java/"}],"tags":[]},{"title":"C++的类型转换——隐式、显式转换(xxx_cast)","slug":"Lang_CPP_xxx_cast","date":"2016-05-28T04:22:33.000Z","updated":"2017-04-27T03:20:19.052Z","comments":true,"path":"2016/05/28/Lang_CPP_xxx_cast/","link":"","permalink":"jingg.me/2016/05/28/Lang_CPP_xxx_cast/","excerpt":"第一部分. 隐式类型转换算数运算float + int =&gt; float 、 赋值int = float、传参、返回值 第二部分.显式类型转换C风格 (type) value C++风格 static_cast、dynamic_cast、reinterpret_cast和const_cast","text":"第一部分. 隐式类型转换算数运算float + int =&gt; float 、 赋值int = float、传参、返回值 第二部分.显式类型转换C风格 (type) value C++风格 static_cast、dynamic_cast、reinterpret_cast和const_cast static_cast (expression)该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性，如下几种用法： a. 用于类层次结构中基类和子类之间指针或引用的转换。 进行上行转换（把子类的指针或引用转换成基类表示）是安全的； 进行下行转换（把基类指针或引用转换成子类指针或引用）时，由于没有动态类型检查，所以是不安全的。 b. 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。 c. 把void指针转换成目标类型的指针(不安全!!) e. 把任何类型的表达式转换成void类型。 注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。 来源：为什么需要static_cast强制转换？ 情况1：void指针-&gt;其他类型指针 情况2：改变通常的标准转换 情况3：避免出现可能多种转换的歧义 dynamic_cast (expression)该运算符把expression转换成type-id类型的对象。Type-id必须是类的指针、类的引用或者void *；如果type-id是类指针类型，那么expression也必须是一个指针，如果type-id是一个引用，那么expression也必须是一个引用。 dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。 class Base{ public: int m_iNum; virtual void foo(); }; class Derived:public Base{ public: char *m_szName[100]; }; void func(Base *pb){ //pb可能是Base or Derived Derived *pd1 = static_cast&lt;Derived *&gt; (pb); Derived *pd2 = dynamic_cast&lt;Derived *&gt; (pb); } 在上面的代码段中，如果pb实际指向一个Derived类型的对象，pd1和pd2是一样的，并且对这两个指针执行Derived类型的任何操作都是安全的； 如果pb实际指向的是一个Base类型的对象，那么pd1将是一个指向该对象的指针，对它进行Derived类型的操作将是不安全且非法的（如访问m_szName），而pd2将是一个空指针(即0，因为dynamic_cast失败)。 另外要注意： dynamic_cast 转换时Base要有虚函数，否则会编译出错；static_cast则没有这个限制。这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表（关于虚函数表的概念，详细可见&lt;Inside c++ object model&gt;）中，只有定义了虚函数的类才有虚函数表，没有定义虚函数的类是没有虚函数表的。 dynamic_cast还支持交叉转换（cross cast）。如下代码所示。 class Base { public: int m_iNum; virtual void f(){} }; class Derived1 : public Base{ }; class Derived2 : public Base { }; void foo() { Derived1 *pd1 = new Drived1(); pd1-&gt;m_iNum = 100; Derived2 *pd2 = static_cast&lt;Derived2 *&gt;(pd1); //Compile error Derived2 *pd2 = dynamic_cast&lt;Derived2 *&gt;(pd1); //pd2 is NULL delete pd1; } 在函数foo中，使用static_cast进行转换是不被允许的，将在编译时出错；而使用 dynamic_cast的转换则是允许的，结果是空指针。 来源：为什么需要dynamic_cast强制转换？ 简单的说，当无法使用virtual函数的时候 reinterpret_cast (expression)是C++中强制类型转换符，操作符修改了操作数类型，但仅仅是重新解释了给出的对象的比特模型而没有进行二进制转换。eg: void *p ===&gt; int p type-id必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，再把该整数转换成原类型的指针，还可以得到原先的指针值）。 reinterpret_cast是为了映射到一个完全不同类型的意思，这个关键词在我们需要把类型映射回原有类型时用到它。 const_cast (expression)该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。 常量指针被转化成非常量指针，并且仍然指向原来的对象； 常量引用被转换成非常量引用，并且仍然指向原来的对象； 常量对象被转换成非常量对象。 Voiatile和const类试。举如下一例： class B{ public: int m_iNum; } void foo(){ const B b1; b1.m_iNum = 100; //comile error B b2 = const_cast&lt;B&gt;(b1); // 去掉const 属性 b2. m_iNum = 200; //fine } 上面的代码编译时会报错，因为b1是一个常量对象，不能对它进行改变； 使用const_cast把它转换成一个非常量对象，就可以对它的数据成员任意改变。注意：b1和b2是两个不同的对象。 比较static_cast Vs. reinterpret_castreinterpret_cast是为了映射到一个完全不同类型的意思，这个关键词在我们需要把类型映射回原有类型时用到它。我们映射到的类型仅仅是为了故弄玄虚和其他目的，这是所有映射中最危险的。(这句话是C++编程思想中的原话) static_cast 和 reinterpret_cast 操作符修改了操作数类型。它们不是互逆的； static_cast 在编译时使用类型信息执行转换，在转换执行必要的检测(诸如指针越界计算, 类型检查). 其操作数相对是安全的。另一方面；reinterpret_cast 仅仅是重新解释了给出的对象的比特模型而没有进行二进制转换，例子如下： int n=9; double d=static_cast &lt; double &gt; (n); 上面的例子中, 我们将一个变量从 int 转换到 double。这些类型的二进制表达式是不同的。 要将整数 9 转换到 双精度整数 9，static_cast 需要正确地为双精度整数 d 补足比特位。其结果为 9.0。而reinterpret_cast 的行为却不同: int n=9; double d=reinterpret_cast&lt;double &amp; &gt; (n); 这次, 结果有所不同. 在进行计算以后, d 包含无用值. 这是因为 reinterpret_cast 仅仅是复制 n 的比特位到 d, 没有进行必要的分析. 因此, 你需要谨慎使用 reinterpret_cast. C++primer第五章里写了编译器隐式执行任何类型转换都可由static_cast显示完成;reinterpret_cast通常为操作数的位模式提供较低层的重新解释 1、C++中的static_cast执行非多态的转换，用于代替C中通常的转换操作。因此，被做为隐式类型转换使用。比如： int i; float f = 166.7f; i = static_cast&lt;int&gt;(f); 此时结果，i的值为166。 2、C++中的reinterpret_cast主要是将数据从一种类型的转换为另一种类型。所谓“通常为操作数的位模式提供较低层的重新解释”也就是说将数据以二进制存在形式的重新解释。比如： int i; char *p = &quot;This is a example.&quot;; i = reinterpret_cast&lt;int&gt;(p); 此时结果，i与p的值是完全相同的。reinterpret_cast的作用是说将指针p的值以二进制（位模式）的方式被解释为整型，并赋给i，一个明显的现象是在转换前后没有数位损失。 C++的类型转换明显比C里面的用()的类型转换要严谨很多。首先，C++样式的类型转换编写 的代码更容易维护，想想看，只要搜索“static_cast”，就可以找出代码中所有使用了静态转换的代码，比C里面五花八门的 (long) (long*) (double )好找多了吧。另外，reinterpret_cast，看字面意思就知道，是保持二进制位不变，用另一种格式来重新解释，我们也知道计算机里面只有 bit,到底代表什么类型，整形还是浮点型，全在于应用程序怎么解释每一个bit，reinterpret_cast给了我们这么一个机会。而C里面要想 二进制重解释，你要么拷贝内存，要么还是用()来强制类型转换，某些特定情况下，()强制转换其实是二进制的重解释，毫无疑问，C风格的转换会让代码变得 难懂。","categories":[{"name":"C++","slug":"C","permalink":"jingg.me/categories/C/"}],"tags":[{"name":"类型转换","slug":"类型转换","permalink":"jingg.me/tags/类型转换/"},{"name":"static_cast","slug":"static-cast","permalink":"jingg.me/tags/static-cast/"},{"name":"dynamic_cast","slug":"dynamic-cast","permalink":"jingg.me/tags/dynamic-cast/"},{"name":"reinterpret_cast","slug":"reinterpret-cast","permalink":"jingg.me/tags/reinterpret-cast/"},{"name":"const_cast","slug":"const-cast","permalink":"jingg.me/tags/const-cast/"}]},{"title":"C++的类型转换——隐式、显式转换(xxx_cast)","slug":"Lang_C","date":"2016-05-28T04:22:33.000Z","updated":"2017-04-27T03:20:19.052Z","comments":true,"path":"2016/05/28/Lang_C/","link":"","permalink":"jingg.me/2016/05/28/Lang_C/","excerpt":"第一部分. 隐式类型转换算数运算float + int =&gt; float 、 赋值int = float、传参、返回值 第二部分.显式类型转换C风格 (type) value C++风格 static_cast、dynamic_cast、reinterpret_cast和const_cast","text":"第一部分. 隐式类型转换算数运算float + int =&gt; float 、 赋值int = float、传参、返回值 第二部分.显式类型转换C风格 (type) value C++风格 static_cast、dynamic_cast、reinterpret_cast和const_cast static_cast (expression)该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性，如下几种用法： a. 用于类层次结构中基类和子类之间指针或引用的转换。 进行上行转换（把子类的指针或引用转换成基类表示）是安全的； 进行下行转换（把基类指针或引用转换成子类指针或引用）时，由于没有动态类型检查，所以是不安全的。 b. 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。 c. 把void指针转换成目标类型的指针(不安全!!) e. 把任何类型的表达式转换成void类型。 注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。 来源：为什么需要static_cast强制转换？ 情况1：void指针-&gt;其他类型指针 情况2：改变通常的标准转换 情况3：避免出现可能多种转换的歧义 dynamic_cast (expression)该运算符把expression转换成type-id类型的对象。Type-id必须是类的指针、类的引用或者void *；如果type-id是类指针类型，那么expression也必须是一个指针，如果type-id是一个引用，那么expression也必须是一个引用。 dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。 class Base{ public: int m_iNum; virtual void foo(); }; class Derived:public Base{ public: char *m_szName[100]; }; void func(Base *pb){ //pb可能是Base or Derived Derived *pd1 = static_cast&lt;Derived *&gt; (pb); Derived *pd2 = dynamic_cast&lt;Derived *&gt; (pb); } 在上面的代码段中，如果pb实际指向一个Derived类型的对象，pd1和pd2是一样的，并且对这两个指针执行Derived类型的任何操作都是安全的； 如果pb实际指向的是一个Base类型的对象，那么pd1将是一个指向该对象的指针，对它进行Derived类型的操作将是不安全且非法的（如访问m_szName），而pd2将是一个空指针(即0，因为dynamic_cast失败)。 另外要注意： dynamic_cast 转换时Base要有虚函数，否则会编译出错；static_cast则没有这个限制。这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表（关于虚函数表的概念，详细可见&lt;Inside c++ object model&gt;）中，只有定义了虚函数的类才有虚函数表，没有定义虚函数的类是没有虚函数表的。 dynamic_cast还支持交叉转换（cross cast）。如下代码所示。 class Base { public: int m_iNum; virtual void f(){} }; class Derived1 : public Base{ }; class Derived2 : public Base { }; void foo() { Derived1 *pd1 = new Drived1(); pd1-&gt;m_iNum = 100; Derived2 *pd2 = static_cast&lt;Derived2 *&gt;(pd1); //Compile error Derived2 *pd2 = dynamic_cast&lt;Derived2 *&gt;(pd1); //pd2 is NULL delete pd1; } 在函数foo中，使用static_cast进行转换是不被允许的，将在编译时出错；而使用 dynamic_cast的转换则是允许的，结果是空指针。 来源：为什么需要dynamic_cast强制转换？ 简单的说，当无法使用virtual函数的时候 reinterpret_cast (expression)是C++中强制类型转换符，操作符修改了操作数类型，但仅仅是重新解释了给出的对象的比特模型而没有进行二进制转换。eg: void *p ===&gt; int p type-id必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，再把该整数转换成原类型的指针，还可以得到原先的指针值）。 reinterpret_cast是为了映射到一个完全不同类型的意思，这个关键词在我们需要把类型映射回原有类型时用到它。 const_cast (expression)该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。 常量指针被转化成非常量指针，并且仍然指向原来的对象； 常量引用被转换成非常量引用，并且仍然指向原来的对象； 常量对象被转换成非常量对象。 Voiatile和const类试。举如下一例： class B{ public: int m_iNum; } void foo(){ const B b1; b1.m_iNum = 100; //comile error B b2 = const_cast&lt;B&gt;(b1); // 去掉const 属性 b2. m_iNum = 200; //fine } 上面的代码编译时会报错，因为b1是一个常量对象，不能对它进行改变； 使用const_cast把它转换成一个非常量对象，就可以对它的数据成员任意改变。注意：b1和b2是两个不同的对象。 比较static_cast Vs. reinterpret_castreinterpret_cast是为了映射到一个完全不同类型的意思，这个关键词在我们需要把类型映射回原有类型时用到它。我们映射到的类型仅仅是为了故弄玄虚和其他目的，这是所有映射中最危险的。(这句话是C++编程思想中的原话) static_cast 和 reinterpret_cast 操作符修改了操作数类型。它们不是互逆的； static_cast 在编译时使用类型信息执行转换，在转换执行必要的检测(诸如指针越界计算, 类型检查). 其操作数相对是安全的。另一方面；reinterpret_cast 仅仅是重新解释了给出的对象的比特模型而没有进行二进制转换，例子如下： int n=9; double d=static_cast &lt; double &gt; (n); 上面的例子中, 我们将一个变量从 int 转换到 double。这些类型的二进制表达式是不同的。 要将整数 9 转换到 双精度整数 9，static_cast 需要正确地为双精度整数 d 补足比特位。其结果为 9.0。而reinterpret_cast 的行为却不同: int n=9; double d=reinterpret_cast&lt;double &amp; &gt; (n); 这次, 结果有所不同. 在进行计算以后, d 包含无用值. 这是因为 reinterpret_cast 仅仅是复制 n 的比特位到 d, 没有进行必要的分析. 因此, 你需要谨慎使用 reinterpret_cast. C++primer第五章里写了编译器隐式执行任何类型转换都可由static_cast显示完成;reinterpret_cast通常为操作数的位模式提供较低层的重新解释 1、C++中的static_cast执行非多态的转换，用于代替C中通常的转换操作。因此，被做为隐式类型转换使用。比如： int i; float f = 166.7f; i = static_cast&lt;int&gt;(f); 此时结果，i的值为166。 2、C++中的reinterpret_cast主要是将数据从一种类型的转换为另一种类型。所谓“通常为操作数的位模式提供较低层的重新解释”也就是说将数据以二进制存在形式的重新解释。比如： int i; char *p = &quot;This is a example.&quot;; i = reinterpret_cast&lt;int&gt;(p); 此时结果，i与p的值是完全相同的。reinterpret_cast的作用是说将指针p的值以二进制（位模式）的方式被解释为整型，并赋给i，一个明显的现象是在转换前后没有数位损失。 C++的类型转换明显比C里面的用()的类型转换要严谨很多。首先，C++样式的类型转换编写 的代码更容易维护，想想看，只要搜索“static_cast”，就可以找出代码中所有使用了静态转换的代码，比C里面五花八门的 (long) (long*) (double )好找多了吧。另外，reinterpret_cast，看字面意思就知道，是保持二进制位不变，用另一种格式来重新解释，我们也知道计算机里面只有 bit,到底代表什么类型，整形还是浮点型，全在于应用程序怎么解释每一个bit，reinterpret_cast给了我们这么一个机会。而C里面要想 二进制重解释，你要么拷贝内存，要么还是用()来强制类型转换，某些特定情况下，()强制转换其实是二进制的重解释，毫无疑问，C风格的转换会让代码变得 难懂。","categories":[{"name":"C++","slug":"C","permalink":"jingg.me/categories/C/"}],"tags":[{"name":"类型转换","slug":"类型转换","permalink":"jingg.me/tags/类型转换/"},{"name":"static_cast","slug":"static-cast","permalink":"jingg.me/tags/static-cast/"},{"name":"dynamic_cast","slug":"dynamic-cast","permalink":"jingg.me/tags/dynamic-cast/"},{"name":"reinterpret_cast","slug":"reinterpret-cast","permalink":"jingg.me/tags/reinterpret-cast/"},{"name":"const_cast","slug":"const-cast","permalink":"jingg.me/tags/const-cast/"}]},{"title":"Java中四中内部类","slug":"Lang_Java_innerClass","date":"2016-05-28T04:22:33.000Z","updated":"2017-05-18T07:56:02.158Z","comments":true,"path":"2016/05/28/Lang_Java_innerClass/","link":"","permalink":"jingg.me/2016/05/28/Lang_Java_innerClass/","excerpt":"","text":"常规内部类public class A{ private int a = 100; class B{ //其中可以直接使用外部类A中的实例变量和方法 int b; } public void createB{ //在外部类方法中创建内部类实例 B c = new B(); } public static void main(){ A out = new A(); A.B in = new out.B(); //内部类通过A实例创建对象 } } 静态内部类（静态内部类与静态内部方法相似）由于static内部类不具有任何对外部类实例的引用，因此static内部类中不能使用this关键字来访问外部类中的实例成员，但是可以访问外部类中的static成员。 MyOuter.MyInner si=new MyOuter.MyInner();//静态内部类不通过外部实例就可以创建对象 局部内部类在方法体或语句块（包括方法、构造方法、局部块或静态初始化块）内部定义的类成为局部内部类。 局部内部类不能加任何访问修饰符，因为它只对局部块有效。 1.局部内部类只在方法体中有效，就想定义的局部变量一样，在定义的方法体外不能创建局部内部类的对象 1.方法定义局部内部类同方法定义局部变量一样，不能使用private、protected、public等访问修饰说明符修饰，也不能使用static修饰，但可以使用final和 abstract修饰 匿名内部类 定义类的最终目的是创建一个类的实例，但是如果某个类的实例只是用一次，则可以将类的定义与类的创建， 放到与一起完成，或者说在定义类的同时就创建一个类 new ClassOrInterfaceName(){ /*类体*/ } 匿名内部类可以继承一个类或实现一个接口，这里的ClassOrInterfaceName是匿名内部类所继承的类名或实现的接口名。 但匿名内部类不能同时实现一个接口和继承一个类，也不能实现多个接口。如果实现了一个接口，该类是Object类的直接子类， 匿名类继承一个类或实现一个接口，不需要extends和implements关键字。 由于匿名内部类没有名称，所以类体中不能定义构造方法，由于不知道类名也不能使用关键字来创建该类的实例。实际上匿名内部类的定义、构造、和第一次使用都发生在同样一个地方。此外，上式是一个表达式，返回的是一个对象的引用，所以可以直接使用或将其复制给一个对象变量。例： TypeName obj=new Name（）{ /*此处为类体*/ } 同样，也可以将构造的对象作为调用的参数。例： someMethod(new Name(){ /此处为类体/ } );","categories":[{"name":"Java","slug":"Java","permalink":"jingg.me/categories/Java/"}],"tags":[{"name":"内部类","slug":"内部类","permalink":"jingg.me/tags/内部类/"}]},{"title":"C++的const用法","slug":"Lang_CPP_const","date":"2016-05-28T04:22:33.000Z","updated":"2017-05-05T07:43:05.016Z","comments":true,"path":"2016/05/28/Lang_CPP_const/","link":"","permalink":"jingg.me/2016/05/28/Lang_CPP_const/","excerpt":"","text":"C++ const 允许指定一个语义约束，编译器会强制实施这个约束，允许程序员告诉编译器某值是保持不变的。如果在编程中确实有某个值保持不变，就应该明确使用const，这样可以获得编译器的帮助。const 有几种用法。下面将详细讲解。 const 全局变量 用法： const int a; // const data const int *p; // const data, non-const pointer int * const p; // non-const data, const pointer const int * const p; // const data, const pointer const 函数局部变量 (包括函数参数、返回值等) 用法：const int a; const int *p;int * const p;const int * const p; const int* function(const int *a); // 返回值必须传给const data,non-const pointer 的变量 void int function(const int&amp; a); const 成员变量 用法：成员常量不能被修改，只能在构造函数初始化列表中赋值 const 成员方法 用法： 不能修改任何成员变量（mutable修饰的变量除外），不能调用非const成员函数 定义格式：void function() const {} const 类对象、类指针、类引用 将Const类型转化为非Const类型的方法采用const_cast 进行转换。该运算符用来修改类型的const或volatile属性。","categories":[{"name":"C++","slug":"C","permalink":"jingg.me/categories/C/"}],"tags":[{"name":"const","slug":"const","permalink":"jingg.me/tags/const/"}]},{"title":"Android 权限的实现","slug":"Android_permission","date":"2016-05-28T04:22:33.000Z","updated":"2017-05-18T11:02:46.125Z","comments":true,"path":"2016/05/28/Android_permission/","link":"","permalink":"jingg.me/2016/05/28/Android_permission/","excerpt":"","text":"权限每个程序在安装时都有建立一个系统ID，如app_15，用以保护数据不被其它应用获取。Android根据不同的用户和组，分配不同权限，比如访问SD卡，访问网络等等。底层映射为Linux权限。 Android权限的实现 1) 第一层：由应用设置，修改AndroidManifest.xml，形如： 应用申请权限 1) 应用开发者通过AndroidManifest.xml中&lt;uses-permission&gt;指定对应权限，再映射到底层的用户和组，默认情况下不设定特殊的权限。 AndroidManifest加入权限后系统安装程序时会在图形界面中提示权限 2) 如果是缺少某个权限（程序中使用的某种权限而在AndroidManifest.xml中并未声名）， 程序运行时会在logcat中打印出错误信息requires &lt;permission&gt; 3) 与某个进程使用相同的用户ID 应用程序可与系统中已存在的用户使用同一权限，需要在AndroidManifest.xml中设置sharedUserId，如android:sharedUserId=&quot;android.uid.shared&quot;，作用是获得系统权限， 但是这样的程序属性只能在build整个系统时放进去（就是系统软件）才起作用，共享ID的程序必须是同一签名的 2) 第二层：框架层，权限对应组，frameworks/base/data/etc/platform.xml，形如： 3) 第三层：系统层，系统的权限，system/core/include/private/android_filesystem_config.h,形如： #define AID_INET 3003 //建立SOCKET的权限 …… { “inet”, AID_INET, }, 系统权限 特殊权限的用户 a) system uid 1000 b) radio uid 1001 permission权限查看 $ adb shell $ pm list permissions framework层对权限的判断 1) 相关源码实现frameworks/base/services/Java/com/android/server/PackageManagerService.java frameworks/base/services/java/com/android/server/am/ActivityManagerService.java 2) 在系统层，如何查看某个应用的权限a) 在应用进程开启时，ActivityManagerService.java会在logcat中输出该应用的权限，形如： I/ActivityManager(1730): Start proc com.anbdroid.phone for restart com.android.phone:pid=2605 uid=1000 gids={3002,3001,3003} 即它有3001,3002,3003三个权限：访问蓝牙和建立socket b) 注意：此打印输出在应用第一次启动时。如果进程已存在，需要先把对应进程杀掉，以保证该进程重新启动，才能显示 c) 具体实现，见： framewors/base/services/java/com/android/server/am/ActivityManagerService.java的 函数startProcessLocked()，其中取其组信息的具本语句是mContext.getPackageManager().getPackageGids(app.info.packageName); 参考http://wenku.baidu.com/view/7754a4360b4c2e3f5727634e.html","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"permission","slug":"permission","permalink":"jingg.me/tags/permission/"}]},{"title":"C++的static用法","slug":"Lang_CPP_static","date":"2016-05-28T04:22:33.000Z","updated":"2017-05-09T06:38:28.282Z","comments":true,"path":"2016/05/28/Lang_CPP_static/","link":"","permalink":"jingg.me/2016/05/28/Lang_CPP_static/","excerpt":"","text":"C++ 中static 关键字用法可以从两个方面来区分，一个是面向过程，另一个是面向对象。面向过程有三种用法，面向对象有两种用法。下文将详细讲解。 用法详解（从作用域，生命周期角度来解释） 面向过程 文件内全局static变量 （和C一样） 作用域：本文件内 生命周期：程序退出 函数内static变量 （和C一样） 作用域：本函数内 生命周期：程序退出 文件内static函数 （和C一样） 作用域：本文件内 生命周期：N/A 面向对象 类中static成员变量 用法：使用时不用实例化，与类实例无关。（静态数据成员存储在全局数据区，静态数据成员定义时要分配空间，所以不能在类声明中定义。应该在类外定义。此外，在类体外定义时不能指定static关键字）。 初始化格式：&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员&gt; = &lt;值&gt; 作用域：遵从类的public、private、protected访问规则 生命周期：程序退出 类中static成员方法 用法：可以引用static成员变量。无法访问属于类对象的非静态数据成员变量/函数。此外，类体外定义时不能指定static关键字 调用static成员方法方式： XClass::xxx_static_fun()、XClassInstant.xxx_static_fun()、XClassInstantP-&gt;xxx_static_fun() 作用域：遵从类的public、private、protected访问规则 生命周期：N/A 附1（可执行文件内存布局） .text 代码段存放可执行指令 .data 初始化后数据 { a. 只读数据区(const全局变量 字符串) b. 已初始化可读数据区——全局区(全局变量) c. 已初始化可读数据区——全局静态区(static全局变量) .bss 未初始化数据（只记录数据需要多少空间，不为其真正分配内存） a. 未初始化静态和全局变量 .heap 运行时malloc动态分配的数据占用空间 a. 动态内存分配 .stack 函数运行时分配的自动变量占用空间 a. 局部变量、函数参数 从可执行文件a.out的角度来讲，如果一个数据未被初始化那就不需要为其分配空间，所以.data和.bss一个重要的区别就是.bss并不占用可执行文件的大小，它只是记载需要多少空间来存储这些未初始化数据，而不分配实际的空间 附2（参考）http://blog.csdn.net/kerry0071/article/details/25741425/","categories":[{"name":"C++","slug":"C","permalink":"jingg.me/categories/C/"}],"tags":[{"name":"static","slug":"static","permalink":"jingg.me/tags/static/"}]},{"title":"Java反射：getClass   x.class Class.forName","slug":"Android_Java_reflect","date":"2016-05-27T07:13:00.000Z","updated":"2017-05-18T07:46:53.283Z","comments":true,"path":"2016/05/27/Android_Java_reflect/","link":"","permalink":"jingg.me/2016/05/27/Android_Java_reflect/","excerpt":"","text":"1. class装载验证流程Class的装载过程（也就是从字节码文件到生成类的实例这个过程）分为三个阶段loading（装载），linking（连接）和initializing（实例化） 1.1 加载装载类的第一个阶段通过类的全限定名(eg: com.company.Employee)取得类的二进制流转为方法区数据结构在Java堆中生成对应的java.lang.Class对象 1.2 链接 -&gt; 验证目的：保证Class流的格式是正确的 文件格式的验证 是否以0xCAFEBABE开头版本号是否合理元数据验证 是否有父类继承了final类？非抽象类实现了所有的抽象方法字节码验证 (很复杂) 运行检查栈数据类型和操作码数据参数吻合跳转指令指定到合理的位置符号引用验证 常量池中描述类是否存在访问的方法或字段是否存在且有足够的权限 1.3 链接 -&gt; 准备分配内存，并为类设置初始值 （方法区中，关于方法区请查看Java内存区域） public static int v=1;在准备阶段中，v会被设置为0在初始化的中才会被设置为1对于static final类型（常量），在准备阶段就会被赋上正确的值public static final int v=1; ###1.4 链接 -&gt; 解析 1.5 初始化执行类构造器 static变量 赋值语句static{}语句 2. 什么是类装载器ClassLoaderClassLoader是一个抽象类ClassLoader的实例将读入Java字节码将类装载到JVM中ClassLoader可以定制，满足不同的字节码流获取方式（譬如从网络中加载，从文件中加载）ClassLoader负责类装载过程中的加载阶段 3. Android中java反射使用Java的每个类必需被JVM加载到虚拟机中，然后就有一个运行时类对象，该Class对象中保存了创建对象所需的所有信息。 方法1.1：用于类提前已被加载，通过全限定名来获得类，法1——xxx.class可以用.class返回此 Object 的运行时类Class对象，如： //.class一般用于获得类型，JVM中加载已经加载过的类Class&lt;?&gt; clazz = com.android.systemui.statusbar.SystemBars.classclazz.newInstance(); //实例化 方法1.2：用于类提前已被加载，通过实例对象来获取类，法2——getClass也可以用getClass()获得。 //获得此对象后可以利用此Class对象的一些反射特性进行操作，例如：//使用前类已加载Class&lt;?&gt; clazz = this.getClass(); //用缺省构造函数创建一个该类的Class&lt;?&gt;对象clazz.newInstance(); //用缺省构造函数创建一个该类的对象clazz.getInterfaces(); //获得此类实现的接口信息clazz.getMethods(); //获得此类实现的所有公有方法 方法2： 加载类到JVM中(使用全限定名)，并初始化 ——Class.forNameClass&lt;?&gt; clazz = Class.forName(“类名，如’java.lang.Thread’ “); //动态加载类，并返回具有指定名的类的 Class 对象在加载完成后，一般还要调用Class下的newInstance( )静态方法来实例化对象以便操作 Class.forName有两个调用方法 1. 常用的 Class.forName(&quot;xx.xx&quot;) //查找并加载类，最后执行了类static代码 2. 多参数 Class.forName(&quot;xx.xx&quot;,true,CALLClass.class.getClassLoader()) //可指定是否初始化static语句，及指定类加载器 方法3：加载类到JVM(使用全限定名)，但不初始化——loadClassClass&lt;?&gt; clazz = loader.loadClass(“xx.xx”); 或者mContext.getClassLoader().loadClass(clsName); 都只是加载了类，但是没有执行类静态代码使用loadClass只有执行clazz.NewInstance()才能够初始化类 参考http://blog.csdn.net/sunyujia/article/details/2501709","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"reflect","slug":"reflect","permalink":"jingg.me/tags/reflect/"}]},{"title":"Java中newInstance()和new()","slug":"Lang_Java_newInstance","date":"2016-05-27T04:22:33.000Z","updated":"2017-05-18T07:52:22.735Z","comments":true,"path":"2016/05/27/Lang_Java_newInstance/","link":"","permalink":"jingg.me/2016/05/27/Lang_Java_newInstance/","excerpt":"","text":"在Java开发特别是数据库开发中，经常会用到Class.forName( )这个方法。通过查询Java Documentation我们会发现使用Class.forName( )静态方法的目的是为了动态加载类。在加载完成后，一般还要调用Class下的newInstance( )静态方法来实例化对象以便操作。因此，单单使用Class.forName( )是动态加载类是没有用的，其最终目的是为了实例化对象。 这里有必要提一下就是Class下的newInstance()和new有什么区别？，首先，newInstance( )是一个方法，而new是一个关键字，其次，Class下的newInstance()的使用有局限，因为它生成对象只能调用无参的构造函数，而使用new关键字生成对象没有这个限制。好，到此为止，我们总结如下：Class.forName(“”)返回的是类 classClass.forName(“”).newInstance()返回的是object有数据库开发经验朋友会发现，为什么在我们加载数据库驱动包的时候有的却没有调用newInstance( )方法呢？即:有的jdbc连接数据库的写法里是Class.forName(“xxx.xx.xx”);而有一些：Class.forName(xxx.xx.xx).newInstance()，为什么会有这两种写法呢？刚才提到，Class.forName(“”);的作用是要求JVM查找并加载指定的类，如果在类中有静态初始化器的话，JVM必然会执行该类的静态代码段。而在JDBC规范中明确要求这个Driver类必须向DriverManager注册自己，即任何一个JDBC Driver的Driver类的代码都必须类似如下： public class MyJDBCDriver implements Driver { static { DriverManager.registerDriver(new MyJDBCDriver()); } } 既然在静态初始化器的中已经进行了注册，所以我们在使用JDBC时只需要Class.forName(XXX.XXX);就可以了。Java中工厂模式经常使用newInstance()方法来创建对象，因此从为什么要使用工厂模式上可以找到具体答案。 例如： class c = Class.forName(“Example”); factory = (ExampleInterface)c.newInstance();其中ExampleInterface是Example的接口，可以写成如下形式： String className = “Example”; class c = Class.forName(className); factory = (ExampleInterface)c.newInstance();进一步可以写成如下形式： String className = readfromXMlConfig;//从xml 配置文件中获得字符串 class c = Class.forName(className); factory = (ExampleInterface)c.newInstance();上面代码已经不存在Example的类名称，它的优点是，无论Example类怎么变化，上述代码不变，甚至可以更换Example的兄弟类Example2 , Example3 , Example4……，只要他们继承ExampleInterface就可以。 从JVM的角度看，我们使用关键字new创建一个类的时候，这个类可以没有被加载。 但是使用newInstance()方法的时候，就必须保证：1、这个 类已经加载；2、这个类已经连接了。而完成上面两个步骤的正是Class的静态方法forName()所完成的，这个静态方法调用了启动类加载器，即加载 java API的那个加载器。 现在可以看出，newInstance()实际上是把new这个方式分解为两步，即首先调用Class加载方法加载某个类，然后实例化。 这样分步的好处是显而易见的。我们可以在调用class的静态加载方法forName时获得更好的灵活性，提供给了一种降耦的手段。 最后用最简单的描述来区分new关键字和newInstance()方法的区别：newInstance: 弱类型。低效率。只能调用无参构造。new: 强类型。相对高效。能调用任何public构造。","categories":[{"name":"Java","slug":"Java","permalink":"jingg.me/categories/Java/"}],"tags":[{"name":"newInstance","slug":"newInstance","permalink":"jingg.me/tags/newInstance/"},{"name":"new","slug":"new","permalink":"jingg.me/tags/new/"}]},{"title":"Java为什么支持反射机制?","slug":"Lang_Java_reflect","date":"2016-05-27T04:22:33.000Z","updated":"2017-05-18T07:48:20.665Z","comments":true,"path":"2016/05/27/Lang_Java_reflect/","link":"","permalink":"jingg.me/2016/05/27/Lang_Java_reflect/","excerpt":"","text":"Java为什么能够支持Reflection？ 答案是Java运行时仍然拥有类型信息，它包含了这个类一切：它有哪些字段、哪些方法，各是何种保护级别等等，还有这个类依赖于哪些类。在Java中，类信息以对象的形式存放，这些对象是一种元对象，它们的类型就是Class。拥有了这些信息，无论是动态创建对象还是调用某些方法都是轻而易举的。在C++中，通过RTTI（运行时类型识别），我们也可以知道类的一些信息，但为什么C++中却没有 Reflection，原因是类型信息不完整。RTTI这个名字本身就告诉我们，C++的类型信息是用来进行类型识别的，因此，它也不需要其它额外的信息。并不是C++无法做到这一点，而是C++不希望给用户增加额外的负担。有所得，必然有所失，因此，C++放弃了元对象。关于这一点，C++之父 Bjarne Stroustrup在他的《C++语言的设计与演化》的14.2.8节中进行了深入的讨论。 元对象是Java Reflection的物质基础，那它的精神基础又是什么呢？Java为什么要支持Reflection？ 经过上面的讨论，我们把这个问题再进一步，为什么Java要提供元对象？讨论这个问题，我们还要拉回到十年前，那时Java刚刚来到正式登上历史的舞台。Java实际上诞生在这之前的数年，那时候还叫Oak，环境所限使得这一划时代的杰作甫一出炉便被束之高阁。当Netscape掀起了为网络大戏的序幕，Java得以凤凰涅?，这其中很重要的一个原因就是Java是以网络为中心的。 仔细观察，我们会发现，Java的整个基础架构的设计都是为网络服务。首当其冲的便是Java中最著名的跨平台。其实，在Java之前的年代，人们也需要考虑平台之间的可移植性，但这种移植大多数集中在源码一级，这也就是C语言可以流行的原因之一，在单机环境下，平台的差异并不那么明显。网络的出现使平台之间差异凸现出来，因为网络可能会连接各种各样的计算机和设备。没错，还有设备，你也许知道Java最初的开发是和嵌入式设备相关的。一旦应用可以跨平台，程序开发和后期管理维护工作将得到极大的简化，可移植性也从源码级晋升到二进制级（Java字节码）。所以，跨平台实际上也是为了网络打基础。Java中另一个重要的买点??安全性与网络之间的关系更为密切，谁都可以想出几条理由，把二者关联起来。 再来具体看看Java的基础架构如何对网络进行支持的。还记得Java最初是怎么吸引人的吗？没错，Applet。熟悉原理的朋友都知道，Applet的运行是把远程的类文件下载到本地来执行的。相对于本地硬盘，网络给我们的感觉就是一个字????慢。如果Java采用传统可执行文件组织方式，即一个完整的可执行文件，把整个 Applet下载下来的运行，只怕等到花儿也谢了。Java采用的手法是把文件拆开，以类为单位进行组织，这就是我们今天见到的class文件。这样，执行的过程就变成第一个类下载之后就可以运行，大大节省了最初的等待时间。好的设计会把程序分成若干的模块，所以，绝大多数程序不可能写在一个类中。因此，类文件中必须包含它所用到类。对于引导部分，我们可以让它以特定的方式开始执行，比如把我们耳熟能详的main方法放在特定的字节，但对于没有定法的任意方法，是没有办法规定的，而一个类调用另一个类的方法就是这样随意，因此类文件中必须包含这个类方法的信息，进一步字段信息也会加进来，这样几乎一个完整类的信息就出来了，而这些信息对应的恰好是元对象。所以，元对象出现在Java基础架构中。有了元对象，Reflection也成了一件顺其自然的事情。有了Reflection，Java也就拥有了动态扩展的能力，这样就可以极大的提高程序的灵活性。 关于Java基础结构对网络的支持还可以再说几句。class文件经过了精心的设计，本身相当紧凑，其目的就是为了方便在网络上传输，而JAR文件的出现，其目的也是为了方便网络传输，因为如果每次只传输一个类，大量的时间都被浪费在建立网络连接的过程中，JAR文件使得一次传输多个类成为可能，而且我们还知道JAR文件中的数据是经过压缩的，这样可以进一步减少下载时间。Java基础架构对网络的支持，《深入Java虚拟机》（第二版）的4.3节进行了很好阐述，有兴趣不妨看一下。对Reflection思考让我有机会对Java本身的设计进行深入的思考。一个好的软件设计需要一个核心理念作为支撑，所有的一切都是围绕核心进行的，而对于Java，这个核心就是网络。一次有趣的思考体验！","categories":[{"name":"Java","slug":"Java","permalink":"jingg.me/categories/Java/"}],"tags":[{"name":"reflect","slug":"reflect","permalink":"jingg.me/tags/reflect/"}]},{"title":"Android 打印函数调用栈","slug":"Android_dumpstack","date":"2016-05-26T07:13:00.000Z","updated":"2017-05-18T09:39:32.504Z","comments":true,"path":"2016/05/26/Android_dumpstack/","link":"","permalink":"jingg.me/2016/05/26/Android_dumpstack/","excerpt":"","text":"0. ActivityThreadStackTraceElement st[]= Thread.currentThread().getStackTrace(); for(int i=0;i&lt;st.length;i++) System.out.println(i+&quot;:&quot;+st[i]); 1. Java层打印函数调用栈的方法方法1:StackTraceElement[] stes = new Throwable().getStackTrace(); if(stes.length &gt;= 1) { for(int i = 1; i &lt; stes.length; i++) { Log.d(TAG, &quot;File:&quot; + stes[i].getFileName() + &quot;, Line: &quot; + stes[i].getLineNumber() + &quot;, MethodName:&quot; + stes[i].getMethodName()); } for(StackTraceElement elem : stes) { System.out.println(elem.getClassName() + &quot; &quot; + elem.getMethodName()); } } 方法2:StackTraceElement[] stes = Thread.getAllStackTraces().get(Thread.currentThread()); for(StackTraceElement elem : stes) { System.out.println(elem.getClassName() + &quot; &quot; + elem.getMethodName()); } 方法3:Throwable throwable = new Throwable(); Log.w(LOGTAG, Log.getStackTraceString(throwable)); 或者 Log.d(TAG,Log.getStackTraceString(new Throwable())); 方法3:java.util.Map&lt;Thread, StackTraceElement[]&gt; ts = Thread.getAllStackTraces(); StackTraceElement[] stes = ts.get(Thread.currentThread()); for (StackTraceElement elem : stes) { Log.d(TAG, &quot;SS &quot;, elem.toString()); } 方法4:(new Exception()).printStackTrace(); 或 Exception ex = new Exception(&quot;dingran&quot;); ex.printStackTrace(); 备注:此方法打印出的TAG是在W/System.err(4275)中; 方法5:RuntimeException here = new RuntimeException(&quot;here&quot;); here.fillInStackTrace(); Log.w(TAG, &quot;Called: &quot; + this, here); 2. Native层打印调用栈方法1、打印C++函数调用栈:#include &lt;utils/CallStack.h&gt; CallStack stack; stack.update(); stack.dump(); LOCAL_SHARED_LIBRARIES += libutils 备注:下面操作是可选操作,但加上去之后会有一些额外的功能; #define HAVE_DLADDR 1 --&gt; 可以从lib中自己转成C++代码行,不需要手动反编译; #define HAVE_CXXABI 1 --&gt; 将C++已被name mangling的函数名转化为源文件中定义的函数名; 并在文件frameworks/base/libs/utils/Android.mk中大约105行(LOCAL_SHARED_LIBRARIES)后添加 ifeq ($(TARGET_OS),linux) LOCAL_SHARED_LIBRARIES += libdl endif重新编译push生成的libutils.so到/system/lib/目录下,重启设备;此外,由于CallStack.dump中使用的LOGD进行的打印,因此需要将后台的Log Level设置为D一下才能出来; 2、打印C函数调用栈:可以参考CallStack.cpp的实现,通过调用_Unwind_Backtrace完成; 3. Kernel层打印调用栈方法使用函数dump_stack()来打印出函数之间的调用关系;另外,使用宏BUG()、BUG_ON(xxxx)、WARN()、WARN_ON()、BUILD_BUG_ON()和函数panic(“foo is %ld\\n”,foo)也可以在内核中打印调试信息;其中,宏WARN_ON()最终会调用函数dump_stack();","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"trace","slug":"trace","permalink":"jingg.me/tags/trace/"},{"name":"stack","slug":"stack","permalink":"jingg.me/tags/stack/"}]},{"title":"Android Log","slug":"Android_Log","date":"2016-05-26T07:13:00.000Z","updated":"2017-05-18T09:58:24.708Z","comments":true,"path":"2016/05/26/Android_Log/","link":"","permalink":"jingg.me/2016/05/26/Android_Log/","excerpt":"","text":"Android 各层中日志打印功能的应用1. HAL层头文件： #include Android.mk中： LOCAL_SHARED_LIBRARIES := liblog libcutils 对应的级别 打印方法VERBOSE LOGV()DEBUG LOGD()INFO LOGI()WARN LOGW()ERROR LOGE() 方法：LOGD(“%d, %s”, int, char* ) 2. JNI层头文件： #include 对应的级别 打印方法VERBOSE LOGV()DEBUG LOGD()INFO LOGI()WARN LOGW()ERROR LOGE() 方法：LOGD(“%d, %s”, int, char* ) 3. FRAMEWORK层import android.util.Slog; 对应的级别 打印方法VERBOSE Slog.v()DEBUG Slog.d()INFO Slog.i()WARN Slog.w()ERROR Slog.e() 方法：Slog.d(TAG, “something to say.”); 4. Java层import android.util.Log; 对应的级别 打印方法VERBOSE Log.v()DEBUG Log.d()INFO Log.i()WARN Log.w()ERROR Log.e() 方法：Log.d(TAG, “something to say.”); 一、LOG等级：Verbose,Debug,Info,Warn,Error, Assert,Suppress】Verbose最低级别，什么信息都输出；A是最高级别的日志，即assert；S表示Suppress，即停止该日志的输出。 二、选用标准：Verbose：开发调试过程中一些详细信息，Verbose等级的Log，请不要在user版本中出现 Java示例 import android.os.Build; import android.util.Log final public Boolean isEng =Build.TYPE.equals(“eng”); if (isEng) Log.v(“LOG_TAG”,“LOG_MESSAGE”); C/C++示例 #include ———–C/C++示例———- char value[PROPERTY_VALUE_MAX]; int isEng=0; property_get(“ro.build.type”,value, “user”); isEng=strcmp(value, “eng”); if (isEng) ALOGV(); Debug: 用于调试的信息，编译进产品，但可以在运行时关闭，Debug等级的log,默认不开启，通过终端命令开启; Java示例 import android.util.Log ——————————— final String TAG=”MyActivity”; final public Boolean LOG_DEBUG = Log.isLoggable(TAG, Log.DEBUG); if (LOG_DEBUG) Log.d(“LOG_TAG”,“LOG_MESSAGE”); 运行时开启log: 在终端输入：setprop log.tag.MyActivity DEBUG 运行时关闭log: 在终端输入：setprop log.tag.MyActivity INFO C/C++示例 #include —————– #define LOG_CTL &quot;debug.MyActivity.enablelog&quot; charvalue[PROPERTY_VALUE_MAX]; int isDebug=0; property_get(LOG_CTL, value, &quot;0&quot;); isDebug = strcmp(value,&quot;1&quot;); if (isDebug) ALOGD(); 运行时开启log: 在终端输入：setprop debug.MyActivity.enablelog 1 运行时关闭log: 在终端输入：setprop debug.MyActivity.enablelog 0 附：Log.isLoggable(TAG, log.DEBUG) //这个函数表示通过setprop设置的level需要小于DEBUG，值才为True。（默认setprop配置的值是INFO，INFO&gt;DEBUG所以你不配置时，值为false的），通过setprop log.tag. 通过设置属性的方式来改变默认level，也可以将这些属性按照log.tag.=的形式，写入/data/local.prop中； Info:例如一些运行时的状态信息，这些状态信息在出现问题的时候能提供帮助。Warn：警告系统出现了异常，即将出现错误。Error：系统已经出现了错误。 注：Info、Warn、Error等级的Log禁止作为普通的调试信息使用，这些等级的Log是系统出现问题时候的重要分析线索，如果随意使用，将给Log分析人员带来极大困扰。请参考前面的等级介绍合理使用。 注2：禁止使用new Exception(“print trace”).printStackTrace()或者Log. getStackTraceString(Exception)方式打印普通调试信息，因为这种方式打印Log非常消耗系统资源。此种方式打印Log一般只出现try..catch某个异常使用。 注3：Log的tag命名，使用Activity名称或者类、模块的名称，不要出现自己的姓名拼音或其他简称。在c++/c代码中调用ALOGD等宏函数，参数没有传入tag,需要在文件头部#define LOG_TAG”YOUR_TAG_NAME”。 注4：Log的内容，不要出现公司名称、个人名称或相关简称，Log内容不要出现无意义的内容，如连续的等号或星号或连续的数字等，Log内容要方便其他分析Log的人员查看。 注5：Log输出的频率需要控制,例如1s打印一次的Log，尽量只在eng版本使用，user版本如需开启，请默认关闭，通过设置setprop命令来开启。 三、使用方法c++、c 层输出log： #include ALOGV(), ALOGD(), ALOGI(), ALOGW(), ALOGE() Java层输出log：import android.util.LogLog.v(String tag, String msg), Log.d(String tag, String msg),Log.i(String tag, String msg), Log.w(String tag, String msg), Log.e(String tag, String msg) 四、log显示格式log示例：I/SysInfoService( 488): SysInfoWorkThread running 等级/TAG(PID) :消息 五、过滤logcat消息过滤 logcat -c 清除log logcat -s TAG:D -v [process只显示pid] [tag 只显示 priority/Tag] [thread 显示process:thread and priority/tag] [raw只显示message][time显示date-time-priority/Tag PID ][long 将元数据和消息分行] 六、Java核心库打印Java核心库在Android工程的\\libcore\\luni\\src\\main\\java目录下。在Android的java核心库中是无法使用Logcat打印的，因为Android的java层要使用Java库，即Java库是Android的Java运行的前提，所以。。。 经过调试，发现其实运用Java的Logger可以很简单的实现(或许Android已经做了处理)，在adb logcat中输出。好了，演示一下。 引入包import java.util.logging.Logger;static Logger logger = Logger.getLogger(“mytag”);logger.info(“blala”);然后在adb logcat直接输出就行了。标签是mytag","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"log","slug":"log","permalink":"jingg.me/tags/log/"},{"name":"trace","slug":"trace","permalink":"jingg.me/tags/trace/"}]},{"title":"Android HAL 模型","slug":"Android_HAL","date":"2016-04-26T02:37:33.000Z","updated":"2017-05-10T11:57:24.529Z","comments":true,"path":"2016/04/26/Android_HAL/","link":"","permalink":"jingg.me/2016/04/26/Android_HAL/","excerpt":"","text":"前言暂时省略… Android HAL层模型直接上图:","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"hal","slug":"hal","permalink":"jingg.me/tags/hal/"}]},{"title":"HTTP MITM","slug":"Protocol_HTTP_MITM","date":"2016-04-26T02:37:33.000Z","updated":"2017-05-17T08:05:25.829Z","comments":true,"path":"2016/04/26/Protocol_HTTP_MITM/","link":"","permalink":"jingg.me/2016/04/26/Protocol_HTTP_MITM/","excerpt":"首先明确一个概念：非对称加密算法 非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。HTTPS协议中，前面的握手过程，服务器会将公钥发给客户端，客户端验证后生成一个密钥用公钥加密后发送给服务器，成功后建立通信。通信过程客户端将请求数据用得到的公钥加密后，发给服务器，服务器用私钥解密。服务器用客户端给的密钥加密响应报文，发回给客户端，客户端用自己存的密钥解密。 忽略掉其他例如确定协议和版本号之类的环节，提炼出来的重要环节如下：","text":"首先明确一个概念：非对称加密算法 非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。HTTPS协议中，前面的握手过程，服务器会将公钥发给客户端，客户端验证后生成一个密钥用公钥加密后发送给服务器，成功后建立通信。通信过程客户端将请求数据用得到的公钥加密后，发给服务器，服务器用私钥解密。服务器用客户端给的密钥加密响应报文，发回给客户端，客户端用自己存的密钥解密。 忽略掉其他例如确定协议和版本号之类的环节，提炼出来的重要环节如下： 公私玥A用于非对称式加密，密钥B只用于普通的对称式加密。 简而言之就是这样，那么问题来了：你作为一个中间人，你没有服务器私钥A，是不能解密客户端发送的内容的，如果你没有客户端自己生成的密钥B，所以你也不能解密客户端发过去的内容的。请注意：这两个私钥都是两端各自保存，而私钥A是只保存在服务器上，从不对外发送的。 结果就是，你收发的数据，他都能看到——————但是他不能解密，看不懂。 这只是最普通的劫持HTTP的方式，HTTPS就是为了解决题主所说的这个中间人攻击而产生的，然而题主并没有去理解HTTPS的工作原理，而用HTTP的原始思路继续去思考HTTPS，所以题主这个方法是完全不可行的。 继续往下想，或许有人会觉得： 如果你自己签发一对非对称式公私钥C，还有密钥D，然后作为一个中间人。在一开始的通信环节，用公私钥C替代公私钥A，用密钥D替代密钥B。这样分发给对应的服务器和客户端，这样他们发给自己的信息，自己都能解密。然后自己再用真正的公钥A把解密后的信息重新加密发给服务器骗取响应报文，把响应报文用密钥B（前面客户端用公钥C加密后，被中间人用私钥C解密的刀）重新加密发回给客户端骗取新的请求报文。这样岂不是可以瞒天过海？ 那么在图中所示的验证环节，因为你的证书是自己签发的，所以证书跟指纹拿去去系统里可信颁发机构的证书那一对，肯定对不上。如果你要假冒其他机构颁发证书，因为你没有颁发机构的密钥，那么你颁发的证书，结果指纹肯定没办法对上，还是一样会报警。系统信任的颁发机构一般都是权威的大机构，当然你也可以自己导入自己信任的机构的证书，用来验证签名。如果要实现HTTPS下的中间人攻击，你应该让自己的根证书进入系统里，让自己成为裁判。 还有人就说了，我可以让用户回落到HTTP协议啊，中间人用HTTPS跟服务器通信，然后用HTTP跟客户端通信——要知道大部分用户在地址栏输入URL时，并没有指定协议的习惯，都是打www开头而不是打https://开头，能用HTTPS全是Web Server上80端口301 Location到HTTPS的功劳。 看起来似乎中间人充当了一个替换页面里HTTPS资源到HTTP的反向代理，好像可行性还是很高。但是只要利用HSTS（HTTP Strict Transport Security，RFC6797）就可以解决这个问题。通过在HTTP Header中加入Strict-Transport-Security的声明，告诉浏览器在一定时间内必须通过HTTPS协议访问本域名下的资源。这种情况下，只要用户曾经在安全网络环境下访问过一次某站，中间人在指定时间内也无法让其回落到HTTP。","categories":[{"name":"Network","slug":"Network","permalink":"jingg.me/categories/Network/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"jingg.me/tags/HTTP/"},{"name":"MITM","slug":"MITM","permalink":"jingg.me/tags/MITM/"},{"name":"security","slug":"security","permalink":"jingg.me/tags/security/"}]},{"title":"Android 升级","slug":"Android_update","date":"2016-04-26T02:37:33.000Z","updated":"2017-05-18T06:53:49.076Z","comments":true,"path":"2016/04/26/Android_update/","link":"","permalink":"jingg.me/2016/04/26/Android_update/","excerpt":"","text":"TODO… 升级包 OTA 包 增量包 编译制作过程to do 升级流程http://blog.csdn.net/chenyufei1013/article/details/12705719","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"recovery","slug":"recovery","permalink":"jingg.me/tags/recovery/"},{"name":"OTA","slug":"OTA","permalink":"jingg.me/tags/OTA/"},{"name":"升级","slug":"升级","permalink":"jingg.me/tags/升级/"},{"name":"update.img","slug":"update-img","permalink":"jingg.me/tags/update-img/"}]},{"title":"Linux 文件操作API","slug":"Linux_FileOperationAPI","date":"2015-11-29T16:00:00.000Z","updated":"2017-04-28T11:02:10.812Z","comments":true,"path":"2015/11/30/Linux_FileOperationAPI/","link":"","permalink":"jingg.me/2015/11/30/Linux_FileOperationAPI/","excerpt":"","text":"open#include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; int open(const char *pathname, int flags); //打开一个现有的文件 int open(const char *pathname, int flags, mode_t mode); //打开文件不存在，则先创建 【flags】:---------- O_RDONLY, O_WRONLY, or O_RDWR. 这三个之一必备 O_APPEND: The file is opened in append mode. O_ASYNC: This feature is available only for terminals, pseudoterminals, sockets, pipes and FIFOs O_CLOEXEC: Enable the close-on-exec flag for the new file descriptor. 了解这个选项需要明白fork后跟随exec和fork后不跟随exec的区别 fork之后若跟随执行exec后，该进程执行的程序完全替换为新程序，而新程序则从其main函数开始执行。因为调用exec并不创建新进程，所以先后的进程ID并未改变。exec只是用一个全新的程序替换了当前进程的正文、数据、堆和栈段。 也就是说之前的打开的文件描述符fd会被清理掉，导致打开的文件句柄无法释放，所以有了这个选项，在当前进程执行exec族函数时，会先做一个清理工作，close掉当前进程的文件描述符，再载入要执行的程序到当前进程环境。 O_CREAT:- 【mode】: （如果是新建文件，就设置初始访问权限） S_IRWXU 00700 user (file owner) has read, write and execute permission S_IRUSR 00400 user has read permission S_IWUSR 00200 user has write permission S_IXUSR 00100 user has execute permission S_IRWXG 00070 group has read, write and execute permission S_IRGRP 00040 group has read permission S_IWGRP 00020 group has write permission S_IXGRP 00010 group has execute permission S_IRWXO 00007 others have read, write and execute permission S_IROTH 00004 others have read permission S_IWOTH 00002 others have write permission S_IXOTH 00001 others have execute permission 多个模式可位或 bitwise-or O_DIRECT: Try to minimize cache effects of the I/O to and from this file. O_DIRECTORY: If pathname is not a directory, cause the open to fail. O_EXCL: 如果同时指定了O_CREAT，而文件已经存在，则导致调用出错 O_LARGEFILE: O_NOATIME: O_NOCTTY: 如果pathname指的是终端设备(tty)，则不将此设备分配作为此进程的控制终端 O_NOFOLLOW O_NONBLOCK : When possible, the file is opened in nonblocking mode. O_PATH: O_SYNC: The file is opened for synchronous I/O. Any write(2)s on the resulting file descriptor will block the calling process until the data has been physically written to the underlying hardware. 只在数据被写入外存或者其他设备之后操作才返回 O_TRUNC: If the file already exists and is a regular file and the open mode allows writing (i.e., is O_RDWR or O_WRONLY) it will be truncated to length 0. 如果文件存在，而且为读写或只写方式打开，则将其长度截断为0 文件类型ls -l drwxr-xr-x. 2 anxier anxier 4096 1月 15 00:29 desktop 第一栏的信息包含10字符。第1个字符，表示文件的类型；第2～4位，代表文件所有者（User）的权限，分别为读、写、执行；第5～7位，代表文件所有者的同组用户（Group）的权限，分别是读、写、执行；第8～10位，代表其他用户（Other）的权限，分别为读、写、执行。 1 2 3 4 5 6 7 8 9 10 -/l/c/s/d/b/p r/- w/- x/- r/- w/- x/- r/- w/- x/- - 普通文件 d 目录文件 文本文件和二进制文件。 l 链接文件 b 块设备文件 c 字符设备文件 p 管道文件 用于在进程间传递数据 s 套接口文件 ioctl#include &lt;sys/ioctl.h&gt; int ioctl(int d, int request, ...); request: ---- TIOCSETD int *ldisc change the line discipline: TTYDISC termios interactive line discipline TABLDISC tablet line discipline SLIPDISC serial IP line discipline PPPDISC PPP line discipline TIOCGETD int *ldisc return the current line discipline TIOCSBRK set the terminal into BREAK condition TIOCCBRK clear the terminal BREAK condition TIOCSDTR assert data terminal ready TIOCCDTR clear data terminal ready TIOCGPGRP int *tpgrp return the terminal&apos;s process group TIOCSPGRP int *tpgrp associate the terminal&apos;s process group TIOCGETA struct termios *term get the terminal&apos;s termios attributes TIOCSETA struct termios *term set the terminal&apos;s termios attributes TIOCSETAW struct termios *term set the termios attrs after any output completes TIOCSETAF struct termios *term after any output completes, clear input and set termios attrs TIOCOUTQ int *num current number of characters in the output queue TIOCSTI char *cp manually send a character to the terminal TIOCSTOP stop output (like typing ^S) TIOCSTART start output (like typing ^Q) TIOCSCTTY make this the controlling terminal for the process TIOCDRAIN wait until all output is drained TIOCEXCL set exclusive use on the terminal TIOCNXCL clear exclusive use of the terminal TIOCFLUSH int *what clear input/output if `what&apos; has FREAD/FWRITE set TIOCGWINSZ struct winsize *ws get the winsize information TIOCSWINSZ struct winsize *ws set the winsize information TIOCCONS int *on redirect kernel console messages TIOCMSET int *state set the modem state bit flags according to the following: TIOCM_LE Line Enable TIOCM_DTR Data Terminal Ready TIOCM_RTS Request To Send TIOCM_ST Secondary Transmit TIOCM_SR Secondary Receive TIOCM_CTS Clear To Send TIOCM_CAR Carrier Detect TIOCM_CD Carrier Detect (synonym) TIOCM_RNG Ring Indication TIOCM_RI Ring Indication (synonym) TIOCM_DSR Data Set Ready TIOCMGET int *state get the modem state bit flags TIOCMBIS int *state add modem state bit flags, OR-ing in the new states TIOCMBIC int *state clear modem state bit flags","categories":[{"name":"Linux","slug":"Linux","permalink":"jingg.me/categories/Linux/"}],"tags":[{"name":"open","slug":"open","permalink":"jingg.me/tags/open/"},{"name":"ioctl","slug":"ioctl","permalink":"jingg.me/tags/ioctl/"}]},{"title":"Android NDK移植杂项","slug":"Android_NDKPorting_Za","date":"2015-11-29T16:00:00.000Z","updated":"2017-04-27T12:45:05.299Z","comments":true,"path":"2015/11/30/Android_NDKPorting_Za/","link":"","permalink":"jingg.me/2015/11/30/Android_NDKPorting_Za/","excerpt":"","text":"1android上gcc编译与linux上有点点差别： ndk中gcc不需要需要显式指定-lpthread。Android pthread系列函数libc_bionic.a(即bionic C库)中，所以在默认就会链接。","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"jingg.me/tags/Android/"},{"name":"NDK","slug":"NDK","permalink":"jingg.me/tags/NDK/"}]},{"title":"Android 源码目录解析","slug":"Android_SourceCodePathGuide","date":"2015-11-29T16:00:00.000Z","updated":"2017-04-27T04:15:43.246Z","comments":true,"path":"2015/11/30/Android_SourceCodePathGuide/","link":"","permalink":"jingg.me/2015/11/30/Android_SourceCodePathGuide/","excerpt":"Android 源码目录繁多，本文旨在更详尽做出说明。.├── abi├── art├── bionic├── bootable├── build├── cts├── dalvik├── developers├── development├── device├── docs├── external├── frameworks├── hardware├── libcore├── libnativehelper├── ndk├── packages├── pdk├── prebuilts├── sdk├── system└── tools 待续。。。","text":"Android 源码目录繁多，本文旨在更详尽做出说明。.├── abi├── art├── bionic├── bootable├── build├── cts├── dalvik├── developers├── development├── device├── docs├── external├── frameworks├── hardware├── libcore├── libnativehelper├── ndk├── packages├── pdk├── prebuilts├── sdk├── system└── tools 待续。。。 bionicbuilddeviceframeworksframeworks/native/cmds/servicemanager servicemanager 进程 hardwarelibcorepackagessystem","categories":[{"name":"Android","slug":"Android","permalink":"jingg.me/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"jingg.me/tags/Android/"},{"name":"Source","slug":"Source","permalink":"jingg.me/tags/Source/"},{"name":"Code","slug":"Code","permalink":"jingg.me/tags/Code/"}]}]}